// Copyright 2019 Polyaxon, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Experiment service
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0
 * Contact: contact@polyaxon.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := ptypes.MarshalAny(foo)      ...      foo := &pb.Foo{}      if err := ptypes.UnmarshalAny(any, foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use 'type.googleapis.com/full.type.name' as the type URL and the unpack methods only use the fully qualified type name after the last '/' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface ProtobufAny
 */
export interface ProtobufAny {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof ProtobufAny
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @type {string}
     * @memberof ProtobufAny
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface V1CodeReference
 */
export interface V1CodeReference {
    /**
     * 
     * @type {string}
     * @memberof V1CodeReference
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CodeReference
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CodeReference
     */
    commit?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CodeReference
     */
    updated_at?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CodeReference
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CodeReference
     */
    git_url?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1CodeReference
     */
    is_dirty?: boolean;
}

/**
 * 
 * @export
 * @interface V1CodeReferenceBodyRequest
 */
export interface V1CodeReferenceBodyRequest {
    /**
     * 
     * @type {V1OwnedEntityIdRequest}
     * @memberof V1CodeReferenceBodyRequest
     */
    entity?: V1OwnedEntityIdRequest;
    /**
     * 
     * @type {V1CodeReference}
     * @memberof V1CodeReferenceBodyRequest
     */
    CodeReference?: V1CodeReference;
}

/**
 * 
 * @export
 * @interface V1Dict
 */
export interface V1Dict {
    /**
     * 
     * @type {Array<V1KV>}
     * @memberof V1Dict
     */
    kv?: Array<V1KV>;
}

/**
 * 
 * @export
 * @interface V1Experiment
 */
export interface V1Experiment {
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    unique_name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Experiment
     */
    tags?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof V1Experiment
     */
    deleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    updated_at?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    started_at?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    finished_at?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    is_managed?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    spec?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    backend?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    framework?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    last_status?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    code_reference?: string;
    /**
     * 
     * @type {V1Dict}
     * @memberof V1Experiment
     */
    resources?: V1Dict;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    readme?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1Experiment
     */
    bookmarked?: boolean;
    /**
     * 
     * @type {V1Dict}
     * @memberof V1Experiment
     */
    params?: V1Dict;
    /**
     * 
     * @type {V1Dict}
     * @memberof V1Experiment
     */
    run_env?: V1Dict;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    build_job?: string;
    /**
     * 
     * @type {V1Dict}
     * @memberof V1Experiment
     */
    data_refs?: V1Dict;
    /**
     * 
     * @type {V1Dict}
     * @memberof V1Experiment
     */
    artifact_refs?: V1Dict;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    original?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    cloning_strategy?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    experiment_group?: string;
    /**
     * 
     * @type {number}
     * @memberof V1Experiment
     */
    num_jobs?: number;
    /**
     * 
     * @type {boolean}
     * @memberof V1Experiment
     */
    has_tensorboard?: boolean;
    /**
     * 
     * @type {V1Dict}
     * @memberof V1Experiment
     */
    last_metric?: V1Dict;
}

/**
 * 
 * @export
 * @interface V1ExperimentBodyRequest
 */
export interface V1ExperimentBodyRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ExperimentBodyRequest
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ExperimentBodyRequest
     */
    project?: string;
    /**
     * 
     * @type {V1Experiment}
     * @memberof V1ExperimentBodyRequest
     */
    experiment?: V1Experiment;
}

/**
 * 
 * @export
 * @interface V1ExperimentStatus
 */
export interface V1ExperimentStatus {
    /**
     * 
     * @type {string}
     * @memberof V1ExperimentStatus
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ExperimentStatus
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ExperimentStatus
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ExperimentStatus
     */
    updated_at?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ExperimentStatus
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ExperimentStatus
     */
    message?: string;
}

/**
 * 
 * @export
 * @interface V1KV
 */
export interface V1KV {
    /**
     * 
     * @type {string}
     * @memberof V1KV
     */
    key?: string;
    /**
     * 
     * @type {ProtobufAny}
     * @memberof V1KV
     */
    value?: ProtobufAny;
}

/**
 * 
 * @export
 * @interface V1ListExperimentStatusesResponse
 */
export interface V1ListExperimentStatusesResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListExperimentStatusesResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1ExperimentStatus>}
     * @memberof V1ListExperimentStatusesResponse
     */
    results?: Array<V1ExperimentStatus>;
    /**
     * 
     * @type {string}
     * @memberof V1ListExperimentStatusesResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListExperimentStatusesResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListExperimentsResponse
 */
export interface V1ListExperimentsResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListExperimentsResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1Experiment>}
     * @memberof V1ListExperimentsResponse
     */
    results?: Array<V1Experiment>;
    /**
     * 
     * @type {string}
     * @memberof V1ListExperimentsResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListExperimentsResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1OwnedEntityIdRequest
 */
export interface V1OwnedEntityIdRequest {
    /**
     * 
     * @type {string}
     * @memberof V1OwnedEntityIdRequest
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof V1OwnedEntityIdRequest
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof V1OwnedEntityIdRequest
     */
    id?: string;
}

/**
 * 
 * @export
 * @interface V1ProjectBodyRequest
 */
export interface V1ProjectBodyRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ProjectBodyRequest
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ProjectBodyRequest
     */
    project?: string;
}

/**
 * 
 * @export
 * @interface V1StatusResponse
 */
export interface V1StatusResponse {
    /**
     * 
     * @type {string}
     * @memberof V1StatusResponse
     */
    status?: string;
}


/**
 * ExperimentServiceApi - fetch parameter creator
 * @export
 */
export const ExperimentServiceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Archive experiment
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveExperiment(owner: string, project: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling archiveExperiment.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling archiveExperiment.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling archiveExperiment.');
            }
            const localVarPath = `/v1/{owner}/{project}/experiments/{id}/archive`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Bookmark experiment
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkExperiment(owner: string, project: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling bookmarkExperiment.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling bookmarkExperiment.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling bookmarkExperiment.');
            }
            const localVarPath = `/v1/{owner}/{project}/experiments/{id}/bookmark`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new experiment
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {V1ExperimentBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExperiment(owner: string, project: string, body: V1ExperimentBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createExperiment.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling createExperiment.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createExperiment.');
            }
            const localVarPath = `/v1/{owner}/{project}/experiments`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ExperimentBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new experiment status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExperimentStatus(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createExperimentStatus.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling createExperimentStatus.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling createExperimentStatus.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createExperimentStatus.');
            }
            const localVarPath = `/v1/{owner}/{project}/experiments/{id}/statuses`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1OwnedEntityIdRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete experiment
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExperiment(owner: string, project: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteExperiment.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling deleteExperiment.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteExperiment.');
            }
            const localVarPath = `/v1/{owner}/{project}/experiments/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete experiments
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExperiments(owner: string, project: string, body: V1OwnedEntityIdRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteExperiments.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling deleteExperiments.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling deleteExperiments.');
            }
            const localVarPath = `/v1/{owner}/{project}/experiments/delete`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1OwnedEntityIdRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get experiment
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperiment(owner: string, project: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getExperiment.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getExperiment.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getExperiment.');
            }
            const localVarPath = `/v1/{owner}/{project}/experiments/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get experiment code ref
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperimentCodeRef(owner: string, project: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getExperimentCodeRef.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getExperimentCodeRef.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getExperimentCodeRef.');
            }
            const localVarPath = `/v1/{owner}/{project}/experiments/{id}/coderef`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get experiment code ref
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_id Unique integer identifier of the entity
         * @param {V1CodeReferenceBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        greateExperimentCodeRef(entity_owner: string, entity_project: string, entity_id: string, body: V1CodeReferenceBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'entity_owner' is not null or undefined
            if (entity_owner === null || entity_owner === undefined) {
                throw new RequiredError('entity_owner','Required parameter entity_owner was null or undefined when calling greateExperimentCodeRef.');
            }
            // verify required parameter 'entity_project' is not null or undefined
            if (entity_project === null || entity_project === undefined) {
                throw new RequiredError('entity_project','Required parameter entity_project was null or undefined when calling greateExperimentCodeRef.');
            }
            // verify required parameter 'entity_id' is not null or undefined
            if (entity_id === null || entity_id === undefined) {
                throw new RequiredError('entity_id','Required parameter entity_id was null or undefined when calling greateExperimentCodeRef.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling greateExperimentCodeRef.');
            }
            const localVarPath = `/v1/{entity.owner}/{entity.project}/experiments/{entity.id}/coderef`
                .replace(`{${"entity.owner"}}`, encodeURIComponent(String(entity_owner)))
                .replace(`{${"entity.project"}}`, encodeURIComponent(String(entity_project)))
                .replace(`{${"entity.id"}}`, encodeURIComponent(String(entity_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1CodeReferenceBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List archived experiments
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedExperiments(owner: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listArchivedExperiments.');
            }
            const localVarPath = `/v1/archives/{owner}/experiments`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked experiments
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedExperiments(owner: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listBookmarkedExperiments.');
            }
            const localVarPath = `/v1/bookmarks/{owner}/experiments`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List experiment statuses
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExperimentStatuses(owner: string, project: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listExperimentStatuses.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling listExperimentStatuses.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listExperimentStatuses.');
            }
            const localVarPath = `/v1/{owner}/{project}/experiments/{id}/statuses`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List experiments
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExperiments(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listExperiments.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling listExperiments.');
            }
            const localVarPath = `/v1/{owner}/{project}/experiments`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restart experiment
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartExperiment(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling restartExperiment.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling restartExperiment.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling restartExperiment.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling restartExperiment.');
            }
            const localVarPath = `/v1/{owner}/{project}/experiments/{id}/restart`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1OwnedEntityIdRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore experiment
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreExperiment(owner: string, project: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling restoreExperiment.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling restoreExperiment.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling restoreExperiment.');
            }
            const localVarPath = `/v1/{owner}/{project}/experiments/{id}/restore`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resume experiment
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeExperiment(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling resumeExperiment.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling resumeExperiment.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling resumeExperiment.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling resumeExperiment.');
            }
            const localVarPath = `/v1/{owner}/{project}/experiments/{id}/resume`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1OwnedEntityIdRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start experiment tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startExperimentTensorboard(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling startExperimentTensorboard.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling startExperimentTensorboard.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling startExperimentTensorboard.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling startExperimentTensorboard.');
            }
            const localVarPath = `/v1/{owner}/{project}/experiments/{id}/tensorboard/start`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1OwnedEntityIdRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop experiment
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopExperiment(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling stopExperiment.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling stopExperiment.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling stopExperiment.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling stopExperiment.');
            }
            const localVarPath = `/v1/{owner}/{project}/experiments/{id}/stop`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1OwnedEntityIdRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop experiment tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopExperimentTensorboard(owner: string, project: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling stopExperimentTensorboard.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling stopExperimentTensorboard.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling stopExperimentTensorboard.');
            }
            const localVarPath = `/v1/{owner}/{project}/experiments/{id}/tensorboard/stop`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop experiments
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1ProjectBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopExperiments(owner: string, project: string, body: V1ProjectBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling stopExperiments.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling stopExperiments.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling stopExperiments.');
            }
            const localVarPath = `/v1/{owner}/{project}/experiments/stop`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ProjectBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary UnBookmark experiment
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unBookmarkExperiment(owner: string, project: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling unBookmarkExperiment.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling unBookmarkExperiment.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling unBookmarkExperiment.');
            }
            const localVarPath = `/v1/{owner}/{project}/experiments/{id}/unbookmark`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update experiment
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} experiment_id Unique integer identifier
         * @param {V1ExperimentBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExperiment2(owner: string, project: string, experiment_id: string, body: V1ExperimentBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateExperiment2.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling updateExperiment2.');
            }
            // verify required parameter 'experiment_id' is not null or undefined
            if (experiment_id === null || experiment_id === undefined) {
                throw new RequiredError('experiment_id','Required parameter experiment_id was null or undefined when calling updateExperiment2.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateExperiment2.');
            }
            const localVarPath = `/v1/{owner}/{project}/experiments/{experiment.id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"experiment.id"}}`, encodeURIComponent(String(experiment_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ExperimentBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExperimentServiceApi - functional programming interface
 * @export
 */
export const ExperimentServiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Archive experiment
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveExperiment(owner: string, project: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).archiveExperiment(owner, project, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Bookmark experiment
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkExperiment(owner: string, project: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).bookmarkExperiment(owner, project, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new experiment
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {V1ExperimentBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExperiment(owner: string, project: string, body: V1ExperimentBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Experiment> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).createExperiment(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new experiment status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExperimentStatus(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ExperimentStatus> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).createExperimentStatus(owner, project, id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete experiment
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExperiment(owner: string, project: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).deleteExperiment(owner, project, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete experiments
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExperiments(owner: string, project: string, body: V1OwnedEntityIdRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).deleteExperiments(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get experiment
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperiment(owner: string, project: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Experiment> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).getExperiment(owner, project, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get experiment code ref
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperimentCodeRef(owner: string, project: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1CodeReference> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).getExperimentCodeRef(owner, project, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get experiment code ref
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_id Unique integer identifier of the entity
         * @param {V1CodeReferenceBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        greateExperimentCodeRef(entity_owner: string, entity_project: string, entity_id: string, body: V1CodeReferenceBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1CodeReference> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).greateExperimentCodeRef(entity_owner, entity_project, entity_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List archived experiments
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedExperiments(owner: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListExperimentsResponse> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).listArchivedExperiments(owner, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked experiments
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedExperiments(owner: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListExperimentsResponse> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).listBookmarkedExperiments(owner, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List experiment statuses
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExperimentStatuses(owner: string, project: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListExperimentStatusesResponse> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).listExperimentStatuses(owner, project, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List experiments
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExperiments(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListExperimentsResponse> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).listExperiments(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Restart experiment
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartExperiment(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Experiment> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).restartExperiment(owner, project, id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Restore experiment
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreExperiment(owner: string, project: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).restoreExperiment(owner, project, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Resume experiment
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeExperiment(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Experiment> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).resumeExperiment(owner, project, id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Start experiment tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startExperimentTensorboard(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).startExperimentTensorboard(owner, project, id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stop experiment
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopExperiment(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).stopExperiment(owner, project, id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stop experiment tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopExperimentTensorboard(owner: string, project: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).stopExperimentTensorboard(owner, project, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stop experiments
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1ProjectBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopExperiments(owner: string, project: string, body: V1ProjectBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).stopExperiments(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary UnBookmark experiment
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unBookmarkExperiment(owner: string, project: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).unBookmarkExperiment(owner, project, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update experiment
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} experiment_id Unique integer identifier
         * @param {V1ExperimentBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExperiment2(owner: string, project: string, experiment_id: string, body: V1ExperimentBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Experiment> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).updateExperiment2(owner, project, experiment_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ExperimentServiceApi - factory interface
 * @export
 */
export const ExperimentServiceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Archive experiment
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveExperiment(owner: string, project: string, id: string, options?: any) {
            return ExperimentServiceApiFp(configuration).archiveExperiment(owner, project, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Bookmark experiment
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkExperiment(owner: string, project: string, id: string, options?: any) {
            return ExperimentServiceApiFp(configuration).bookmarkExperiment(owner, project, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new experiment
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {V1ExperimentBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExperiment(owner: string, project: string, body: V1ExperimentBodyRequest, options?: any) {
            return ExperimentServiceApiFp(configuration).createExperiment(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new experiment status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExperimentStatus(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any) {
            return ExperimentServiceApiFp(configuration).createExperimentStatus(owner, project, id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete experiment
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExperiment(owner: string, project: string, id: string, options?: any) {
            return ExperimentServiceApiFp(configuration).deleteExperiment(owner, project, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete experiments
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExperiments(owner: string, project: string, body: V1OwnedEntityIdRequest, options?: any) {
            return ExperimentServiceApiFp(configuration).deleteExperiments(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get experiment
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperiment(owner: string, project: string, id: string, options?: any) {
            return ExperimentServiceApiFp(configuration).getExperiment(owner, project, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get experiment code ref
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperimentCodeRef(owner: string, project: string, id: string, options?: any) {
            return ExperimentServiceApiFp(configuration).getExperimentCodeRef(owner, project, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get experiment code ref
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_id Unique integer identifier of the entity
         * @param {V1CodeReferenceBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        greateExperimentCodeRef(entity_owner: string, entity_project: string, entity_id: string, body: V1CodeReferenceBodyRequest, options?: any) {
            return ExperimentServiceApiFp(configuration).greateExperimentCodeRef(entity_owner, entity_project, entity_id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List archived experiments
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedExperiments(owner: string, options?: any) {
            return ExperimentServiceApiFp(configuration).listArchivedExperiments(owner, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked experiments
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedExperiments(owner: string, options?: any) {
            return ExperimentServiceApiFp(configuration).listBookmarkedExperiments(owner, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List experiment statuses
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExperimentStatuses(owner: string, project: string, id: string, options?: any) {
            return ExperimentServiceApiFp(configuration).listExperimentStatuses(owner, project, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List experiments
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExperiments(owner: string, project: string, options?: any) {
            return ExperimentServiceApiFp(configuration).listExperiments(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Restart experiment
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartExperiment(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any) {
            return ExperimentServiceApiFp(configuration).restartExperiment(owner, project, id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Restore experiment
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreExperiment(owner: string, project: string, id: string, options?: any) {
            return ExperimentServiceApiFp(configuration).restoreExperiment(owner, project, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Resume experiment
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeExperiment(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any) {
            return ExperimentServiceApiFp(configuration).resumeExperiment(owner, project, id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Start experiment tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startExperimentTensorboard(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any) {
            return ExperimentServiceApiFp(configuration).startExperimentTensorboard(owner, project, id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stop experiment
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopExperiment(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any) {
            return ExperimentServiceApiFp(configuration).stopExperiment(owner, project, id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stop experiment tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopExperimentTensorboard(owner: string, project: string, id: string, options?: any) {
            return ExperimentServiceApiFp(configuration).stopExperimentTensorboard(owner, project, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stop experiments
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1ProjectBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopExperiments(owner: string, project: string, body: V1ProjectBodyRequest, options?: any) {
            return ExperimentServiceApiFp(configuration).stopExperiments(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary UnBookmark experiment
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unBookmarkExperiment(owner: string, project: string, id: string, options?: any) {
            return ExperimentServiceApiFp(configuration).unBookmarkExperiment(owner, project, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update experiment
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} experiment_id Unique integer identifier
         * @param {V1ExperimentBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExperiment2(owner: string, project: string, experiment_id: string, body: V1ExperimentBodyRequest, options?: any) {
            return ExperimentServiceApiFp(configuration).updateExperiment2(owner, project, experiment_id, body, options)(fetch, basePath);
        },
    };
};

/**
 * ExperimentServiceApi - object-oriented interface
 * @export
 * @class ExperimentServiceApi
 * @extends {BaseAPI}
 */
export class ExperimentServiceApi extends BaseAPI {
    /**
     * 
     * @summary Archive experiment
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public archiveExperiment(owner: string, project: string, id: string, options?: any) {
        return ExperimentServiceApiFp(this.configuration).archiveExperiment(owner, project, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Bookmark experiment
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public bookmarkExperiment(owner: string, project: string, id: string, options?: any) {
        return ExperimentServiceApiFp(this.configuration).bookmarkExperiment(owner, project, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new experiment
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {V1ExperimentBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public createExperiment(owner: string, project: string, body: V1ExperimentBodyRequest, options?: any) {
        return ExperimentServiceApiFp(this.configuration).createExperiment(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new experiment status
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {V1OwnedEntityIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public createExperimentStatus(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any) {
        return ExperimentServiceApiFp(this.configuration).createExperimentStatus(owner, project, id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete experiment
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public deleteExperiment(owner: string, project: string, id: string, options?: any) {
        return ExperimentServiceApiFp(this.configuration).deleteExperiment(owner, project, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete experiments
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {V1OwnedEntityIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public deleteExperiments(owner: string, project: string, body: V1OwnedEntityIdRequest, options?: any) {
        return ExperimentServiceApiFp(this.configuration).deleteExperiments(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get experiment
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public getExperiment(owner: string, project: string, id: string, options?: any) {
        return ExperimentServiceApiFp(this.configuration).getExperiment(owner, project, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get experiment code ref
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public getExperimentCodeRef(owner: string, project: string, id: string, options?: any) {
        return ExperimentServiceApiFp(this.configuration).getExperimentCodeRef(owner, project, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get experiment code ref
     * @param {string} entity_owner Owner of the namespace
     * @param {string} entity_project Project where the experiement will be assigned
     * @param {string} entity_id Unique integer identifier of the entity
     * @param {V1CodeReferenceBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public greateExperimentCodeRef(entity_owner: string, entity_project: string, entity_id: string, body: V1CodeReferenceBodyRequest, options?: any) {
        return ExperimentServiceApiFp(this.configuration).greateExperimentCodeRef(entity_owner, entity_project, entity_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List archived experiments
     * @param {string} owner Owner of the namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public listArchivedExperiments(owner: string, options?: any) {
        return ExperimentServiceApiFp(this.configuration).listArchivedExperiments(owner, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked experiments
     * @param {string} owner Owner of the namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public listBookmarkedExperiments(owner: string, options?: any) {
        return ExperimentServiceApiFp(this.configuration).listBookmarkedExperiments(owner, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List experiment statuses
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public listExperimentStatuses(owner: string, project: string, id: string, options?: any) {
        return ExperimentServiceApiFp(this.configuration).listExperimentStatuses(owner, project, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List experiments
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public listExperiments(owner: string, project: string, options?: any) {
        return ExperimentServiceApiFp(this.configuration).listExperiments(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Restart experiment
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {V1OwnedEntityIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public restartExperiment(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any) {
        return ExperimentServiceApiFp(this.configuration).restartExperiment(owner, project, id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Restore experiment
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public restoreExperiment(owner: string, project: string, id: string, options?: any) {
        return ExperimentServiceApiFp(this.configuration).restoreExperiment(owner, project, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Resume experiment
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {V1OwnedEntityIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public resumeExperiment(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any) {
        return ExperimentServiceApiFp(this.configuration).resumeExperiment(owner, project, id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Start experiment tensorboard
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {V1OwnedEntityIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public startExperimentTensorboard(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any) {
        return ExperimentServiceApiFp(this.configuration).startExperimentTensorboard(owner, project, id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stop experiment
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {V1OwnedEntityIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public stopExperiment(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any) {
        return ExperimentServiceApiFp(this.configuration).stopExperiment(owner, project, id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stop experiment tensorboard
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public stopExperimentTensorboard(owner: string, project: string, id: string, options?: any) {
        return ExperimentServiceApiFp(this.configuration).stopExperimentTensorboard(owner, project, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stop experiments
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {V1ProjectBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public stopExperiments(owner: string, project: string, body: V1ProjectBodyRequest, options?: any) {
        return ExperimentServiceApiFp(this.configuration).stopExperiments(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary UnBookmark experiment
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public unBookmarkExperiment(owner: string, project: string, id: string, options?: any) {
        return ExperimentServiceApiFp(this.configuration).unBookmarkExperiment(owner, project, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update experiment
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} experiment_id Unique integer identifier
     * @param {V1ExperimentBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public updateExperiment2(owner: string, project: string, experiment_id: string, body: V1ExperimentBodyRequest, options?: any) {
        return ExperimentServiceApiFp(this.configuration).updateExperiment2(owner, project, experiment_id, body, options)(this.fetch, this.basePath);
    }

}

