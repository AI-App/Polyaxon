// Copyright 2019 Polyaxon, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Polyaxon sdk
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.14.4
 * Contact: contact@polyaxon.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface V1Auth
 */
export interface V1Auth {
    /**
     * 
     * @type {string}
     * @memberof V1Auth
     */
    token?: string;
}

/**
 * 
 * @export
 * @interface V1CodeRefBodyRequest
 */
export interface V1CodeRefBodyRequest {
    /**
     * 
     * @type {V1OwnedEntityUUIdRequest}
     * @memberof V1CodeRefBodyRequest
     */
    entity?: V1OwnedEntityUUIdRequest;
    /**
     * 
     * @type {V1CodeReference}
     * @memberof V1CodeRefBodyRequest
     */
    CodeReference?: V1CodeReference;
}

/**
 * 
 * @export
 * @interface V1CodeReference
 */
export interface V1CodeReference {
    /**
     * 
     * @type {string}
     * @memberof V1CodeReference
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CodeReference
     */
    commit?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CodeReference
     */
    updated_at?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CodeReference
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CodeReference
     */
    git_url?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1CodeReference
     */
    is_dirty?: boolean;
}

/**
 * 
 * @export
 * @interface V1CredsBodyRequest
 */
export interface V1CredsBodyRequest {
    /**
     * 
     * @type {string}
     * @memberof V1CredsBodyRequest
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CredsBodyRequest
     */
    password?: string;
}

/**
 * 
 * @export
 * @interface V1EntityStatusRequest
 */
export interface V1EntityStatusRequest {
    /**
     * 
     * @type {string}
     * @memberof V1EntityStatusRequest
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EntityStatusRequest
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EntityStatusRequest
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EntityStatusRequest
     */
    status?: string;
}

/**
 * 
 * @export
 * @interface V1ListCodeRefResponse
 */
export interface V1ListCodeRefResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListCodeRefResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1CodeReference>}
     * @memberof V1ListCodeRefResponse
     */
    results?: Array<V1CodeReference>;
    /**
     * 
     * @type {string}
     * @memberof V1ListCodeRefResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListCodeRefResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListProjectsResponse
 */
export interface V1ListProjectsResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListProjectsResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1Project>}
     * @memberof V1ListProjectsResponse
     */
    results?: Array<V1Project>;
    /**
     * 
     * @type {string}
     * @memberof V1ListProjectsResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListProjectsResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListRunsResponse
 */
export interface V1ListRunsResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListRunsResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1Run>}
     * @memberof V1ListRunsResponse
     */
    results?: Array<V1Run>;
    /**
     * 
     * @type {string}
     * @memberof V1ListRunsResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListRunsResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1OwnedEntityUUIdRequest
 */
export interface V1OwnedEntityUUIdRequest {
    /**
     * 
     * @type {string}
     * @memberof V1OwnedEntityUUIdRequest
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof V1OwnedEntityUUIdRequest
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof V1OwnedEntityUUIdRequest
     */
    uuid?: string;
}

/**
 * 
 * @export
 * @interface V1OwnerBodyRequest
 */
export interface V1OwnerBodyRequest {
    /**
     * 
     * @type {string}
     * @memberof V1OwnerBodyRequest
     */
    owner?: string;
}

/**
 * 
 * @export
 * @interface V1Project
 */
export interface V1Project {
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    updated_at?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    is_public?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1Project
     */
    bookmarked?: boolean;
}

/**
 * 
 * @export
 * @interface V1ProjectBodyRequest
 */
export interface V1ProjectBodyRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ProjectBodyRequest
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ProjectBodyRequest
     */
    project?: string;
}

/**
 * 
 * @export
 * @interface V1Run
 */
export interface V1Run {
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Run
     */
    tags?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof V1Run
     */
    deleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    updated_at?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    started_at?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    finished_at?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    is_managed?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    readme?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1Run
     */
    bookmarked?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1Run
     */
    inputs?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1Run
     */
    outputs?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1Run
     */
    run_env?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof V1Run
     */
    is_clone?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    pipeline?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    original?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    pipeline_name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    original_name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    cloning_strategy?: string;
}

/**
 * 
 * @export
 * @interface V1RunBodyRequest
 */
export interface V1RunBodyRequest {
    /**
     * 
     * @type {string}
     * @memberof V1RunBodyRequest
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof V1RunBodyRequest
     */
    project?: string;
    /**
     * 
     * @type {V1Run}
     * @memberof V1RunBodyRequest
     */
    run?: V1Run;
}

/**
 * 
 * @export
 * @interface V1StatusResponse
 */
export interface V1StatusResponse {
    /**
     * 
     * @type {string}
     * @memberof V1StatusResponse
     */
    status?: string;
}

/**
 * 
 * @export
 * @interface V1Version
 */
export interface V1Version {
    /**
     * 
     * @type {string}
     * @memberof V1Version
     */
    min_version?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Version
     */
    latest_version?: string;
}

/**
 * 
 * @export
 * @interface V1Versions
 */
export interface V1Versions {
    /**
     * 
     * @type {string}
     * @memberof V1Versions
     */
    current_version?: string;
    /**
     * 
     * @type {V1Version}
     * @memberof V1Versions
     */
    cli?: V1Version;
    /**
     * 
     * @type {V1Version}
     * @memberof V1Versions
     */
    platform?: V1Version;
    /**
     * 
     * @type {V1Version}
     * @memberof V1Versions
     */
    agent?: V1Version;
}


/**
 * AuthServiceApi - fetch parameter creator
 * @export
 */
export const AuthServiceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {V1CredsBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body: V1CredsBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling login.');
            }
            const localVarPath = `/api/v1/users/token`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1CredsBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthServiceApi - functional programming interface
 * @export
 */
export const AuthServiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {V1CredsBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body: V1CredsBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Auth> {
            const localVarFetchArgs = AuthServiceApiFetchParamCreator(configuration).login(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuthServiceApi - factory interface
 * @export
 */
export const AuthServiceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List runs
         * @param {V1CredsBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body: V1CredsBodyRequest, options?: any) {
            return AuthServiceApiFp(configuration).login(body, options)(fetch, basePath);
        },
    };
};

/**
 * AuthServiceApi - object-oriented interface
 * @export
 * @class AuthServiceApi
 * @extends {BaseAPI}
 */
export class AuthServiceApi extends BaseAPI {
    /**
     * 
     * @summary List runs
     * @param {V1CredsBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthServiceApi
     */
    public login(body: V1CredsBodyRequest, options?: any) {
        return AuthServiceApiFp(this.configuration).login(body, options)(this.fetch, this.basePath);
    }

}

/**
 * ProjectServiceApi - fetch parameter creator
 * @export
 */
export const ProjectServiceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveProject(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling archiveProject.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling archiveProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/archive`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkProject(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling bookmarkProject.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling bookmarkProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/bookmark`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {V1OwnerBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(owner: string, body: V1OwnerBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createProject.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createProject.');
            }
            const localVarPath = `/api/v1/{owner}/projects/create`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1OwnerBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExperiment(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteExperiment.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling deleteExperiment.');
            }
            const localVarPath = `/api/v1/{owner}/projecs/{project}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resume run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableProjectCI(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling disableProjectCI.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling disableProjectCI.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/unbookmark`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restart run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableProjectCI(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling enableProjectCI.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling enableProjectCI.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/ci`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getProject.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getProject.');
            }
            const localVarPath = `/api/v1/{owner}/projects/{project}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedProjects(owner: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listArchivedProjects.');
            }
            const localVarPath = `/api/v1/archives/{owner}/projects`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List archived runs
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedProjects(owner: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listBookmarkedProjects.');
            }
            const localVarPath = `/api/v1/bookmarks/{owner}/projects`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked runs
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectNames(owner: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listProjectNames.');
            }
            const localVarPath = `/api/v1/{owner}/projects/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects(owner: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listProjects.');
            }
            const localVarPath = `/api/v1/{owner}/projects/list`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1ProjectBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProject(owner: string, project: string, body: V1ProjectBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchProject.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling patchProject.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchProject.');
            }
            const localVarPath = `/api/v1/{owner}/projects/{project}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ProjectBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreExperiment(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling restoreExperiment.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling restoreExperiment.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/restore`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1ProjectBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject(owner: string, project: string, body: V1ProjectBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateProject.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling updateProject.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateProject.');
            }
            const localVarPath = `/api/v1/{owner}/projects/{project}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ProjectBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectServiceApi - functional programming interface
 * @export
 */
export const ProjectServiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveProject(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ProjectServiceApiFetchParamCreator(configuration).archiveProject(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkProject(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ProjectServiceApiFetchParamCreator(configuration).bookmarkProject(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {V1OwnerBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(owner: string, body: V1OwnerBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Project> {
            const localVarFetchArgs = ProjectServiceApiFetchParamCreator(configuration).createProject(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExperiment(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ProjectServiceApiFetchParamCreator(configuration).deleteExperiment(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Resume run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableProjectCI(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ProjectServiceApiFetchParamCreator(configuration).disableProjectCI(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Restart run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableProjectCI(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ProjectServiceApiFetchParamCreator(configuration).enableProjectCI(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Project> {
            const localVarFetchArgs = ProjectServiceApiFetchParamCreator(configuration).getProject(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedProjects(owner: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListProjectsResponse> {
            const localVarFetchArgs = ProjectServiceApiFetchParamCreator(configuration).listArchivedProjects(owner, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List archived runs
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedProjects(owner: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListProjectsResponse> {
            const localVarFetchArgs = ProjectServiceApiFetchParamCreator(configuration).listBookmarkedProjects(owner, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked runs
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectNames(owner: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListProjectsResponse> {
            const localVarFetchArgs = ProjectServiceApiFetchParamCreator(configuration).listProjectNames(owner, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects(owner: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListProjectsResponse> {
            const localVarFetchArgs = ProjectServiceApiFetchParamCreator(configuration).listProjects(owner, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1ProjectBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProject(owner: string, project: string, body: V1ProjectBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Project> {
            const localVarFetchArgs = ProjectServiceApiFetchParamCreator(configuration).patchProject(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stop runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreExperiment(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ProjectServiceApiFetchParamCreator(configuration).restoreExperiment(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1ProjectBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject(owner: string, project: string, body: V1ProjectBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Project> {
            const localVarFetchArgs = ProjectServiceApiFetchParamCreator(configuration).updateProject(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProjectServiceApi - factory interface
 * @export
 */
export const ProjectServiceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveProject(owner: string, project: string, options?: any) {
            return ProjectServiceApiFp(configuration).archiveProject(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkProject(owner: string, project: string, options?: any) {
            return ProjectServiceApiFp(configuration).bookmarkProject(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {V1OwnerBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(owner: string, body: V1OwnerBodyRequest, options?: any) {
            return ProjectServiceApiFp(configuration).createProject(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExperiment(owner: string, project: string, options?: any) {
            return ProjectServiceApiFp(configuration).deleteExperiment(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Resume run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableProjectCI(owner: string, project: string, options?: any) {
            return ProjectServiceApiFp(configuration).disableProjectCI(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Restart run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableProjectCI(owner: string, project: string, options?: any) {
            return ProjectServiceApiFp(configuration).enableProjectCI(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(owner: string, project: string, options?: any) {
            return ProjectServiceApiFp(configuration).getProject(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedProjects(owner: string, options?: any) {
            return ProjectServiceApiFp(configuration).listArchivedProjects(owner, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List archived runs
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedProjects(owner: string, options?: any) {
            return ProjectServiceApiFp(configuration).listBookmarkedProjects(owner, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked runs
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectNames(owner: string, options?: any) {
            return ProjectServiceApiFp(configuration).listProjectNames(owner, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects(owner: string, options?: any) {
            return ProjectServiceApiFp(configuration).listProjects(owner, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1ProjectBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProject(owner: string, project: string, body: V1ProjectBodyRequest, options?: any) {
            return ProjectServiceApiFp(configuration).patchProject(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stop runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreExperiment(owner: string, project: string, options?: any) {
            return ProjectServiceApiFp(configuration).restoreExperiment(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1ProjectBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject(owner: string, project: string, body: V1ProjectBodyRequest, options?: any) {
            return ProjectServiceApiFp(configuration).updateProject(owner, project, body, options)(fetch, basePath);
        },
    };
};

/**
 * ProjectServiceApi - object-oriented interface
 * @export
 * @class ProjectServiceApi
 * @extends {BaseAPI}
 */
export class ProjectServiceApi extends BaseAPI {
    /**
     * 
     * @summary Stop run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectServiceApi
     */
    public archiveProject(owner: string, project: string, options?: any) {
        return ProjectServiceApiFp(this.configuration).archiveProject(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stop run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectServiceApi
     */
    public bookmarkProject(owner: string, project: string, options?: any) {
        return ProjectServiceApiFp(this.configuration).bookmarkProject(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run
     * @param {string} owner Owner of the namespace
     * @param {V1OwnerBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectServiceApi
     */
    public createProject(owner: string, body: V1OwnerBodyRequest, options?: any) {
        return ProjectServiceApiFp(this.configuration).createProject(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectServiceApi
     */
    public deleteExperiment(owner: string, project: string, options?: any) {
        return ProjectServiceApiFp(this.configuration).deleteExperiment(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Resume run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectServiceApi
     */
    public disableProjectCI(owner: string, project: string, options?: any) {
        return ProjectServiceApiFp(this.configuration).disableProjectCI(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Restart run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectServiceApi
     */
    public enableProjectCI(owner: string, project: string, options?: any) {
        return ProjectServiceApiFp(this.configuration).enableProjectCI(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectServiceApi
     */
    public getProject(owner: string, project: string, options?: any) {
        return ProjectServiceApiFp(this.configuration).getProject(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run
     * @param {string} owner Owner of the namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectServiceApi
     */
    public listArchivedProjects(owner: string, options?: any) {
        return ProjectServiceApiFp(this.configuration).listArchivedProjects(owner, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List archived runs
     * @param {string} owner Owner of the namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectServiceApi
     */
    public listBookmarkedProjects(owner: string, options?: any) {
        return ProjectServiceApiFp(this.configuration).listBookmarkedProjects(owner, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked runs
     * @param {string} owner Owner of the namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectServiceApi
     */
    public listProjectNames(owner: string, options?: any) {
        return ProjectServiceApiFp(this.configuration).listProjectNames(owner, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List runs
     * @param {string} owner Owner of the namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectServiceApi
     */
    public listProjects(owner: string, options?: any) {
        return ProjectServiceApiFp(this.configuration).listProjects(owner, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {V1ProjectBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectServiceApi
     */
    public patchProject(owner: string, project: string, body: V1ProjectBodyRequest, options?: any) {
        return ProjectServiceApiFp(this.configuration).patchProject(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stop runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectServiceApi
     */
    public restoreExperiment(owner: string, project: string, options?: any) {
        return ProjectServiceApiFp(this.configuration).restoreExperiment(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {V1ProjectBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectServiceApi
     */
    public updateProject(owner: string, project: string, body: V1ProjectBodyRequest, options?: any) {
        return ProjectServiceApiFp(this.configuration).updateProject(owner, project, body, options)(this.fetch, this.basePath);
    }

}

/**
 * RunServiceApi - fetch parameter creator
 * @export
 */
export const RunServiceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Archive run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling archiveRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling archiveRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling archiveRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/archive`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Bookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling bookmarkRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling bookmarkRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling bookmarkRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/bookmark`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {V1RunBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRun(owner: string, project: string, body: V1RunBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling createRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1RunBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run code ref
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1CodeRefBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunCodeRef(entity_owner: string, entity_project: string, entity_uuid: string, body: V1CodeRefBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'entity_owner' is not null or undefined
            if (entity_owner === null || entity_owner === undefined) {
                throw new RequiredError('entity_owner','Required parameter entity_owner was null or undefined when calling createRunCodeRef.');
            }
            // verify required parameter 'entity_project' is not null or undefined
            if (entity_project === null || entity_project === undefined) {
                throw new RequiredError('entity_project','Required parameter entity_project was null or undefined when calling createRunCodeRef.');
            }
            // verify required parameter 'entity_uuid' is not null or undefined
            if (entity_uuid === null || entity_uuid === undefined) {
                throw new RequiredError('entity_uuid','Required parameter entity_uuid was null or undefined when calling createRunCodeRef.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createRunCodeRef.');
            }
            const localVarPath = `/api/v1/{entity.owner}/{entity.project}/runs/{entity.uuid}/coderef`
                .replace(`{${"entity.owner"}}`, encodeURIComponent(String(entity_owner)))
                .replace(`{${"entity.project"}}`, encodeURIComponent(String(entity_project)))
                .replace(`{${"entity.uuid"}}`, encodeURIComponent(String(entity_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1CodeRefBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1EntityStatusRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunStatus(owner: string, project: string, uuid: string, body: V1EntityStatusRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createRunStatus.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling createRunStatus.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling createRunStatus.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createRunStatus.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/statuses`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1EntityStatusRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling deleteRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1ProjectBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRuns(owner: string, project: string, body: V1ProjectBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteRuns.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling deleteRuns.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling deleteRuns.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/delete`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ProjectBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run code ref
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunCodeRefs(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRunCodeRefs.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getRunCodeRefs.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRunCodeRefs.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/coderef`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunStatuses(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRunStatuses.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getRunStatuses.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRunStatuses.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/statuses`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1OwnedEntityUUIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateRun(owner: string, project: string, uuid: string, body: V1OwnedEntityUUIdRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling invalidateRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling invalidateRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling invalidateRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling invalidateRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/invalidate`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1OwnedEntityUUIdRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invalidate runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1ProjectBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateRuns(owner: string, project: string, body: V1ProjectBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling invalidateRuns.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling invalidateRuns.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling invalidateRuns.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/invalidate`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ProjectBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List archived runs
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedRuns(owner: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listArchivedRuns.');
            }
            const localVarPath = `/api/v1/archives/{owner}/runs`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked runs
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedRuns(owner: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listBookmarkedRuns.');
            }
            const localVarPath = `/api/v1/bookmarks/{owner}/runs`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuns(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listRuns.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling listRuns.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} run_uuid UUID
         * @param {V1RunBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRun(owner: string, project: string, run_uuid: string, body: V1RunBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling patchRun.');
            }
            // verify required parameter 'run_uuid' is not null or undefined
            if (run_uuid === null || run_uuid === undefined) {
                throw new RequiredError('run_uuid','Required parameter run_uuid was null or undefined when calling patchRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{run.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"run.uuid"}}`, encodeURIComponent(String(run_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1RunBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restart run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1OwnedEntityUUIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartRun(owner: string, project: string, uuid: string, body: V1OwnedEntityUUIdRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling restartRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling restartRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling restartRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling restartRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/restart`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1OwnedEntityUUIdRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling restoreRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling restoreRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling restoreRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/restore`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resume run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1OwnedEntityUUIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeRun(owner: string, project: string, uuid: string, body: V1OwnedEntityUUIdRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling resumeRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling resumeRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling resumeRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling resumeRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/resume`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1OwnedEntityUUIdRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1OwnedEntityUUIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRunTensorboard(owner: string, project: string, uuid: string, body: V1OwnedEntityUUIdRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling startRunTensorboard.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling startRunTensorboard.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling startRunTensorboard.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling startRunTensorboard.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/tensorboard/start`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1OwnedEntityUUIdRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1OwnedEntityUUIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRun(owner: string, project: string, uuid: string, body: V1OwnedEntityUUIdRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling stopRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling stopRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling stopRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling stopRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/stop`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1OwnedEntityUUIdRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRunTensorboard(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling stopRunTensorboard.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling stopRunTensorboard.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling stopRunTensorboard.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/tensorboard/stop`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1ProjectBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRuns(owner: string, project: string, body: V1ProjectBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling stopRuns.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling stopRuns.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling stopRuns.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/stop`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ProjectBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary UnBookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unBookmarkRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling unBookmarkRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling unBookmarkRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling unBookmarkRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/unbookmark`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} run_uuid UUID
         * @param {V1RunBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRun(owner: string, project: string, run_uuid: string, body: V1RunBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling updateRun.');
            }
            // verify required parameter 'run_uuid' is not null or undefined
            if (run_uuid === null || run_uuid === undefined) {
                throw new RequiredError('run_uuid','Required parameter run_uuid was null or undefined when calling updateRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{run.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"run.uuid"}}`, encodeURIComponent(String(run_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1RunBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RunServiceApi - functional programming interface
 * @export
 */
export const RunServiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Archive run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = RunServiceApiFetchParamCreator(configuration).archiveRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Bookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = RunServiceApiFetchParamCreator(configuration).bookmarkRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {V1RunBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRun(owner: string, project: string, body: V1RunBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunServiceApiFetchParamCreator(configuration).createRun(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run code ref
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1CodeRefBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunCodeRef(entity_owner: string, entity_project: string, entity_uuid: string, body: V1CodeRefBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1CodeReference> {
            const localVarFetchArgs = RunServiceApiFetchParamCreator(configuration).createRunCodeRef(entity_owner, entity_project, entity_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1EntityStatusRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunStatus(owner: string, project: string, uuid: string, body: V1EntityStatusRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = RunServiceApiFetchParamCreator(configuration).createRunStatus(owner, project, uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = RunServiceApiFetchParamCreator(configuration).deleteRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1ProjectBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRuns(owner: string, project: string, body: V1ProjectBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = RunServiceApiFetchParamCreator(configuration).deleteRuns(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunServiceApiFetchParamCreator(configuration).getRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run code ref
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunCodeRefs(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListCodeRefResponse> {
            const localVarFetchArgs = RunServiceApiFetchParamCreator(configuration).getRunCodeRefs(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunStatuses(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1StatusResponse> {
            const localVarFetchArgs = RunServiceApiFetchParamCreator(configuration).getRunStatuses(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1OwnedEntityUUIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateRun(owner: string, project: string, uuid: string, body: V1OwnedEntityUUIdRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = RunServiceApiFetchParamCreator(configuration).invalidateRun(owner, project, uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Invalidate runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1ProjectBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateRuns(owner: string, project: string, body: V1ProjectBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = RunServiceApiFetchParamCreator(configuration).invalidateRuns(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List archived runs
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedRuns(owner: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListRunsResponse> {
            const localVarFetchArgs = RunServiceApiFetchParamCreator(configuration).listArchivedRuns(owner, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked runs
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedRuns(owner: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListRunsResponse> {
            const localVarFetchArgs = RunServiceApiFetchParamCreator(configuration).listBookmarkedRuns(owner, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuns(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListRunsResponse> {
            const localVarFetchArgs = RunServiceApiFetchParamCreator(configuration).listRuns(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} run_uuid UUID
         * @param {V1RunBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRun(owner: string, project: string, run_uuid: string, body: V1RunBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunServiceApiFetchParamCreator(configuration).patchRun(owner, project, run_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Restart run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1OwnedEntityUUIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartRun(owner: string, project: string, uuid: string, body: V1OwnedEntityUUIdRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunServiceApiFetchParamCreator(configuration).restartRun(owner, project, uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Restore run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = RunServiceApiFetchParamCreator(configuration).restoreRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Resume run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1OwnedEntityUUIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeRun(owner: string, project: string, uuid: string, body: V1OwnedEntityUUIdRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunServiceApiFetchParamCreator(configuration).resumeRun(owner, project, uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Start run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1OwnedEntityUUIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRunTensorboard(owner: string, project: string, uuid: string, body: V1OwnedEntityUUIdRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = RunServiceApiFetchParamCreator(configuration).startRunTensorboard(owner, project, uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1OwnedEntityUUIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRun(owner: string, project: string, uuid: string, body: V1OwnedEntityUUIdRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = RunServiceApiFetchParamCreator(configuration).stopRun(owner, project, uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stop run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRunTensorboard(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = RunServiceApiFetchParamCreator(configuration).stopRunTensorboard(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stop runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1ProjectBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRuns(owner: string, project: string, body: V1ProjectBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = RunServiceApiFetchParamCreator(configuration).stopRuns(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary UnBookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unBookmarkRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = RunServiceApiFetchParamCreator(configuration).unBookmarkRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} run_uuid UUID
         * @param {V1RunBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRun(owner: string, project: string, run_uuid: string, body: V1RunBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunServiceApiFetchParamCreator(configuration).updateRun(owner, project, run_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RunServiceApi - factory interface
 * @export
 */
export const RunServiceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Archive run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveRun(owner: string, project: string, uuid: string, options?: any) {
            return RunServiceApiFp(configuration).archiveRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Bookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkRun(owner: string, project: string, uuid: string, options?: any) {
            return RunServiceApiFp(configuration).bookmarkRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {V1RunBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRun(owner: string, project: string, body: V1RunBodyRequest, options?: any) {
            return RunServiceApiFp(configuration).createRun(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run code ref
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1CodeRefBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunCodeRef(entity_owner: string, entity_project: string, entity_uuid: string, body: V1CodeRefBodyRequest, options?: any) {
            return RunServiceApiFp(configuration).createRunCodeRef(entity_owner, entity_project, entity_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1EntityStatusRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunStatus(owner: string, project: string, uuid: string, body: V1EntityStatusRequest, options?: any) {
            return RunServiceApiFp(configuration).createRunStatus(owner, project, uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRun(owner: string, project: string, uuid: string, options?: any) {
            return RunServiceApiFp(configuration).deleteRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1ProjectBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRuns(owner: string, project: string, body: V1ProjectBodyRequest, options?: any) {
            return RunServiceApiFp(configuration).deleteRuns(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRun(owner: string, project: string, uuid: string, options?: any) {
            return RunServiceApiFp(configuration).getRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run code ref
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunCodeRefs(owner: string, project: string, uuid: string, options?: any) {
            return RunServiceApiFp(configuration).getRunCodeRefs(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunStatuses(owner: string, project: string, uuid: string, options?: any) {
            return RunServiceApiFp(configuration).getRunStatuses(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1OwnedEntityUUIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateRun(owner: string, project: string, uuid: string, body: V1OwnedEntityUUIdRequest, options?: any) {
            return RunServiceApiFp(configuration).invalidateRun(owner, project, uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Invalidate runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1ProjectBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateRuns(owner: string, project: string, body: V1ProjectBodyRequest, options?: any) {
            return RunServiceApiFp(configuration).invalidateRuns(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List archived runs
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedRuns(owner: string, options?: any) {
            return RunServiceApiFp(configuration).listArchivedRuns(owner, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked runs
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedRuns(owner: string, options?: any) {
            return RunServiceApiFp(configuration).listBookmarkedRuns(owner, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuns(owner: string, project: string, options?: any) {
            return RunServiceApiFp(configuration).listRuns(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} run_uuid UUID
         * @param {V1RunBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRun(owner: string, project: string, run_uuid: string, body: V1RunBodyRequest, options?: any) {
            return RunServiceApiFp(configuration).patchRun(owner, project, run_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Restart run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1OwnedEntityUUIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartRun(owner: string, project: string, uuid: string, body: V1OwnedEntityUUIdRequest, options?: any) {
            return RunServiceApiFp(configuration).restartRun(owner, project, uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Restore run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreRun(owner: string, project: string, uuid: string, options?: any) {
            return RunServiceApiFp(configuration).restoreRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Resume run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1OwnedEntityUUIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeRun(owner: string, project: string, uuid: string, body: V1OwnedEntityUUIdRequest, options?: any) {
            return RunServiceApiFp(configuration).resumeRun(owner, project, uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Start run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1OwnedEntityUUIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRunTensorboard(owner: string, project: string, uuid: string, body: V1OwnedEntityUUIdRequest, options?: any) {
            return RunServiceApiFp(configuration).startRunTensorboard(owner, project, uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1OwnedEntityUUIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRun(owner: string, project: string, uuid: string, body: V1OwnedEntityUUIdRequest, options?: any) {
            return RunServiceApiFp(configuration).stopRun(owner, project, uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stop run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRunTensorboard(owner: string, project: string, uuid: string, options?: any) {
            return RunServiceApiFp(configuration).stopRunTensorboard(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stop runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1ProjectBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRuns(owner: string, project: string, body: V1ProjectBodyRequest, options?: any) {
            return RunServiceApiFp(configuration).stopRuns(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary UnBookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unBookmarkRun(owner: string, project: string, uuid: string, options?: any) {
            return RunServiceApiFp(configuration).unBookmarkRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} run_uuid UUID
         * @param {V1RunBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRun(owner: string, project: string, run_uuid: string, body: V1RunBodyRequest, options?: any) {
            return RunServiceApiFp(configuration).updateRun(owner, project, run_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * RunServiceApi - object-oriented interface
 * @export
 * @class RunServiceApi
 * @extends {BaseAPI}
 */
export class RunServiceApi extends BaseAPI {
    /**
     * 
     * @summary Archive run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApi
     */
    public archiveRun(owner: string, project: string, uuid: string, options?: any) {
        return RunServiceApiFp(this.configuration).archiveRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Bookmark run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApi
     */
    public bookmarkRun(owner: string, project: string, uuid: string, options?: any) {
        return RunServiceApiFp(this.configuration).bookmarkRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {V1RunBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApi
     */
    public createRun(owner: string, project: string, body: V1RunBodyRequest, options?: any) {
        return RunServiceApiFp(this.configuration).createRun(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run code ref
     * @param {string} entity_owner Owner of the namespace
     * @param {string} entity_project Project where the experiement will be assigned
     * @param {string} entity_uuid Unique integer identifier of the entity
     * @param {V1CodeRefBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApi
     */
    public createRunCodeRef(entity_owner: string, entity_project: string, entity_uuid: string, body: V1CodeRefBodyRequest, options?: any) {
        return RunServiceApiFp(this.configuration).createRunCodeRef(entity_owner, entity_project, entity_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run status
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {V1EntityStatusRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApi
     */
    public createRunStatus(owner: string, project: string, uuid: string, body: V1EntityStatusRequest, options?: any) {
        return RunServiceApiFp(this.configuration).createRunStatus(owner, project, uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApi
     */
    public deleteRun(owner: string, project: string, uuid: string, options?: any) {
        return RunServiceApiFp(this.configuration).deleteRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {V1ProjectBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApi
     */
    public deleteRuns(owner: string, project: string, body: V1ProjectBodyRequest, options?: any) {
        return RunServiceApiFp(this.configuration).deleteRuns(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApi
     */
    public getRun(owner: string, project: string, uuid: string, options?: any) {
        return RunServiceApiFp(this.configuration).getRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run code ref
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApi
     */
    public getRunCodeRefs(owner: string, project: string, uuid: string, options?: any) {
        return RunServiceApiFp(this.configuration).getRunCodeRefs(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run status
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApi
     */
    public getRunStatuses(owner: string, project: string, uuid: string, options?: any) {
        return RunServiceApiFp(this.configuration).getRunStatuses(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stop run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {V1OwnedEntityUUIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApi
     */
    public invalidateRun(owner: string, project: string, uuid: string, body: V1OwnedEntityUUIdRequest, options?: any) {
        return RunServiceApiFp(this.configuration).invalidateRun(owner, project, uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Invalidate runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {V1ProjectBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApi
     */
    public invalidateRuns(owner: string, project: string, body: V1ProjectBodyRequest, options?: any) {
        return RunServiceApiFp(this.configuration).invalidateRuns(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List archived runs
     * @param {string} owner Owner of the namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApi
     */
    public listArchivedRuns(owner: string, options?: any) {
        return RunServiceApiFp(this.configuration).listArchivedRuns(owner, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked runs
     * @param {string} owner Owner of the namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApi
     */
    public listBookmarkedRuns(owner: string, options?: any) {
        return RunServiceApiFp(this.configuration).listBookmarkedRuns(owner, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApi
     */
    public listRuns(owner: string, project: string, options?: any) {
        return RunServiceApiFp(this.configuration).listRuns(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} run_uuid UUID
     * @param {V1RunBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApi
     */
    public patchRun(owner: string, project: string, run_uuid: string, body: V1RunBodyRequest, options?: any) {
        return RunServiceApiFp(this.configuration).patchRun(owner, project, run_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Restart run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {V1OwnedEntityUUIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApi
     */
    public restartRun(owner: string, project: string, uuid: string, body: V1OwnedEntityUUIdRequest, options?: any) {
        return RunServiceApiFp(this.configuration).restartRun(owner, project, uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Restore run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApi
     */
    public restoreRun(owner: string, project: string, uuid: string, options?: any) {
        return RunServiceApiFp(this.configuration).restoreRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Resume run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {V1OwnedEntityUUIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApi
     */
    public resumeRun(owner: string, project: string, uuid: string, body: V1OwnedEntityUUIdRequest, options?: any) {
        return RunServiceApiFp(this.configuration).resumeRun(owner, project, uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Start run tensorboard
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {V1OwnedEntityUUIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApi
     */
    public startRunTensorboard(owner: string, project: string, uuid: string, body: V1OwnedEntityUUIdRequest, options?: any) {
        return RunServiceApiFp(this.configuration).startRunTensorboard(owner, project, uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stop run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {V1OwnedEntityUUIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApi
     */
    public stopRun(owner: string, project: string, uuid: string, body: V1OwnedEntityUUIdRequest, options?: any) {
        return RunServiceApiFp(this.configuration).stopRun(owner, project, uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stop run tensorboard
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApi
     */
    public stopRunTensorboard(owner: string, project: string, uuid: string, options?: any) {
        return RunServiceApiFp(this.configuration).stopRunTensorboard(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stop runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {V1ProjectBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApi
     */
    public stopRuns(owner: string, project: string, body: V1ProjectBodyRequest, options?: any) {
        return RunServiceApiFp(this.configuration).stopRuns(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary UnBookmark run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApi
     */
    public unBookmarkRun(owner: string, project: string, uuid: string, options?: any) {
        return RunServiceApiFp(this.configuration).unBookmarkRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} run_uuid UUID
     * @param {V1RunBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunServiceApi
     */
    public updateRun(owner: string, project: string, run_uuid: string, body: V1RunBodyRequest, options?: any) {
        return RunServiceApiFp(this.configuration).updateRun(owner, project, run_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * VersionsServiceApi - fetch parameter creator
 * @export
 */
export const VersionsServiceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersions(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/versions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VersionsServiceApi - functional programming interface
 * @export
 */
export const VersionsServiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersions(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Versions> {
            const localVarFetchArgs = VersionsServiceApiFetchParamCreator(configuration).getVersions(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * VersionsServiceApi - factory interface
 * @export
 */
export const VersionsServiceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List runs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersions(options?: any) {
            return VersionsServiceApiFp(configuration).getVersions(options)(fetch, basePath);
        },
    };
};

/**
 * VersionsServiceApi - object-oriented interface
 * @export
 * @class VersionsServiceApi
 * @extends {BaseAPI}
 */
export class VersionsServiceApi extends BaseAPI {
    /**
     * 
     * @summary List runs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsServiceApi
     */
    public getVersions(options?: any) {
        return VersionsServiceApiFp(this.configuration).getVersions(options)(this.fetch, this.basePath);
    }

}

