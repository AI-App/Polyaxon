// Copyright 2019 Polyaxon, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Polyaxon sdk
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.14.4
 * Contact: contact@polyaxon.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface V1Build
 */
export interface V1Build {
    /**
     * 
     * @type {string}
     * @memberof V1Build
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Build
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Build
     */
    unique_name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Build
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Build
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Build
     */
    tags?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof V1Build
     */
    deleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1Build
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Build
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Build
     */
    updated_at?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Build
     */
    started_at?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Build
     */
    finished_at?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Build
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Build
     */
    is_managed?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Build
     */
    spec?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Build
     */
    backend?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Build
     */
    framework?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Build
     */
    last_status?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Build
     */
    code_reference?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1Build
     */
    resources?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof V1Build
     */
    readme?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1Build
     */
    bookmarked?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1Build
     */
    params?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1Build
     */
    run_env?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof V1Build
     */
    build_build?: string;
}

/**
 * 
 * @export
 * @interface V1BuildBodyRequest
 */
export interface V1BuildBodyRequest {
    /**
     * 
     * @type {string}
     * @memberof V1BuildBodyRequest
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof V1BuildBodyRequest
     */
    project?: string;
    /**
     * 
     * @type {V1Build}
     * @memberof V1BuildBodyRequest
     */
    build?: V1Build;
}

/**
 * 
 * @export
 * @interface V1BuildStatus
 */
export interface V1BuildStatus {
    /**
     * 
     * @type {string}
     * @memberof V1BuildStatus
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V1BuildStatus
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1BuildStatus
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof V1BuildStatus
     */
    updated_at?: string;
    /**
     * 
     * @type {string}
     * @memberof V1BuildStatus
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof V1BuildStatus
     */
    message?: string;
}

/**
 * 
 * @export
 * @interface V1CodeReference
 */
export interface V1CodeReference {
    /**
     * 
     * @type {string}
     * @memberof V1CodeReference
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CodeReference
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CodeReference
     */
    commit?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CodeReference
     */
    updated_at?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CodeReference
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CodeReference
     */
    git_url?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1CodeReference
     */
    is_dirty?: boolean;
}

/**
 * 
 * @export
 * @interface V1CodeReferenceBodyRequest
 */
export interface V1CodeReferenceBodyRequest {
    /**
     * 
     * @type {V1OwnedEntityIdRequest}
     * @memberof V1CodeReferenceBodyRequest
     */
    entity?: V1OwnedEntityIdRequest;
    /**
     * 
     * @type {V1CodeReference}
     * @memberof V1CodeReferenceBodyRequest
     */
    CodeReference?: V1CodeReference;
}

/**
 * 
 * @export
 * @interface V1Experiment
 */
export interface V1Experiment {
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    unique_name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Experiment
     */
    tags?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof V1Experiment
     */
    deleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    updated_at?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    started_at?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    finished_at?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    is_managed?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    spec?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    backend?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    framework?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    last_status?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    code_reference?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1Experiment
     */
    resources?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    readme?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1Experiment
     */
    bookmarked?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1Experiment
     */
    params?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1Experiment
     */
    run_env?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    build_job?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1Experiment
     */
    data_refs?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1Experiment
     */
    artifact_refs?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    original?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    cloning_strategy?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Experiment
     */
    experiment_group?: string;
    /**
     * 
     * @type {number}
     * @memberof V1Experiment
     */
    num_jobs?: number;
    /**
     * 
     * @type {boolean}
     * @memberof V1Experiment
     */
    has_tensorboard?: boolean;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof V1Experiment
     */
    last_metric?: { [key: string]: number; };
}

/**
 * 
 * @export
 * @interface V1ExperimentBodyRequest
 */
export interface V1ExperimentBodyRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ExperimentBodyRequest
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ExperimentBodyRequest
     */
    project?: string;
    /**
     * 
     * @type {V1Experiment}
     * @memberof V1ExperimentBodyRequest
     */
    experiment?: V1Experiment;
}

/**
 * 
 * @export
 * @interface V1ExperimentStatus
 */
export interface V1ExperimentStatus {
    /**
     * 
     * @type {string}
     * @memberof V1ExperimentStatus
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ExperimentStatus
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ExperimentStatus
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ExperimentStatus
     */
    updated_at?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ExperimentStatus
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ExperimentStatus
     */
    message?: string;
}

/**
 * 
 * @export
 * @interface V1Job
 */
export interface V1Job {
    /**
     * 
     * @type {string}
     * @memberof V1Job
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Job
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Job
     */
    unique_name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Job
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Job
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Job
     */
    tags?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof V1Job
     */
    deleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1Job
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Job
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Job
     */
    updated_at?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Job
     */
    started_at?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Job
     */
    finished_at?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Job
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Job
     */
    is_managed?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Job
     */
    spec?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Job
     */
    backend?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Job
     */
    framework?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Job
     */
    last_status?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Job
     */
    code_reference?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1Job
     */
    resources?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof V1Job
     */
    readme?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1Job
     */
    bookmarked?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1Job
     */
    params?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1Job
     */
    run_env?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof V1Job
     */
    build_job?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1Job
     */
    data_refs?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1Job
     */
    artifact_refs?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof V1Job
     */
    original?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Job
     */
    cloning_strategy?: string;
}

/**
 * 
 * @export
 * @interface V1JobBodyRequest
 */
export interface V1JobBodyRequest {
    /**
     * 
     * @type {string}
     * @memberof V1JobBodyRequest
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof V1JobBodyRequest
     */
    project?: string;
    /**
     * 
     * @type {V1Job}
     * @memberof V1JobBodyRequest
     */
    job?: V1Job;
}

/**
 * 
 * @export
 * @interface V1JobStatus
 */
export interface V1JobStatus {
    /**
     * 
     * @type {string}
     * @memberof V1JobStatus
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V1JobStatus
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1JobStatus
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof V1JobStatus
     */
    updated_at?: string;
    /**
     * 
     * @type {string}
     * @memberof V1JobStatus
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof V1JobStatus
     */
    message?: string;
}

/**
 * 
 * @export
 * @interface V1ListBuildStatusesResponse
 */
export interface V1ListBuildStatusesResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListBuildStatusesResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1BuildStatus>}
     * @memberof V1ListBuildStatusesResponse
     */
    results?: Array<V1BuildStatus>;
    /**
     * 
     * @type {string}
     * @memberof V1ListBuildStatusesResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListBuildStatusesResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListBuildsResponse
 */
export interface V1ListBuildsResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListBuildsResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1Build>}
     * @memberof V1ListBuildsResponse
     */
    results?: Array<V1Build>;
    /**
     * 
     * @type {string}
     * @memberof V1ListBuildsResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListBuildsResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListExperimentStatusesResponse
 */
export interface V1ListExperimentStatusesResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListExperimentStatusesResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1ExperimentStatus>}
     * @memberof V1ListExperimentStatusesResponse
     */
    results?: Array<V1ExperimentStatus>;
    /**
     * 
     * @type {string}
     * @memberof V1ListExperimentStatusesResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListExperimentStatusesResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListExperimentsResponse
 */
export interface V1ListExperimentsResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListExperimentsResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1Experiment>}
     * @memberof V1ListExperimentsResponse
     */
    results?: Array<V1Experiment>;
    /**
     * 
     * @type {string}
     * @memberof V1ListExperimentsResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListExperimentsResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListJobStatusesResponse
 */
export interface V1ListJobStatusesResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListJobStatusesResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1JobStatus>}
     * @memberof V1ListJobStatusesResponse
     */
    results?: Array<V1JobStatus>;
    /**
     * 
     * @type {string}
     * @memberof V1ListJobStatusesResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListJobStatusesResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListJobsResponse
 */
export interface V1ListJobsResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListJobsResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1Job>}
     * @memberof V1ListJobsResponse
     */
    results?: Array<V1Job>;
    /**
     * 
     * @type {string}
     * @memberof V1ListJobsResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListJobsResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1OwnedEntityIdRequest
 */
export interface V1OwnedEntityIdRequest {
    /**
     * 
     * @type {string}
     * @memberof V1OwnedEntityIdRequest
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof V1OwnedEntityIdRequest
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof V1OwnedEntityIdRequest
     */
    id?: string;
}

/**
 * 
 * @export
 * @interface V1ProjectBodyRequest
 */
export interface V1ProjectBodyRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ProjectBodyRequest
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ProjectBodyRequest
     */
    project?: string;
}

/**
 * 
 * @export
 * @interface V1StatusResponse
 */
export interface V1StatusResponse {
    /**
     * 
     * @type {string}
     * @memberof V1StatusResponse
     */
    status?: string;
}


/**
 * BuildServiceApi - fetch parameter creator
 * @export
 */
export const BuildServiceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Archive build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveBuild(owner: string, project: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling archiveBuild.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling archiveBuild.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling archiveBuild.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/builds/{id}/archive`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Bookmark build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkBuild(owner: string, project: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling bookmarkBuild.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling bookmarkBuild.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling bookmarkBuild.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/builds/{id}/bookmark`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {V1BuildBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuild(owner: string, project: string, body: V1BuildBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createBuild.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling createBuild.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createBuild.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/builds`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1BuildBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create build code ref
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_id Unique integer identifier of the entity
         * @param {V1CodeReferenceBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuildCodeRef(entity_owner: string, entity_project: string, entity_id: string, body: V1CodeReferenceBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'entity_owner' is not null or undefined
            if (entity_owner === null || entity_owner === undefined) {
                throw new RequiredError('entity_owner','Required parameter entity_owner was null or undefined when calling createBuildCodeRef.');
            }
            // verify required parameter 'entity_project' is not null or undefined
            if (entity_project === null || entity_project === undefined) {
                throw new RequiredError('entity_project','Required parameter entity_project was null or undefined when calling createBuildCodeRef.');
            }
            // verify required parameter 'entity_id' is not null or undefined
            if (entity_id === null || entity_id === undefined) {
                throw new RequiredError('entity_id','Required parameter entity_id was null or undefined when calling createBuildCodeRef.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createBuildCodeRef.');
            }
            const localVarPath = `/api/v1/{entity.owner}/{entity.project}/builds/{entity.id}/coderef`
                .replace(`{${"entity.owner"}}`, encodeURIComponent(String(entity_owner)))
                .replace(`{${"entity.project"}}`, encodeURIComponent(String(entity_project)))
                .replace(`{${"entity.id"}}`, encodeURIComponent(String(entity_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1CodeReferenceBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new build status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuildStatus(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createBuildStatus.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling createBuildStatus.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling createBuildStatus.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createBuildStatus.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/builds/{id}/statuses`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1OwnedEntityIdRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuild(owner: string, project: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteBuild.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling deleteBuild.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteBuild.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/builds/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete builds
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuilds(owner: string, project: string, body: V1OwnedEntityIdRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteBuilds.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling deleteBuilds.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling deleteBuilds.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/builds/delete`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1OwnedEntityIdRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuild(owner: string, project: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getBuild.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getBuild.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getBuild.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/builds/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get build code ref
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuildCodeRef(owner: string, project: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getBuildCodeRef.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getBuildCodeRef.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getBuildCodeRef.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/builds/{id}/coderef`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List archived builds
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedBuilds(owner: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listArchivedBuilds.');
            }
            const localVarPath = `/api/v1/archives/{owner}/builds`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked builds
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedBuilds(owner: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listBookmarkedBuilds.');
            }
            const localVarPath = `/api/v1/bookmarks/{owner}/builds`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List build statuses
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBuildStatuses(owner: string, project: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listBuildStatuses.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling listBuildStatuses.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listBuildStatuses.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/builds/{id}/statuses`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List builds
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBuilds(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listBuilds.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling listBuilds.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/builds`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restart build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartBuild(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling restartBuild.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling restartBuild.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling restartBuild.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling restartBuild.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/builds/{id}/restart`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1OwnedEntityIdRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreBuild(owner: string, project: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling restoreBuild.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling restoreBuild.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling restoreBuild.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/builds/{id}/restore`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopBuild(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling stopBuild.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling stopBuild.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling stopBuild.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling stopBuild.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/builds/{id}/stop`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1OwnedEntityIdRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop builds
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1ProjectBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopBuilds(owner: string, project: string, body: V1ProjectBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling stopBuilds.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling stopBuilds.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling stopBuilds.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/builds/stop`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ProjectBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary UnBookmark build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unBookmarkBuild(owner: string, project: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling unBookmarkBuild.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling unBookmarkBuild.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling unBookmarkBuild.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/builds/{id}/unbookmark`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} build_id Unique integer identifier
         * @param {V1BuildBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBuild2(owner: string, project: string, build_id: string, body: V1BuildBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateBuild2.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling updateBuild2.');
            }
            // verify required parameter 'build_id' is not null or undefined
            if (build_id === null || build_id === undefined) {
                throw new RequiredError('build_id','Required parameter build_id was null or undefined when calling updateBuild2.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateBuild2.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/builds/{build.id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"build.id"}}`, encodeURIComponent(String(build_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1BuildBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BuildServiceApi - functional programming interface
 * @export
 */
export const BuildServiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Archive build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveBuild(owner: string, project: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = BuildServiceApiFetchParamCreator(configuration).archiveBuild(owner, project, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Bookmark build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkBuild(owner: string, project: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = BuildServiceApiFetchParamCreator(configuration).bookmarkBuild(owner, project, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {V1BuildBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuild(owner: string, project: string, body: V1BuildBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Build> {
            const localVarFetchArgs = BuildServiceApiFetchParamCreator(configuration).createBuild(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create build code ref
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_id Unique integer identifier of the entity
         * @param {V1CodeReferenceBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuildCodeRef(entity_owner: string, entity_project: string, entity_id: string, body: V1CodeReferenceBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1CodeReference> {
            const localVarFetchArgs = BuildServiceApiFetchParamCreator(configuration).createBuildCodeRef(entity_owner, entity_project, entity_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new build status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuildStatus(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1BuildStatus> {
            const localVarFetchArgs = BuildServiceApiFetchParamCreator(configuration).createBuildStatus(owner, project, id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuild(owner: string, project: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = BuildServiceApiFetchParamCreator(configuration).deleteBuild(owner, project, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete builds
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuilds(owner: string, project: string, body: V1OwnedEntityIdRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = BuildServiceApiFetchParamCreator(configuration).deleteBuilds(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuild(owner: string, project: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Build> {
            const localVarFetchArgs = BuildServiceApiFetchParamCreator(configuration).getBuild(owner, project, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get build code ref
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuildCodeRef(owner: string, project: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1CodeReference> {
            const localVarFetchArgs = BuildServiceApiFetchParamCreator(configuration).getBuildCodeRef(owner, project, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List archived builds
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedBuilds(owner: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListBuildsResponse> {
            const localVarFetchArgs = BuildServiceApiFetchParamCreator(configuration).listArchivedBuilds(owner, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked builds
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedBuilds(owner: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListBuildsResponse> {
            const localVarFetchArgs = BuildServiceApiFetchParamCreator(configuration).listBookmarkedBuilds(owner, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List build statuses
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBuildStatuses(owner: string, project: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListBuildStatusesResponse> {
            const localVarFetchArgs = BuildServiceApiFetchParamCreator(configuration).listBuildStatuses(owner, project, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List builds
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBuilds(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListBuildsResponse> {
            const localVarFetchArgs = BuildServiceApiFetchParamCreator(configuration).listBuilds(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Restart build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartBuild(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Build> {
            const localVarFetchArgs = BuildServiceApiFetchParamCreator(configuration).restartBuild(owner, project, id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Restore build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreBuild(owner: string, project: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = BuildServiceApiFetchParamCreator(configuration).restoreBuild(owner, project, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stop build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopBuild(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = BuildServiceApiFetchParamCreator(configuration).stopBuild(owner, project, id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stop builds
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1ProjectBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopBuilds(owner: string, project: string, body: V1ProjectBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = BuildServiceApiFetchParamCreator(configuration).stopBuilds(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary UnBookmark build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unBookmarkBuild(owner: string, project: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = BuildServiceApiFetchParamCreator(configuration).unBookmarkBuild(owner, project, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} build_id Unique integer identifier
         * @param {V1BuildBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBuild2(owner: string, project: string, build_id: string, body: V1BuildBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Build> {
            const localVarFetchArgs = BuildServiceApiFetchParamCreator(configuration).updateBuild2(owner, project, build_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BuildServiceApi - factory interface
 * @export
 */
export const BuildServiceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Archive build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveBuild(owner: string, project: string, id: string, options?: any) {
            return BuildServiceApiFp(configuration).archiveBuild(owner, project, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Bookmark build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkBuild(owner: string, project: string, id: string, options?: any) {
            return BuildServiceApiFp(configuration).bookmarkBuild(owner, project, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {V1BuildBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuild(owner: string, project: string, body: V1BuildBodyRequest, options?: any) {
            return BuildServiceApiFp(configuration).createBuild(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create build code ref
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_id Unique integer identifier of the entity
         * @param {V1CodeReferenceBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuildCodeRef(entity_owner: string, entity_project: string, entity_id: string, body: V1CodeReferenceBodyRequest, options?: any) {
            return BuildServiceApiFp(configuration).createBuildCodeRef(entity_owner, entity_project, entity_id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new build status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuildStatus(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any) {
            return BuildServiceApiFp(configuration).createBuildStatus(owner, project, id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuild(owner: string, project: string, id: string, options?: any) {
            return BuildServiceApiFp(configuration).deleteBuild(owner, project, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete builds
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuilds(owner: string, project: string, body: V1OwnedEntityIdRequest, options?: any) {
            return BuildServiceApiFp(configuration).deleteBuilds(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuild(owner: string, project: string, id: string, options?: any) {
            return BuildServiceApiFp(configuration).getBuild(owner, project, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get build code ref
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuildCodeRef(owner: string, project: string, id: string, options?: any) {
            return BuildServiceApiFp(configuration).getBuildCodeRef(owner, project, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List archived builds
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedBuilds(owner: string, options?: any) {
            return BuildServiceApiFp(configuration).listArchivedBuilds(owner, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked builds
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedBuilds(owner: string, options?: any) {
            return BuildServiceApiFp(configuration).listBookmarkedBuilds(owner, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List build statuses
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBuildStatuses(owner: string, project: string, id: string, options?: any) {
            return BuildServiceApiFp(configuration).listBuildStatuses(owner, project, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List builds
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBuilds(owner: string, project: string, options?: any) {
            return BuildServiceApiFp(configuration).listBuilds(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Restart build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartBuild(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any) {
            return BuildServiceApiFp(configuration).restartBuild(owner, project, id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Restore build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreBuild(owner: string, project: string, id: string, options?: any) {
            return BuildServiceApiFp(configuration).restoreBuild(owner, project, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stop build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopBuild(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any) {
            return BuildServiceApiFp(configuration).stopBuild(owner, project, id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stop builds
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1ProjectBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopBuilds(owner: string, project: string, body: V1ProjectBodyRequest, options?: any) {
            return BuildServiceApiFp(configuration).stopBuilds(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary UnBookmark build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unBookmarkBuild(owner: string, project: string, id: string, options?: any) {
            return BuildServiceApiFp(configuration).unBookmarkBuild(owner, project, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} build_id Unique integer identifier
         * @param {V1BuildBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBuild2(owner: string, project: string, build_id: string, body: V1BuildBodyRequest, options?: any) {
            return BuildServiceApiFp(configuration).updateBuild2(owner, project, build_id, body, options)(fetch, basePath);
        },
    };
};

/**
 * BuildServiceApi - object-oriented interface
 * @export
 * @class BuildServiceApi
 * @extends {BaseAPI}
 */
export class BuildServiceApi extends BaseAPI {
    /**
     * 
     * @summary Archive build
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildServiceApi
     */
    public archiveBuild(owner: string, project: string, id: string, options?: any) {
        return BuildServiceApiFp(this.configuration).archiveBuild(owner, project, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Bookmark build
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildServiceApi
     */
    public bookmarkBuild(owner: string, project: string, id: string, options?: any) {
        return BuildServiceApiFp(this.configuration).bookmarkBuild(owner, project, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new build
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {V1BuildBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildServiceApi
     */
    public createBuild(owner: string, project: string, body: V1BuildBodyRequest, options?: any) {
        return BuildServiceApiFp(this.configuration).createBuild(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create build code ref
     * @param {string} entity_owner Owner of the namespace
     * @param {string} entity_project Project where the experiement will be assigned
     * @param {string} entity_id Unique integer identifier of the entity
     * @param {V1CodeReferenceBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildServiceApi
     */
    public createBuildCodeRef(entity_owner: string, entity_project: string, entity_id: string, body: V1CodeReferenceBodyRequest, options?: any) {
        return BuildServiceApiFp(this.configuration).createBuildCodeRef(entity_owner, entity_project, entity_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new build status
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {V1OwnedEntityIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildServiceApi
     */
    public createBuildStatus(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any) {
        return BuildServiceApiFp(this.configuration).createBuildStatus(owner, project, id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete build
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildServiceApi
     */
    public deleteBuild(owner: string, project: string, id: string, options?: any) {
        return BuildServiceApiFp(this.configuration).deleteBuild(owner, project, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete builds
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {V1OwnedEntityIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildServiceApi
     */
    public deleteBuilds(owner: string, project: string, body: V1OwnedEntityIdRequest, options?: any) {
        return BuildServiceApiFp(this.configuration).deleteBuilds(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get build
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildServiceApi
     */
    public getBuild(owner: string, project: string, id: string, options?: any) {
        return BuildServiceApiFp(this.configuration).getBuild(owner, project, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get build code ref
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildServiceApi
     */
    public getBuildCodeRef(owner: string, project: string, id: string, options?: any) {
        return BuildServiceApiFp(this.configuration).getBuildCodeRef(owner, project, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List archived builds
     * @param {string} owner Owner of the namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildServiceApi
     */
    public listArchivedBuilds(owner: string, options?: any) {
        return BuildServiceApiFp(this.configuration).listArchivedBuilds(owner, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked builds
     * @param {string} owner Owner of the namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildServiceApi
     */
    public listBookmarkedBuilds(owner: string, options?: any) {
        return BuildServiceApiFp(this.configuration).listBookmarkedBuilds(owner, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List build statuses
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildServiceApi
     */
    public listBuildStatuses(owner: string, project: string, id: string, options?: any) {
        return BuildServiceApiFp(this.configuration).listBuildStatuses(owner, project, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List builds
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildServiceApi
     */
    public listBuilds(owner: string, project: string, options?: any) {
        return BuildServiceApiFp(this.configuration).listBuilds(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Restart build
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {V1OwnedEntityIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildServiceApi
     */
    public restartBuild(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any) {
        return BuildServiceApiFp(this.configuration).restartBuild(owner, project, id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Restore build
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildServiceApi
     */
    public restoreBuild(owner: string, project: string, id: string, options?: any) {
        return BuildServiceApiFp(this.configuration).restoreBuild(owner, project, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stop build
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {V1OwnedEntityIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildServiceApi
     */
    public stopBuild(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any) {
        return BuildServiceApiFp(this.configuration).stopBuild(owner, project, id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stop builds
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {V1ProjectBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildServiceApi
     */
    public stopBuilds(owner: string, project: string, body: V1ProjectBodyRequest, options?: any) {
        return BuildServiceApiFp(this.configuration).stopBuilds(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary UnBookmark build
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildServiceApi
     */
    public unBookmarkBuild(owner: string, project: string, id: string, options?: any) {
        return BuildServiceApiFp(this.configuration).unBookmarkBuild(owner, project, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update build
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} build_id Unique integer identifier
     * @param {V1BuildBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildServiceApi
     */
    public updateBuild2(owner: string, project: string, build_id: string, body: V1BuildBodyRequest, options?: any) {
        return BuildServiceApiFp(this.configuration).updateBuild2(owner, project, build_id, body, options)(this.fetch, this.basePath);
    }

}

/**
 * ExperimentServiceApi - fetch parameter creator
 * @export
 */
export const ExperimentServiceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Restore build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveExperiment(owner: string, project: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling archiveExperiment.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling archiveExperiment.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling archiveExperiment.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/experiments/{id}/archive`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary UnBookmark build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkExperiment(owner: string, project: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling bookmarkExperiment.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling bookmarkExperiment.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling bookmarkExperiment.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/experiments/{id}/bookmark`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {V1ExperimentBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExperiment(owner: string, project: string, body: V1ExperimentBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createExperiment.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling createExperiment.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createExperiment.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/experiments`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ExperimentBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get experiment code ref
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_id Unique integer identifier of the entity
         * @param {V1CodeReferenceBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExperimentCodeRef(entity_owner: string, entity_project: string, entity_id: string, body: V1CodeReferenceBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'entity_owner' is not null or undefined
            if (entity_owner === null || entity_owner === undefined) {
                throw new RequiredError('entity_owner','Required parameter entity_owner was null or undefined when calling createExperimentCodeRef.');
            }
            // verify required parameter 'entity_project' is not null or undefined
            if (entity_project === null || entity_project === undefined) {
                throw new RequiredError('entity_project','Required parameter entity_project was null or undefined when calling createExperimentCodeRef.');
            }
            // verify required parameter 'entity_id' is not null or undefined
            if (entity_id === null || entity_id === undefined) {
                throw new RequiredError('entity_id','Required parameter entity_id was null or undefined when calling createExperimentCodeRef.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createExperimentCodeRef.');
            }
            const localVarPath = `/api/v1/{entity.owner}/{entity.project}/experiments/{entity.id}/coderef`
                .replace(`{${"entity.owner"}}`, encodeURIComponent(String(entity_owner)))
                .replace(`{${"entity.project"}}`, encodeURIComponent(String(entity_project)))
                .replace(`{${"entity.id"}}`, encodeURIComponent(String(entity_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1CodeReferenceBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get job code ref
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExperimentStatus(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createExperimentStatus.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling createExperimentStatus.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling createExperimentStatus.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createExperimentStatus.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/experiments/{id}/statuses`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1OwnedEntityIdRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExperiment(owner: string, project: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteExperiment.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling deleteExperiment.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteExperiment.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/experiments/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete builds
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExperiments(owner: string, project: string, body: V1OwnedEntityIdRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteExperiments.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling deleteExperiments.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling deleteExperiments.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/experiments/delete`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1OwnedEntityIdRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperiment(owner: string, project: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getExperiment.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getExperiment.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getExperiment.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/experiments/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get experiment code ref
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperimentCodeRef(owner: string, project: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getExperimentCodeRef.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getExperimentCodeRef.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getExperimentCodeRef.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/experiments/{id}/coderef`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List archived builds
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedExperiments(owner: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listArchivedExperiments.');
            }
            const localVarPath = `/api/v1/archives/{owner}/experiments`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked builds
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedExperiments(owner: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listBookmarkedExperiments.');
            }
            const localVarPath = `/api/v1/bookmarks/{owner}/experiments`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create build code ref
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExperimentStatuses(owner: string, project: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listExperimentStatuses.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling listExperimentStatuses.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listExperimentStatuses.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/experiments/{id}/statuses`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List builds
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExperiments(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listExperiments.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling listExperiments.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/experiments`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restart build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartExperiment(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling restartExperiment.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling restartExperiment.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling restartExperiment.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling restartExperiment.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/experiments/{id}/restart`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1OwnedEntityIdRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Bookmark build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreExperiment(owner: string, project: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling restoreExperiment.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling restoreExperiment.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling restoreExperiment.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/experiments/{id}/restore`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Archive build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeExperiment(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling resumeExperiment.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling resumeExperiment.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling resumeExperiment.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling resumeExperiment.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/experiments/{id}/resume`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1OwnedEntityIdRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List build statuses
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startExperimentTensorboard(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling startExperimentTensorboard.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling startExperimentTensorboard.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling startExperimentTensorboard.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling startExperimentTensorboard.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/experiments/{id}/tensorboard/start`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1OwnedEntityIdRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopExperiment(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling stopExperiment.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling stopExperiment.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling stopExperiment.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling stopExperiment.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/experiments/{id}/stop`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1OwnedEntityIdRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new build status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopExperimentTensorboard(owner: string, project: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling stopExperimentTensorboard.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling stopExperimentTensorboard.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling stopExperimentTensorboard.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/experiments/{id}/tensorboard/stop`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop builds
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1ProjectBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopExperiments(owner: string, project: string, body: V1ProjectBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling stopExperiments.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling stopExperiments.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling stopExperiments.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/experiments/stop`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ProjectBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get build status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unBookmarkExperiment(owner: string, project: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling unBookmarkExperiment.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling unBookmarkExperiment.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling unBookmarkExperiment.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/experiments/{id}/unbookmark`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} experiment_id Unique integer identifier
         * @param {V1ExperimentBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExperiment2(owner: string, project: string, experiment_id: string, body: V1ExperimentBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateExperiment2.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling updateExperiment2.');
            }
            // verify required parameter 'experiment_id' is not null or undefined
            if (experiment_id === null || experiment_id === undefined) {
                throw new RequiredError('experiment_id','Required parameter experiment_id was null or undefined when calling updateExperiment2.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateExperiment2.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/experiments/{experiment.id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"experiment.id"}}`, encodeURIComponent(String(experiment_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ExperimentBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExperimentServiceApi - functional programming interface
 * @export
 */
export const ExperimentServiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Restore build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveExperiment(owner: string, project: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).archiveExperiment(owner, project, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary UnBookmark build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkExperiment(owner: string, project: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).bookmarkExperiment(owner, project, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {V1ExperimentBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExperiment(owner: string, project: string, body: V1ExperimentBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Experiment> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).createExperiment(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get experiment code ref
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_id Unique integer identifier of the entity
         * @param {V1CodeReferenceBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExperimentCodeRef(entity_owner: string, entity_project: string, entity_id: string, body: V1CodeReferenceBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1CodeReference> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).createExperimentCodeRef(entity_owner, entity_project, entity_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get job code ref
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExperimentStatus(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ExperimentStatus> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).createExperimentStatus(owner, project, id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExperiment(owner: string, project: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).deleteExperiment(owner, project, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete builds
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExperiments(owner: string, project: string, body: V1OwnedEntityIdRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).deleteExperiments(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperiment(owner: string, project: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Experiment> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).getExperiment(owner, project, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get experiment code ref
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperimentCodeRef(owner: string, project: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1CodeReference> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).getExperimentCodeRef(owner, project, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List archived builds
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedExperiments(owner: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListExperimentsResponse> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).listArchivedExperiments(owner, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked builds
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedExperiments(owner: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListExperimentsResponse> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).listBookmarkedExperiments(owner, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create build code ref
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExperimentStatuses(owner: string, project: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListExperimentStatusesResponse> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).listExperimentStatuses(owner, project, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List builds
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExperiments(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListExperimentsResponse> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).listExperiments(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Restart build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartExperiment(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Experiment> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).restartExperiment(owner, project, id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Bookmark build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreExperiment(owner: string, project: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).restoreExperiment(owner, project, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Archive build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeExperiment(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Experiment> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).resumeExperiment(owner, project, id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List build statuses
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startExperimentTensorboard(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).startExperimentTensorboard(owner, project, id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stop build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopExperiment(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).stopExperiment(owner, project, id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new build status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopExperimentTensorboard(owner: string, project: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).stopExperimentTensorboard(owner, project, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stop builds
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1ProjectBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopExperiments(owner: string, project: string, body: V1ProjectBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).stopExperiments(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get build status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unBookmarkExperiment(owner: string, project: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).unBookmarkExperiment(owner, project, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} experiment_id Unique integer identifier
         * @param {V1ExperimentBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExperiment2(owner: string, project: string, experiment_id: string, body: V1ExperimentBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Experiment> {
            const localVarFetchArgs = ExperimentServiceApiFetchParamCreator(configuration).updateExperiment2(owner, project, experiment_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ExperimentServiceApi - factory interface
 * @export
 */
export const ExperimentServiceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Restore build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveExperiment(owner: string, project: string, id: string, options?: any) {
            return ExperimentServiceApiFp(configuration).archiveExperiment(owner, project, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary UnBookmark build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkExperiment(owner: string, project: string, id: string, options?: any) {
            return ExperimentServiceApiFp(configuration).bookmarkExperiment(owner, project, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {V1ExperimentBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExperiment(owner: string, project: string, body: V1ExperimentBodyRequest, options?: any) {
            return ExperimentServiceApiFp(configuration).createExperiment(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get experiment code ref
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_id Unique integer identifier of the entity
         * @param {V1CodeReferenceBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExperimentCodeRef(entity_owner: string, entity_project: string, entity_id: string, body: V1CodeReferenceBodyRequest, options?: any) {
            return ExperimentServiceApiFp(configuration).createExperimentCodeRef(entity_owner, entity_project, entity_id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get job code ref
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExperimentStatus(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any) {
            return ExperimentServiceApiFp(configuration).createExperimentStatus(owner, project, id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExperiment(owner: string, project: string, id: string, options?: any) {
            return ExperimentServiceApiFp(configuration).deleteExperiment(owner, project, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete builds
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExperiments(owner: string, project: string, body: V1OwnedEntityIdRequest, options?: any) {
            return ExperimentServiceApiFp(configuration).deleteExperiments(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperiment(owner: string, project: string, id: string, options?: any) {
            return ExperimentServiceApiFp(configuration).getExperiment(owner, project, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get experiment code ref
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperimentCodeRef(owner: string, project: string, id: string, options?: any) {
            return ExperimentServiceApiFp(configuration).getExperimentCodeRef(owner, project, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List archived builds
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedExperiments(owner: string, options?: any) {
            return ExperimentServiceApiFp(configuration).listArchivedExperiments(owner, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked builds
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedExperiments(owner: string, options?: any) {
            return ExperimentServiceApiFp(configuration).listBookmarkedExperiments(owner, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create build code ref
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExperimentStatuses(owner: string, project: string, id: string, options?: any) {
            return ExperimentServiceApiFp(configuration).listExperimentStatuses(owner, project, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List builds
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExperiments(owner: string, project: string, options?: any) {
            return ExperimentServiceApiFp(configuration).listExperiments(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Restart build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartExperiment(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any) {
            return ExperimentServiceApiFp(configuration).restartExperiment(owner, project, id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Bookmark build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreExperiment(owner: string, project: string, id: string, options?: any) {
            return ExperimentServiceApiFp(configuration).restoreExperiment(owner, project, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Archive build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeExperiment(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any) {
            return ExperimentServiceApiFp(configuration).resumeExperiment(owner, project, id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List build statuses
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startExperimentTensorboard(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any) {
            return ExperimentServiceApiFp(configuration).startExperimentTensorboard(owner, project, id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stop build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopExperiment(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any) {
            return ExperimentServiceApiFp(configuration).stopExperiment(owner, project, id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new build status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopExperimentTensorboard(owner: string, project: string, id: string, options?: any) {
            return ExperimentServiceApiFp(configuration).stopExperimentTensorboard(owner, project, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stop builds
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1ProjectBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopExperiments(owner: string, project: string, body: V1ProjectBodyRequest, options?: any) {
            return ExperimentServiceApiFp(configuration).stopExperiments(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get build status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unBookmarkExperiment(owner: string, project: string, id: string, options?: any) {
            return ExperimentServiceApiFp(configuration).unBookmarkExperiment(owner, project, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} experiment_id Unique integer identifier
         * @param {V1ExperimentBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExperiment2(owner: string, project: string, experiment_id: string, body: V1ExperimentBodyRequest, options?: any) {
            return ExperimentServiceApiFp(configuration).updateExperiment2(owner, project, experiment_id, body, options)(fetch, basePath);
        },
    };
};

/**
 * ExperimentServiceApi - object-oriented interface
 * @export
 * @class ExperimentServiceApi
 * @extends {BaseAPI}
 */
export class ExperimentServiceApi extends BaseAPI {
    /**
     * 
     * @summary Restore build
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public archiveExperiment(owner: string, project: string, id: string, options?: any) {
        return ExperimentServiceApiFp(this.configuration).archiveExperiment(owner, project, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary UnBookmark build
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public bookmarkExperiment(owner: string, project: string, id: string, options?: any) {
        return ExperimentServiceApiFp(this.configuration).bookmarkExperiment(owner, project, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new build
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {V1ExperimentBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public createExperiment(owner: string, project: string, body: V1ExperimentBodyRequest, options?: any) {
        return ExperimentServiceApiFp(this.configuration).createExperiment(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get experiment code ref
     * @param {string} entity_owner Owner of the namespace
     * @param {string} entity_project Project where the experiement will be assigned
     * @param {string} entity_id Unique integer identifier of the entity
     * @param {V1CodeReferenceBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public createExperimentCodeRef(entity_owner: string, entity_project: string, entity_id: string, body: V1CodeReferenceBodyRequest, options?: any) {
        return ExperimentServiceApiFp(this.configuration).createExperimentCodeRef(entity_owner, entity_project, entity_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get job code ref
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {V1OwnedEntityIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public createExperimentStatus(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any) {
        return ExperimentServiceApiFp(this.configuration).createExperimentStatus(owner, project, id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete build
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public deleteExperiment(owner: string, project: string, id: string, options?: any) {
        return ExperimentServiceApiFp(this.configuration).deleteExperiment(owner, project, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete builds
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {V1OwnedEntityIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public deleteExperiments(owner: string, project: string, body: V1OwnedEntityIdRequest, options?: any) {
        return ExperimentServiceApiFp(this.configuration).deleteExperiments(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get build
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public getExperiment(owner: string, project: string, id: string, options?: any) {
        return ExperimentServiceApiFp(this.configuration).getExperiment(owner, project, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get experiment code ref
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public getExperimentCodeRef(owner: string, project: string, id: string, options?: any) {
        return ExperimentServiceApiFp(this.configuration).getExperimentCodeRef(owner, project, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List archived builds
     * @param {string} owner Owner of the namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public listArchivedExperiments(owner: string, options?: any) {
        return ExperimentServiceApiFp(this.configuration).listArchivedExperiments(owner, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked builds
     * @param {string} owner Owner of the namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public listBookmarkedExperiments(owner: string, options?: any) {
        return ExperimentServiceApiFp(this.configuration).listBookmarkedExperiments(owner, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create build code ref
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public listExperimentStatuses(owner: string, project: string, id: string, options?: any) {
        return ExperimentServiceApiFp(this.configuration).listExperimentStatuses(owner, project, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List builds
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public listExperiments(owner: string, project: string, options?: any) {
        return ExperimentServiceApiFp(this.configuration).listExperiments(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Restart build
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {V1OwnedEntityIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public restartExperiment(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any) {
        return ExperimentServiceApiFp(this.configuration).restartExperiment(owner, project, id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Bookmark build
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public restoreExperiment(owner: string, project: string, id: string, options?: any) {
        return ExperimentServiceApiFp(this.configuration).restoreExperiment(owner, project, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Archive build
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {V1OwnedEntityIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public resumeExperiment(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any) {
        return ExperimentServiceApiFp(this.configuration).resumeExperiment(owner, project, id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List build statuses
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {V1OwnedEntityIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public startExperimentTensorboard(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any) {
        return ExperimentServiceApiFp(this.configuration).startExperimentTensorboard(owner, project, id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stop build
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {V1OwnedEntityIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public stopExperiment(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any) {
        return ExperimentServiceApiFp(this.configuration).stopExperiment(owner, project, id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new build status
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public stopExperimentTensorboard(owner: string, project: string, id: string, options?: any) {
        return ExperimentServiceApiFp(this.configuration).stopExperimentTensorboard(owner, project, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stop builds
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {V1ProjectBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public stopExperiments(owner: string, project: string, body: V1ProjectBodyRequest, options?: any) {
        return ExperimentServiceApiFp(this.configuration).stopExperiments(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get build status
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public unBookmarkExperiment(owner: string, project: string, id: string, options?: any) {
        return ExperimentServiceApiFp(this.configuration).unBookmarkExperiment(owner, project, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update build
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} experiment_id Unique integer identifier
     * @param {V1ExperimentBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExperimentServiceApi
     */
    public updateExperiment2(owner: string, project: string, experiment_id: string, body: V1ExperimentBodyRequest, options?: any) {
        return ExperimentServiceApiFp(this.configuration).updateExperiment2(owner, project, experiment_id, body, options)(this.fetch, this.basePath);
    }

}

/**
 * JobServiceApi - fetch parameter creator
 * @export
 */
export const JobServiceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Restore build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveJob(owner: string, project: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling archiveJob.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling archiveJob.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling archiveJob.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/jobs/{id}/archive`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary UnBookmark build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkJob(owner: string, project: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling bookmarkJob.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling bookmarkJob.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling bookmarkJob.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/jobs/{id}/bookmark`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {V1JobBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJob(owner: string, project: string, body: V1JobBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createJob.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling createJob.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createJob.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/jobs`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1JobBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get job code ref
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_id Unique integer identifier of the entity
         * @param {V1CodeReferenceBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobCodeRef(entity_owner: string, entity_project: string, entity_id: string, body: V1CodeReferenceBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'entity_owner' is not null or undefined
            if (entity_owner === null || entity_owner === undefined) {
                throw new RequiredError('entity_owner','Required parameter entity_owner was null or undefined when calling createJobCodeRef.');
            }
            // verify required parameter 'entity_project' is not null or undefined
            if (entity_project === null || entity_project === undefined) {
                throw new RequiredError('entity_project','Required parameter entity_project was null or undefined when calling createJobCodeRef.');
            }
            // verify required parameter 'entity_id' is not null or undefined
            if (entity_id === null || entity_id === undefined) {
                throw new RequiredError('entity_id','Required parameter entity_id was null or undefined when calling createJobCodeRef.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createJobCodeRef.');
            }
            const localVarPath = `/api/v1/{entity.owner}/{entity.project}/jobs/{entity.id}/coderef`
                .replace(`{${"entity.owner"}}`, encodeURIComponent(String(entity_owner)))
                .replace(`{${"entity.project"}}`, encodeURIComponent(String(entity_project)))
                .replace(`{${"entity.id"}}`, encodeURIComponent(String(entity_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1CodeReferenceBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get build code ref
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobStatus(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createJobStatus.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling createJobStatus.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling createJobStatus.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createJobStatus.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/jobs/{id}/statuses`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1OwnedEntityIdRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJob(owner: string, project: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteJob.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling deleteJob.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteJob.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/jobs/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete builds
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobs(owner: string, project: string, body: V1OwnedEntityIdRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteJobs.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling deleteJobs.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling deleteJobs.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/jobs/delete`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1OwnedEntityIdRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob(owner: string, project: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getJob.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getJob.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getJob.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/jobs/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create build code ref
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobCodeRef(owner: string, project: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getJobCodeRef.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getJobCodeRef.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getJobCodeRef.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/jobs/{id}/coderef`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List archived builds
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedJobs(owner: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listArchivedJobs.');
            }
            const localVarPath = `/api/v1/archives/{owner}/jobs`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked builds
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedJobs(owner: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listBookmarkedJobs.');
            }
            const localVarPath = `/api/v1/bookmarks/{owner}/jobs`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new build status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobStatuses(owner: string, project: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listJobStatuses.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling listJobStatuses.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listJobStatuses.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/jobs/{id}/statuses`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List builds
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobs(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listJobs.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling listJobs.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/jobs`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restart build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartJob(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling restartJob.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling restartJob.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling restartJob.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling restartJob.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/jobs/{id}/restart`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1OwnedEntityIdRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Bookmark build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreJob(owner: string, project: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling restoreJob.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling restoreJob.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling restoreJob.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/jobs/{id}/restore`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Archive build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeJob(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling resumeJob.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling resumeJob.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling resumeJob.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling resumeJob.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/jobs/{id}/resume`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1OwnedEntityIdRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopJob(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling stopJob.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling stopJob.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling stopJob.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling stopJob.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/jobs/{id}/stop`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1OwnedEntityIdRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop builds
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1ProjectBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopJobs(owner: string, project: string, body: V1ProjectBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling stopJobs.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling stopJobs.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling stopJobs.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/jobs/stop`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ProjectBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get build status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unBookmarkJob(owner: string, project: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling unBookmarkJob.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling unBookmarkJob.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling unBookmarkJob.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/jobs/{id}/unbookmark`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} job_id Unique integer identifier
         * @param {V1JobBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJob2(owner: string, project: string, job_id: string, body: V1JobBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateJob2.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling updateJob2.');
            }
            // verify required parameter 'job_id' is not null or undefined
            if (job_id === null || job_id === undefined) {
                throw new RequiredError('job_id','Required parameter job_id was null or undefined when calling updateJob2.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateJob2.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/jobs/{job.id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"job.id"}}`, encodeURIComponent(String(job_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1JobBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobServiceApi - functional programming interface
 * @export
 */
export const JobServiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Restore build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveJob(owner: string, project: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = JobServiceApiFetchParamCreator(configuration).archiveJob(owner, project, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary UnBookmark build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkJob(owner: string, project: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = JobServiceApiFetchParamCreator(configuration).bookmarkJob(owner, project, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {V1JobBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJob(owner: string, project: string, body: V1JobBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Job> {
            const localVarFetchArgs = JobServiceApiFetchParamCreator(configuration).createJob(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get job code ref
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_id Unique integer identifier of the entity
         * @param {V1CodeReferenceBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobCodeRef(entity_owner: string, entity_project: string, entity_id: string, body: V1CodeReferenceBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1CodeReference> {
            const localVarFetchArgs = JobServiceApiFetchParamCreator(configuration).createJobCodeRef(entity_owner, entity_project, entity_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get build code ref
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobStatus(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1JobStatus> {
            const localVarFetchArgs = JobServiceApiFetchParamCreator(configuration).createJobStatus(owner, project, id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJob(owner: string, project: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = JobServiceApiFetchParamCreator(configuration).deleteJob(owner, project, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete builds
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobs(owner: string, project: string, body: V1OwnedEntityIdRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = JobServiceApiFetchParamCreator(configuration).deleteJobs(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob(owner: string, project: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Job> {
            const localVarFetchArgs = JobServiceApiFetchParamCreator(configuration).getJob(owner, project, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create build code ref
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobCodeRef(owner: string, project: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1CodeReference> {
            const localVarFetchArgs = JobServiceApiFetchParamCreator(configuration).getJobCodeRef(owner, project, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List archived builds
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedJobs(owner: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListJobsResponse> {
            const localVarFetchArgs = JobServiceApiFetchParamCreator(configuration).listArchivedJobs(owner, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked builds
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedJobs(owner: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListJobsResponse> {
            const localVarFetchArgs = JobServiceApiFetchParamCreator(configuration).listBookmarkedJobs(owner, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new build status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobStatuses(owner: string, project: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListJobStatusesResponse> {
            const localVarFetchArgs = JobServiceApiFetchParamCreator(configuration).listJobStatuses(owner, project, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List builds
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobs(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListJobsResponse> {
            const localVarFetchArgs = JobServiceApiFetchParamCreator(configuration).listJobs(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Restart build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartJob(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Job> {
            const localVarFetchArgs = JobServiceApiFetchParamCreator(configuration).restartJob(owner, project, id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Bookmark build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreJob(owner: string, project: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = JobServiceApiFetchParamCreator(configuration).restoreJob(owner, project, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Archive build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeJob(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Job> {
            const localVarFetchArgs = JobServiceApiFetchParamCreator(configuration).resumeJob(owner, project, id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stop build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopJob(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = JobServiceApiFetchParamCreator(configuration).stopJob(owner, project, id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stop builds
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1ProjectBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopJobs(owner: string, project: string, body: V1ProjectBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = JobServiceApiFetchParamCreator(configuration).stopJobs(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get build status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unBookmarkJob(owner: string, project: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = JobServiceApiFetchParamCreator(configuration).unBookmarkJob(owner, project, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} job_id Unique integer identifier
         * @param {V1JobBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJob2(owner: string, project: string, job_id: string, body: V1JobBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Job> {
            const localVarFetchArgs = JobServiceApiFetchParamCreator(configuration).updateJob2(owner, project, job_id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * JobServiceApi - factory interface
 * @export
 */
export const JobServiceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Restore build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveJob(owner: string, project: string, id: string, options?: any) {
            return JobServiceApiFp(configuration).archiveJob(owner, project, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary UnBookmark build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkJob(owner: string, project: string, id: string, options?: any) {
            return JobServiceApiFp(configuration).bookmarkJob(owner, project, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {V1JobBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJob(owner: string, project: string, body: V1JobBodyRequest, options?: any) {
            return JobServiceApiFp(configuration).createJob(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get job code ref
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_id Unique integer identifier of the entity
         * @param {V1CodeReferenceBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobCodeRef(entity_owner: string, entity_project: string, entity_id: string, body: V1CodeReferenceBodyRequest, options?: any) {
            return JobServiceApiFp(configuration).createJobCodeRef(entity_owner, entity_project, entity_id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get build code ref
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobStatus(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any) {
            return JobServiceApiFp(configuration).createJobStatus(owner, project, id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJob(owner: string, project: string, id: string, options?: any) {
            return JobServiceApiFp(configuration).deleteJob(owner, project, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete builds
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobs(owner: string, project: string, body: V1OwnedEntityIdRequest, options?: any) {
            return JobServiceApiFp(configuration).deleteJobs(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob(owner: string, project: string, id: string, options?: any) {
            return JobServiceApiFp(configuration).getJob(owner, project, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create build code ref
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobCodeRef(owner: string, project: string, id: string, options?: any) {
            return JobServiceApiFp(configuration).getJobCodeRef(owner, project, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List archived builds
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedJobs(owner: string, options?: any) {
            return JobServiceApiFp(configuration).listArchivedJobs(owner, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked builds
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedJobs(owner: string, options?: any) {
            return JobServiceApiFp(configuration).listBookmarkedJobs(owner, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new build status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobStatuses(owner: string, project: string, id: string, options?: any) {
            return JobServiceApiFp(configuration).listJobStatuses(owner, project, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List builds
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobs(owner: string, project: string, options?: any) {
            return JobServiceApiFp(configuration).listJobs(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Restart build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartJob(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any) {
            return JobServiceApiFp(configuration).restartJob(owner, project, id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Bookmark build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreJob(owner: string, project: string, id: string, options?: any) {
            return JobServiceApiFp(configuration).restoreJob(owner, project, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Archive build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeJob(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any) {
            return JobServiceApiFp(configuration).resumeJob(owner, project, id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stop build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {V1OwnedEntityIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopJob(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any) {
            return JobServiceApiFp(configuration).stopJob(owner, project, id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stop builds
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1ProjectBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopJobs(owner: string, project: string, body: V1ProjectBodyRequest, options?: any) {
            return JobServiceApiFp(configuration).stopJobs(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get build status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} id Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unBookmarkJob(owner: string, project: string, id: string, options?: any) {
            return JobServiceApiFp(configuration).unBookmarkJob(owner, project, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update build
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} job_id Unique integer identifier
         * @param {V1JobBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJob2(owner: string, project: string, job_id: string, body: V1JobBodyRequest, options?: any) {
            return JobServiceApiFp(configuration).updateJob2(owner, project, job_id, body, options)(fetch, basePath);
        },
    };
};

/**
 * JobServiceApi - object-oriented interface
 * @export
 * @class JobServiceApi
 * @extends {BaseAPI}
 */
export class JobServiceApi extends BaseAPI {
    /**
     * 
     * @summary Restore build
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobServiceApi
     */
    public archiveJob(owner: string, project: string, id: string, options?: any) {
        return JobServiceApiFp(this.configuration).archiveJob(owner, project, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary UnBookmark build
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobServiceApi
     */
    public bookmarkJob(owner: string, project: string, id: string, options?: any) {
        return JobServiceApiFp(this.configuration).bookmarkJob(owner, project, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new build
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {V1JobBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobServiceApi
     */
    public createJob(owner: string, project: string, body: V1JobBodyRequest, options?: any) {
        return JobServiceApiFp(this.configuration).createJob(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get job code ref
     * @param {string} entity_owner Owner of the namespace
     * @param {string} entity_project Project where the experiement will be assigned
     * @param {string} entity_id Unique integer identifier of the entity
     * @param {V1CodeReferenceBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobServiceApi
     */
    public createJobCodeRef(entity_owner: string, entity_project: string, entity_id: string, body: V1CodeReferenceBodyRequest, options?: any) {
        return JobServiceApiFp(this.configuration).createJobCodeRef(entity_owner, entity_project, entity_id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get build code ref
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {V1OwnedEntityIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobServiceApi
     */
    public createJobStatus(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any) {
        return JobServiceApiFp(this.configuration).createJobStatus(owner, project, id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete build
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobServiceApi
     */
    public deleteJob(owner: string, project: string, id: string, options?: any) {
        return JobServiceApiFp(this.configuration).deleteJob(owner, project, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete builds
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {V1OwnedEntityIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobServiceApi
     */
    public deleteJobs(owner: string, project: string, body: V1OwnedEntityIdRequest, options?: any) {
        return JobServiceApiFp(this.configuration).deleteJobs(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get build
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobServiceApi
     */
    public getJob(owner: string, project: string, id: string, options?: any) {
        return JobServiceApiFp(this.configuration).getJob(owner, project, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create build code ref
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobServiceApi
     */
    public getJobCodeRef(owner: string, project: string, id: string, options?: any) {
        return JobServiceApiFp(this.configuration).getJobCodeRef(owner, project, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List archived builds
     * @param {string} owner Owner of the namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobServiceApi
     */
    public listArchivedJobs(owner: string, options?: any) {
        return JobServiceApiFp(this.configuration).listArchivedJobs(owner, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked builds
     * @param {string} owner Owner of the namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobServiceApi
     */
    public listBookmarkedJobs(owner: string, options?: any) {
        return JobServiceApiFp(this.configuration).listBookmarkedJobs(owner, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new build status
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobServiceApi
     */
    public listJobStatuses(owner: string, project: string, id: string, options?: any) {
        return JobServiceApiFp(this.configuration).listJobStatuses(owner, project, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List builds
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobServiceApi
     */
    public listJobs(owner: string, project: string, options?: any) {
        return JobServiceApiFp(this.configuration).listJobs(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Restart build
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {V1OwnedEntityIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobServiceApi
     */
    public restartJob(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any) {
        return JobServiceApiFp(this.configuration).restartJob(owner, project, id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Bookmark build
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobServiceApi
     */
    public restoreJob(owner: string, project: string, id: string, options?: any) {
        return JobServiceApiFp(this.configuration).restoreJob(owner, project, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Archive build
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {V1OwnedEntityIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobServiceApi
     */
    public resumeJob(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any) {
        return JobServiceApiFp(this.configuration).resumeJob(owner, project, id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stop build
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {V1OwnedEntityIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobServiceApi
     */
    public stopJob(owner: string, project: string, id: string, body: V1OwnedEntityIdRequest, options?: any) {
        return JobServiceApiFp(this.configuration).stopJob(owner, project, id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stop builds
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {V1ProjectBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobServiceApi
     */
    public stopJobs(owner: string, project: string, body: V1ProjectBodyRequest, options?: any) {
        return JobServiceApiFp(this.configuration).stopJobs(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get build status
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} id Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobServiceApi
     */
    public unBookmarkJob(owner: string, project: string, id: string, options?: any) {
        return JobServiceApiFp(this.configuration).unBookmarkJob(owner, project, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update build
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} job_id Unique integer identifier
     * @param {V1JobBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobServiceApi
     */
    public updateJob2(owner: string, project: string, job_id: string, body: V1JobBodyRequest, options?: any) {
        return JobServiceApiFp(this.configuration).updateJob2(owner, project, job_id, body, options)(this.fetch, this.basePath);
    }

}

