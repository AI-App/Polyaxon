// Copyright 2019 Polyaxon, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Polyaxon SDKs and REST API specification.
 * Polyaxon SDKs and REST API specification.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: contact@polyaxon.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * `NullValue` is a singleton enumeration to represent the null value for the `Value` type union.   The JSON representation for `NullValue` is JSON `null`.   - NULL_VALUE: Null value.
 * @export
 * @enum {string}
 */
export enum ProtobufNullValue {
    NULLVALUE = <any> 'NULL_VALUE'
}

/**
 * 
 * @export
 * @interface V1Agent
 */
export interface V1Agent {
    /**
     * 
     * @type {string}
     * @memberof V1Agent
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Agent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Agent
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Agent
     */
    tags?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof V1Agent
     */
    disabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1Agent
     */
    deleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1Agent
     */
    namespace?: string;
    /**
     * 
     * @type {any}
     * @memberof V1Agent
     */
    version_api?: any;
    /**
     * 
     * @type {Date}
     * @memberof V1Agent
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Agent
     */
    updated_at?: Date;
}

/**
 * - csv: Comma  - tsv: Tab  - psv: Pipe  - ssv: Space
 * @export
 * @enum {string}
 */
export enum V1ArtifactFormat {
    Csv = <any> 'csv',
    Tsv = <any> 'tsv',
    Psv = <any> 'psv',
    Ssv = <any> 'ssv'
}

/**
 * 
 * @export
 * @interface V1ArtifactMount
 */
export interface V1ArtifactMount {
    /**
     * 
     * @type {string}
     * @memberof V1ArtifactMount
     */
    name?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1ArtifactMount
     */
    paths?: Array<string>;
}

/**
 * 
 * @export
 * @interface V1ArtifactTreeResponse
 */
export interface V1ArtifactTreeResponse {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1ArtifactTreeResponse
     */
    files?: { [key: string]: string; };
    /**
     * 
     * @type {Array<string>}
     * @memberof V1ArtifactTreeResponse
     */
    dirs?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof V1ArtifactTreeResponse
     */
    is_done?: boolean;
}

/**
 * 
 * @export
 * @interface V1Auth
 */
export interface V1Auth {
    /**
     * 
     * @type {string}
     * @memberof V1Auth
     */
    token?: string;
}

/**
 * Early stopping with average stopping, this policy computes running averages across all runs and stops those whose best performance is worse than the median of the running runs.
 * @export
 * @interface V1AverageStoppingPolicy
 */
export interface V1AverageStoppingPolicy {
    /**
     * 
     * @type {string}
     * @memberof V1AverageStoppingPolicy
     */
    kind?: string;
    /**
     * Interval/Frequency for applying the policy.
     * @type {number}
     * @memberof V1AverageStoppingPolicy
     */
    evaluation_interval?: number;
}

/**
 * 
 * @export
 * @interface V1BO
 */
export interface V1BO {
    /**
     * 
     * @type {string}
     * @memberof V1BO
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof V1BO
     */
    matrix?: string;
    /**
     * 
     * @type {number}
     * @memberof V1BO
     */
    n_initial_trials?: number;
    /**
     * 
     * @type {number}
     * @memberof V1BO
     */
    n_iterations?: number;
    /**
     * 
     * @type {any}
     * @memberof V1BO
     */
    utility_function?: any;
    /**
     * 
     * @type {V1OptimizationMetric}
     * @memberof V1BO
     */
    metric?: V1OptimizationMetric;
    /**
     * 
     * @type {number}
     * @memberof V1BO
     */
    seed?: number;
    /**
     * 
     * @type {number}
     * @memberof V1BO
     */
    concurrency?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1BO
     */
    early_stopping?: Array<any>;
}

/**
 * 
 * @export
 * @interface V1BlobConnection
 */
export interface V1BlobConnection {
    /**
     * 
     * @type {string}
     * @memberof V1BlobConnection
     */
    blob?: string;
}

/**
 * 
 * @export
 * @interface V1BuildContext
 */
export interface V1BuildContext {
    /**
     * 
     * @type {string}
     * @memberof V1BuildContext
     */
    image?: string;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1BuildContext
     */
    env?: Array<any>;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1BuildContext
     */
    path?: Array<any>;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1BuildContext
     */
    copy?: Array<any>;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1BuildContext
     */
    run?: Array<any>;
    /**
     * 
     * @type {string}
     * @memberof V1BuildContext
     */
    lang_env?: string;
    /**
     * 
     * @type {number}
     * @memberof V1BuildContext
     */
    uid?: number;
    /**
     * 
     * @type {number}
     * @memberof V1BuildContext
     */
    gid?: number;
    /**
     * 
     * @type {string}
     * @memberof V1BuildContext
     */
    filename?: string;
    /**
     * 
     * @type {string}
     * @memberof V1BuildContext
     */
    workdir?: string;
    /**
     * 
     * @type {string}
     * @memberof V1BuildContext
     */
    workdir_path?: string;
    /**
     * 
     * @type {string}
     * @memberof V1BuildContext
     */
    shell?: string;
}

/**
 * 
 * @export
 * @interface V1ClaimConnection
 */
export interface V1ClaimConnection {
    /**
     * 
     * @type {string}
     * @memberof V1ClaimConnection
     */
    volume_claim?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ClaimConnection
     */
    mount_path?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1ClaimConnection
     */
    read_only?: boolean;
}

/**
 * 
 * @export
 * @interface V1CodeRef
 */
export interface V1CodeRef {
    /**
     * 
     * @type {string}
     * @memberof V1CodeRef
     */
    commit?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CodeRef
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface V1Component
 */
export interface V1Component {
    /**
     * 
     * @type {number}
     * @memberof V1Component
     */
    version?: number;
    /**
     * 
     * @type {string}
     * @memberof V1Component
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Component
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Component
     */
    tag?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Component
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Component
     */
    tags?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof V1Component
     */
    profile?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Component
     */
    queue?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1Component
     */
    nocache?: boolean;
    /**
     * 
     * @type {V1Environment}
     * @memberof V1Component
     */
    environment?: V1Environment;
    /**
     * 
     * @type {V1Termination}
     * @memberof V1Component
     */
    termination?: V1Termination;
    /**
     * 
     * @type {V1Init}
     * @memberof V1Component
     */
    init?: V1Init;
    /**
     * 
     * @type {V1Mounts}
     * @memberof V1Component
     */
    mounts?: V1Mounts;
    /**
     * 
     * @type {any}
     * @memberof V1Component
     */
    schedule?: any;
    /**
     * 
     * @type {any}
     * @memberof V1Component
     */
    parallel?: any;
    /**
     * 
     * @type {V1Service}
     * @memberof V1Component
     */
    service?: V1Service;
    /**
     * 
     * @type {Array<V1IO>}
     * @memberof V1Component
     */
    inputs?: Array<V1IO>;
    /**
     * 
     * @type {Array<V1IO>}
     * @memberof V1Component
     */
    outputs?: Array<V1IO>;
    /**
     * 
     * @type {any}
     * @memberof V1Component
     */
    run?: any;
}

/**
 * 
 * @export
 * @interface V1ComponentRef
 */
export interface V1ComponentRef {
    /**
     * 
     * @type {string}
     * @memberof V1ComponentRef
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ComponentRef
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ComponentRef
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ComponentRef
     */
    hub?: string;
}

/**
 * 
 * @export
 * @interface V1ConfigResource
 */
export interface V1ConfigResource {
    /**
     * 
     * @type {string}
     * @memberof V1ConfigResource
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ConfigResource
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ConfigResource
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1ConfigResource
     */
    tags?: Array<string>;
    /**
     * 
     * @type {Date}
     * @memberof V1ConfigResource
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1ConfigResource
     */
    updated_at?: Date;
    /**
     * 
     * @type {string}
     * @memberof V1ConfigResource
     */
    k8s_ref?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1ConfigResource
     */
    is_secret?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1ConfigResource
     */
    frozen?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1ConfigResource
     */
    disabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1ConfigResource
     */
    deleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1ConfigResource
     */
    mount_path?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1ConfigResource
     */
    items?: Array<string>;
}

/**
 * 
 * @export
 * @interface V1Connection
 */
export interface V1Connection {
    /**
     * 
     * @type {string}
     * @memberof V1Connection
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Connection
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Connection
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Connection
     */
    tags?: Array<string>;
    /**
     * 
     * @type {Date}
     * @memberof V1Connection
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Connection
     */
    updated_at?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof V1Connection
     */
    frozen?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1Connection
     */
    disabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1Connection
     */
    deleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1Connection
     */
    config_resource?: string;
    /**
     * 
     * @type {V1ConnectionKind}
     * @memberof V1Connection
     */
    kind?: V1ConnectionKind;
    /**
     * 
     * @type {any}
     * @memberof V1Connection
     */
    schema?: any;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum V1ConnectionKind {
    HostPath = <any> 'host_path',
    VolumeClaim = <any> 'volume_claim',
    Ftp = <any> 'ftp',
    Gcp = <any> 'gcp',
    Gcs = <any> 'gcs',
    Gcpcloudsql = <any> 'gcpcloudsql',
    Grpc = <any> 'grpc',
    Hdfs = <any> 'hdfs',
    Http = <any> 'http',
    PigCli = <any> 'pig_cli',
    HiveCli = <any> 'hive_cli',
    HiveMetastore = <any> 'hive_metastore',
    HiveServer2 = <any> 'hive_server2',
    Jdbc = <any> 'jdbc',
    Jenkins = <any> 'jenkins',
    Mysql = <any> 'mysql',
    Postgres = <any> 'postgres',
    Oracle = <any> 'oracle',
    Vertica = <any> 'vertica',
    Sqlite = <any> 'sqlite',
    Mssql = <any> 'mssql',
    Redis = <any> 'redis',
    Presto = <any> 'presto',
    Mongo = <any> 'mongo',
    Cassandra = <any> 'cassandra',
    Samba = <any> 'samba',
    Aws = <any> 'aws',
    S3 = <any> 's3',
    Emr = <any> 'emr',
    Snowflake = <any> 'snowflake',
    Ssh = <any> 'ssh',
    Cloudant = <any> 'cloudant',
    Databricks = <any> 'databricks',
    Segment = <any> 'segment',
    AzureDataLake = <any> 'azure_data_lake',
    AzureCosmos = <any> 'azure_cosmos',
    Wasb = <any> 'wasb',
    Registry = <any> 'registry',
    Git = <any> 'git'
}

/**
 * 
 * @export
 * @interface V1ConnectionScema
 */
export interface V1ConnectionScema {
    /**
     * 
     * @type {V1BlobConnection}
     * @memberof V1ConnectionScema
     */
    blob_connection?: V1BlobConnection;
    /**
     * 
     * @type {V1HostPathConnection}
     * @memberof V1ConnectionScema
     */
    host_path_connection?: V1HostPathConnection;
    /**
     * 
     * @type {V1ClaimConnection}
     * @memberof V1ConnectionScema
     */
    claim_connection?: V1ClaimConnection;
    /**
     * 
     * @type {V1HostConnection}
     * @memberof V1ConnectionScema
     */
    host_connection?: V1HostConnection;
}

/**
 * 
 * @export
 * @interface V1Container
 */
export interface V1Container {
    /**
     * 
     * @type {string}
     * @memberof V1Container
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Container
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Container
     */
    image_pull_policy?: string;
    /**
     * The command to execute on the container.
     * @type {Array<string>}
     * @memberof V1Container
     */
    command?: Array<string>;
    /**
     * Arguments to the entrypoint.
     * @type {Array<string>}
     * @memberof V1Container
     */
    args?: Array<string>;
}

/**
 * 
 * @export
 * @interface V1ContainerEnv
 */
export interface V1ContainerEnv {
    /**
     * 
     * @type {string}
     * @memberof V1ContainerEnv
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ContainerEnv
     */
    image_pull_policy?: string;
    /**
     * 
     * @type {number}
     * @memberof V1ContainerEnv
     */
    sleep_interval?: number;
    /**
     * 
     * @type {number}
     * @memberof V1ContainerEnv
     */
    outputs_sync_interval?: number;
    /**
     * 
     * @type {number}
     * @memberof V1ContainerEnv
     */
    logs_sync_interval?: number;
}

/**
 * 
 * @export
 * @interface V1CredsBodyRequest
 */
export interface V1CredsBodyRequest {
    /**
     * 
     * @type {string}
     * @memberof V1CredsBodyRequest
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CredsBodyRequest
     */
    password?: string;
}

/**
 * 
 * @export
 * @interface V1CronSchedule
 */
export interface V1CronSchedule {
    /**
     * 
     * @type {string}
     * @memberof V1CronSchedule
     */
    kind?: string;
    /**
     * 
     * @type {Date}
     * @memberof V1CronSchedule
     */
    start_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1CronSchedule
     */
    end_at?: Date;
    /**
     * 
     * @type {string}
     * @memberof V1CronSchedule
     */
    cron?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1CronSchedule
     */
    depends_on_past?: boolean;
}

/**
 * 
 * @export
 * @interface V1Dag
 */
export interface V1Dag {
    /**
     * 
     * @type {string}
     * @memberof V1Dag
     */
    kind?: string;
    /**
     * 
     * @type {Array<V1Op>}
     * @memberof V1Dag
     */
    ops?: Array<V1Op>;
    /**
     * 
     * @type {Array<V1Component>}
     * @memberof V1Dag
     */
    components?: Array<V1Component>;
    /**
     * 
     * @type {number}
     * @memberof V1Dag
     */
    concurrency?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1Dag
     */
    early_stopping?: Array<any>;
}

/**
 * 
 * @export
 * @interface V1Dashboard
 */
export interface V1Dashboard {
    /**
     * 
     * @type {string}
     * @memberof V1Dashboard
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Dashboard
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Dashboard
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Dashboard
     */
    tags?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof V1Dashboard
     */
    disabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1Dashboard
     */
    deleted?: boolean;
    /**
     * 
     * @type {Array<V1WidgetSpec>}
     * @memberof V1Dashboard
     */
    widgets?: Array<V1WidgetSpec>;
    /**
     * 
     * @type {Date}
     * @memberof V1Dashboard
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Dashboard
     */
    updated_at?: Date;
}

/**
 * 
 * @export
 * @interface V1Dask
 */
export interface V1Dask {
    /**
     * 
     * @type {string}
     * @memberof V1Dask
     */
    kind?: string;
    /**
     * 
     * @type {any}
     * @memberof V1Dask
     */
    spec?: any;
}

/**
 * 
 * @export
 * @interface V1EarlyStopping
 */
export interface V1EarlyStopping {
    /**
     * 
     * @type {V1MedianStoppingPolicy}
     * @memberof V1EarlyStopping
     */
    median?: V1MedianStoppingPolicy;
    /**
     * 
     * @type {V1AverageStoppingPolicy}
     * @memberof V1EarlyStopping
     */
    average?: V1AverageStoppingPolicy;
    /**
     * 
     * @type {V1TruncationStoppingPolicy}
     * @memberof V1EarlyStopping
     */
    truncation?: V1TruncationStoppingPolicy;
    /**
     * 
     * @type {V1MetricEarlyStopping}
     * @memberof V1EarlyStopping
     */
    metric?: V1MetricEarlyStopping;
    /**
     * 
     * @type {V1FailureEarlyStopping}
     * @memberof V1EarlyStopping
     */
    failure?: V1FailureEarlyStopping;
}

/**
 * 
 * @export
 * @interface V1EntityStatusBodyRequest
 */
export interface V1EntityStatusBodyRequest {
    /**
     * 
     * @type {string}
     * @memberof V1EntityStatusBodyRequest
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EntityStatusBodyRequest
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EntityStatusBodyRequest
     */
    uuid?: string;
    /**
     * 
     * @type {V1StatusCondition}
     * @memberof V1EntityStatusBodyRequest
     */
    condition?: V1StatusCondition;
}

/**
 * 
 * @export
 * @interface V1Environment
 */
export interface V1Environment {
    /**
     * 
     * @type {V1ResourceRequirements}
     * @memberof V1Environment
     */
    resources?: V1ResourceRequirements;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1Environment
     */
    labels?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1Environment
     */
    annotations?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1Environment
     */
    node_selector?: { [key: string]: string; };
    /**
     * 
     * @type {Array<any>}
     * @memberof V1Environment
     */
    affinity?: Array<any>;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1Environment
     */
    tolerations?: Array<any>;
    /**
     * 
     * @type {string}
     * @memberof V1Environment
     */
    service_account?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Environment
     */
    image_pull_secrets?: Array<string>;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1Environment
     */
    env_vars?: Array<any>;
    /**
     * 
     * @type {any}
     * @memberof V1Environment
     */
    security_context?: any;
    /**
     * 
     * @type {string}
     * @memberof V1Environment
     */
    log_level?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1Environment
     */
    auth?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1Environment
     */
    docker?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1Environment
     */
    shm?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1Environment
     */
    outputs?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1Environment
     */
    logs?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1Environment
     */
    registry?: string;
    /**
     * 
     * @type {V1ContainerEnv}
     * @memberof V1Environment
     */
    init_container?: V1ContainerEnv;
    /**
     * 
     * @type {V1ContainerEnv}
     * @memberof V1Environment
     */
    sidecar_container?: V1ContainerEnv;
}

/**
 * 
 * @export
 * @interface V1ExactTimeSchedule
 */
export interface V1ExactTimeSchedule {
    /**
     * 
     * @type {string}
     * @memberof V1ExactTimeSchedule
     */
    kind?: string;
    /**
     * 
     * @type {Date}
     * @memberof V1ExactTimeSchedule
     */
    start_at?: Date;
}

/**
 * FailureEarlyStoppingSchema specification Early stopping based on failure config. this policy stops based on a percentage of failed runs at every evaluation.
 * @export
 * @interface V1FailureEarlyStopping
 */
export interface V1FailureEarlyStopping {
    /**
     * 
     * @type {string}
     * @memberof V1FailureEarlyStopping
     */
    kind?: string;
    /**
     * The percentage failed runs, at each evaluation interval. e.g. 1 - 99.
     * @type {number}
     * @memberof V1FailureEarlyStopping
     */
    percent?: number;
    /**
     * Interval/Frequency for applying the policy.
     * @type {string}
     * @memberof V1FailureEarlyStopping
     */
    evaluation_interval?: string;
}

/**
 * 
 * @export
 * @interface V1Flink
 */
export interface V1Flink {
    /**
     * 
     * @type {string}
     * @memberof V1Flink
     */
    kind?: string;
    /**
     * 
     * @type {any}
     * @memberof V1Flink
     */
    spec?: any;
}

/**
 * 
 * @export
 * @interface V1GridSearch
 */
export interface V1GridSearch {
    /**
     * 
     * @type {string}
     * @memberof V1GridSearch
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof V1GridSearch
     */
    matrix?: string;
    /**
     * 
     * @type {number}
     * @memberof V1GridSearch
     */
    n_runs?: number;
    /**
     * 
     * @type {number}
     * @memberof V1GridSearch
     */
    seed?: number;
    /**
     * 
     * @type {number}
     * @memberof V1GridSearch
     */
    concurrency?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1GridSearch
     */
    early_stopping?: Array<any>;
}

/**
 * 
 * @export
 * @interface V1HostConnection
 */
export interface V1HostConnection {
    /**
     * 
     * @type {string}
     * @memberof V1HostConnection
     */
    url?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1HostConnection
     */
    insecure?: boolean;
}

/**
 * 
 * @export
 * @interface V1HostPathConnection
 */
export interface V1HostPathConnection {
    /**
     * 
     * @type {string}
     * @memberof V1HostPathConnection
     */
    host_path?: string;
    /**
     * 
     * @type {string}
     * @memberof V1HostPathConnection
     */
    mount_path?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1HostPathConnection
     */
    read_only?: boolean;
}

/**
 * 
 * @export
 * @interface V1Hyperband
 */
export interface V1Hyperband {
    /**
     * 
     * @type {string}
     * @memberof V1Hyperband
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Hyperband
     */
    matrix?: string;
    /**
     * 
     * @type {number}
     * @memberof V1Hyperband
     */
    max_iter?: number;
    /**
     * 
     * @type {number}
     * @memberof V1Hyperband
     */
    eta?: number;
    /**
     * 
     * @type {V1OptimizationResource}
     * @memberof V1Hyperband
     */
    resource?: V1OptimizationResource;
    /**
     * 
     * @type {V1OptimizationMetric}
     * @memberof V1Hyperband
     */
    metric?: V1OptimizationMetric;
    /**
     * 
     * @type {boolean}
     * @memberof V1Hyperband
     */
    resume?: boolean;
    /**
     * 
     * @type {number}
     * @memberof V1Hyperband
     */
    seed?: number;
    /**
     * 
     * @type {number}
     * @memberof V1Hyperband
     */
    concurrency?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1Hyperband
     */
    early_stopping?: Array<any>;
}

/**
 * 
 * @export
 * @interface V1Hyperopt
 */
export interface V1Hyperopt {
    /**
     * 
     * @type {string}
     * @memberof V1Hyperopt
     */
    kind?: string;
    /**
     * 
     * @type {V1HyperoptAlgorithms}
     * @memberof V1Hyperopt
     */
    algorithm?: V1HyperoptAlgorithms;
    /**
     * 
     * @type {string}
     * @memberof V1Hyperopt
     */
    matrix?: string;
    /**
     * 
     * @type {number}
     * @memberof V1Hyperopt
     */
    n_runs?: number;
    /**
     * 
     * @type {number}
     * @memberof V1Hyperopt
     */
    seed?: number;
    /**
     * 
     * @type {number}
     * @memberof V1Hyperopt
     */
    concurrency?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1Hyperopt
     */
    early_stopping?: Array<any>;
}

/**
 * - tpe: tpe algorithm  - rand: random algorithm  - anneal: anneal algorithm
 * @export
 * @enum {string}
 */
export enum V1HyperoptAlgorithms {
    Tpe = <any> 'tpe',
    Rand = <any> 'rand',
    Anneal = <any> 'anneal'
}

/**
 * 
 * @export
 * @interface V1IO
 */
export interface V1IO {
    /**
     * 
     * @type {string}
     * @memberof V1IO
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1IO
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof V1IO
     */
    iotype?: string;
    /**
     * 
     * @type {any}
     * @memberof V1IO
     */
    value?: any;
    /**
     * 
     * @type {boolean}
     * @memberof V1IO
     */
    is_optional?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1IO
     */
    is_list?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1IO
     */
    is_flag?: boolean;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1IO
     */
    options?: Array<any>;
}

/**
 * 
 * @export
 * @interface V1Init
 */
export interface V1Init {
    /**
     * 
     * @type {Array<V1RepoInit>}
     * @memberof V1Init
     */
    repos?: Array<V1RepoInit>;
    /**
     * 
     * @type {Array<V1ArtifactMount>}
     * @memberof V1Init
     */
    artifacts?: Array<V1ArtifactMount>;
    /**
     * 
     * @type {V1BuildContext}
     * @memberof V1Init
     */
    build?: V1BuildContext;
}

/**
 * 
 * @export
 * @interface V1IntervalSchedule
 */
export interface V1IntervalSchedule {
    /**
     * 
     * @type {string}
     * @memberof V1IntervalSchedule
     */
    kind?: string;
    /**
     * 
     * @type {Date}
     * @memberof V1IntervalSchedule
     */
    start_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1IntervalSchedule
     */
    end_at?: Date;
    /**
     * 
     * @type {number}
     * @memberof V1IntervalSchedule
     */
    frequency?: number;
    /**
     * 
     * @type {boolean}
     * @memberof V1IntervalSchedule
     */
    depends_on_past?: boolean;
}

/**
 * 
 * @export
 * @interface V1Iterative
 */
export interface V1Iterative {
    /**
     * 
     * @type {string}
     * @memberof V1Iterative
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Iterative
     */
    matrix?: string;
    /**
     * 
     * @type {number}
     * @memberof V1Iterative
     */
    n_iterations?: number;
    /**
     * 
     * @type {V1Container}
     * @memberof V1Iterative
     */
    container?: V1Container;
    /**
     * 
     * @type {number}
     * @memberof V1Iterative
     */
    seed?: number;
    /**
     * 
     * @type {number}
     * @memberof V1Iterative
     */
    concurrency?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1Iterative
     */
    early_stopping?: Array<any>;
}

/**
 * 
 * @export
 * @interface V1K8sMount
 */
export interface V1K8sMount {
    /**
     * 
     * @type {string}
     * @memberof V1K8sMount
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1K8sMount
     */
    mount_path?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1K8sMount
     */
    items?: Array<string>;
}

/**
 * 
 * @export
 * @interface V1ListAgentsResponse
 */
export interface V1ListAgentsResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListAgentsResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1Agent>}
     * @memberof V1ListAgentsResponse
     */
    results?: Array<V1Agent>;
    /**
     * 
     * @type {string}
     * @memberof V1ListAgentsResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListAgentsResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListConfigResourcesResponse
 */
export interface V1ListConfigResourcesResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListConfigResourcesResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1ConfigResource>}
     * @memberof V1ListConfigResourcesResponse
     */
    results?: Array<V1ConfigResource>;
    /**
     * 
     * @type {string}
     * @memberof V1ListConfigResourcesResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListConfigResourcesResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListConnectionsResponse
 */
export interface V1ListConnectionsResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListConnectionsResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1Connection>}
     * @memberof V1ListConnectionsResponse
     */
    results?: Array<V1Connection>;
    /**
     * 
     * @type {string}
     * @memberof V1ListConnectionsResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListConnectionsResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListDashboardsResponse
 */
export interface V1ListDashboardsResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListDashboardsResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1Dashboard>}
     * @memberof V1ListDashboardsResponse
     */
    results?: Array<V1Dashboard>;
    /**
     * 
     * @type {string}
     * @memberof V1ListDashboardsResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListDashboardsResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListOrganizationMembersResponse
 */
export interface V1ListOrganizationMembersResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListOrganizationMembersResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1OrganizationMember>}
     * @memberof V1ListOrganizationMembersResponse
     */
    results?: Array<V1OrganizationMember>;
    /**
     * 
     * @type {string}
     * @memberof V1ListOrganizationMembersResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListOrganizationMembersResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListOrganizationsResponse
 */
export interface V1ListOrganizationsResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListOrganizationsResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1Organization>}
     * @memberof V1ListOrganizationsResponse
     */
    results?: Array<V1Organization>;
    /**
     * 
     * @type {string}
     * @memberof V1ListOrganizationsResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListOrganizationsResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListProjectsResponse
 */
export interface V1ListProjectsResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListProjectsResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1Project>}
     * @memberof V1ListProjectsResponse
     */
    results?: Array<V1Project>;
    /**
     * 
     * @type {string}
     * @memberof V1ListProjectsResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListProjectsResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListQueuesResponse
 */
export interface V1ListQueuesResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListQueuesResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1Queue>}
     * @memberof V1ListQueuesResponse
     */
    results?: Array<V1Queue>;
    /**
     * 
     * @type {string}
     * @memberof V1ListQueuesResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListQueuesResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListRunProfilesResponse
 */
export interface V1ListRunProfilesResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListRunProfilesResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1RunProfile>}
     * @memberof V1ListRunProfilesResponse
     */
    results?: Array<V1RunProfile>;
    /**
     * 
     * @type {string}
     * @memberof V1ListRunProfilesResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListRunProfilesResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListRunsResponse
 */
export interface V1ListRunsResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListRunsResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1Run>}
     * @memberof V1ListRunsResponse
     */
    results?: Array<V1Run>;
    /**
     * 
     * @type {string}
     * @memberof V1ListRunsResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListRunsResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListSearchesResponse
 */
export interface V1ListSearchesResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListSearchesResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1Search>}
     * @memberof V1ListSearchesResponse
     */
    results?: Array<V1Search>;
    /**
     * 
     * @type {string}
     * @memberof V1ListSearchesResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListSearchesResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListTeamMembersResponse
 */
export interface V1ListTeamMembersResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListTeamMembersResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1TeamMember>}
     * @memberof V1ListTeamMembersResponse
     */
    results?: Array<V1TeamMember>;
    /**
     * 
     * @type {string}
     * @memberof V1ListTeamMembersResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListTeamMembersResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListTeamsResponse
 */
export interface V1ListTeamsResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListTeamsResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1Team>}
     * @memberof V1ListTeamsResponse
     */
    results?: Array<V1Team>;
    /**
     * 
     * @type {string}
     * @memberof V1ListTeamsResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListTeamsResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1LogHandler
 */
export interface V1LogHandler {
    /**
     * 
     * @type {string}
     * @memberof V1LogHandler
     */
    dsn?: string;
    /**
     * 
     * @type {string}
     * @memberof V1LogHandler
     */
    environment?: string;
}

/**
 * 
 * @export
 * @interface V1Mapping
 */
export interface V1Mapping {
    /**
     * 
     * @type {string}
     * @memberof V1Mapping
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Mapping
     */
    values?: string;
    /**
     * 
     * @type {number}
     * @memberof V1Mapping
     */
    concurrency?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1Mapping
     */
    early_stopping?: Array<any>;
}

/**
 * Early stopping with median stopping, this policy computes running medians across all runs and stops those whose best performance is worse than the median of the running runs.
 * @export
 * @interface V1MedianStoppingPolicy
 */
export interface V1MedianStoppingPolicy {
    /**
     * 
     * @type {string}
     * @memberof V1MedianStoppingPolicy
     */
    kind?: string;
    /**
     * Interval/Frequency for applying the policy.
     * @type {number}
     * @memberof V1MedianStoppingPolicy
     */
    evaluation_interval?: number;
}

/**
 * MetricEarlyStoppingSchema specification Early stopping based on metric config.
 * @export
 * @interface V1MetricEarlyStopping
 */
export interface V1MetricEarlyStopping {
    /**
     * 
     * @type {string}
     * @memberof V1MetricEarlyStopping
     */
    kind?: string;
    /**
     * Metric name to use for early stopping.
     * @type {string}
     * @memberof V1MetricEarlyStopping
     */
    metric?: string;
    /**
     * Metric value to use for the condition.
     * @type {string}
     * @memberof V1MetricEarlyStopping
     */
    value?: string;
    /**
     * Optimization to do: maximize or minimize.
     * @type {V1Optimization}
     * @memberof V1MetricEarlyStopping
     */
    optimization?: V1Optimization;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1MetricEarlyStopping
     */
    policy?: Array<any>;
}

/**
 * 
 * @export
 * @interface V1Mounts
 */
export interface V1Mounts {
    /**
     * 
     * @type {Array<V1K8sMount>}
     * @memberof V1Mounts
     */
    secrets?: Array<V1K8sMount>;
    /**
     * 
     * @type {Array<V1K8sMount>}
     * @memberof V1Mounts
     */
    config_maps?: Array<V1K8sMount>;
    /**
     * 
     * @type {Array<V1ArtifactMount>}
     * @memberof V1Mounts
     */
    artifacts?: Array<V1ArtifactMount>;
}

/**
 * 
 * @export
 * @interface V1MpiJob
 */
export interface V1MpiJob {
    /**
     * 
     * @type {string}
     * @memberof V1MpiJob
     */
    kind?: string;
    /**
     * 
     * @type {number}
     * @memberof V1MpiJob
     */
    slots_per_worker?: number;
    /**
     * 
     * @type {V1Replica}
     * @memberof V1MpiJob
     */
    launcher?: V1Replica;
    /**
     * 
     * @type {V1Replica}
     * @memberof V1MpiJob
     */
    worker?: V1Replica;
}

/**
 * 
 * @export
 * @interface V1Op
 */
export interface V1Op {
    /**
     * 
     * @type {number}
     * @memberof V1Op
     */
    version?: number;
    /**
     * 
     * @type {string}
     * @memberof V1Op
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Op
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Op
     */
    tag?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Op
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Op
     */
    tags?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof V1Op
     */
    profile?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Op
     */
    queue?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1Op
     */
    nocache?: boolean;
    /**
     * 
     * @type {V1Environment}
     * @memberof V1Op
     */
    environment?: V1Environment;
    /**
     * 
     * @type {V1Termination}
     * @memberof V1Op
     */
    termination?: V1Termination;
    /**
     * 
     * @type {V1Init}
     * @memberof V1Op
     */
    init?: V1Init;
    /**
     * 
     * @type {V1Mounts}
     * @memberof V1Op
     */
    mounts?: V1Mounts;
    /**
     * 
     * @type {any}
     * @memberof V1Op
     */
    schedule?: any;
    /**
     * 
     * @type {any}
     * @memberof V1Op
     */
    parallel?: any;
    /**
     * 
     * @type {V1Service}
     * @memberof V1Op
     */
    service?: V1Service;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Op
     */
    dependencies?: Array<string>;
    /**
     * 
     * @type {V1TriggerPolicy}
     * @memberof V1Op
     */
    trigger?: V1TriggerPolicy;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1Op
     */
    conditions?: Array<any>;
    /**
     * 
     * @type {boolean}
     * @memberof V1Op
     */
    skip_on_upstream_skip?: boolean;
    /**
     * 
     * @type {any}
     * @memberof V1Op
     */
    params?: any;
    /**
     * 
     * @type {V1ComponentRef}
     * @memberof V1Op
     */
    component_ref?: V1ComponentRef;
    /**
     * 
     * @type {V1Component}
     * @memberof V1Op
     */
    component?: V1Component;
}

/**
 * 
 * @export
 * @interface V1OpCondition
 */
export interface V1OpCondition {
    /**
     * 
     * @type {V1OpIOCondition}
     * @memberof V1OpCondition
     */
    op_io_conidtion?: V1OpIOCondition;
    /**
     * 
     * @type {V1OpStatusCondition}
     * @memberof V1OpCondition
     */
    op_status_condition?: V1OpStatusCondition;
}

/**
 * 
 * @export
 * @interface V1OpIOCondition
 */
export interface V1OpIOCondition {
    /**
     * 
     * @type {string}
     * @memberof V1OpIOCondition
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof V1OpIOCondition
     */
    param?: string;
    /**
     * 
     * @type {string}
     * @memberof V1OpIOCondition
     */
    trigger?: string;
}

/**
 * 
 * @export
 * @interface V1OpStatusCondition
 */
export interface V1OpStatusCondition {
    /**
     * 
     * @type {string}
     * @memberof V1OpStatusCondition
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof V1OpStatusCondition
     */
    op?: string;
    /**
     * 
     * @type {string}
     * @memberof V1OpStatusCondition
     */
    trigger?: string;
}

/**
 * - maximize: Minimize a metric  - minimize: Minimize a metric
 * @export
 * @enum {string}
 */
export enum V1Optimization {
    Maximize = <any> 'maximize',
    Minimize = <any> 'minimize'
}

/**
 * 
 * @export
 * @interface V1OptimizationMetric
 */
export interface V1OptimizationMetric {
    /**
     * 
     * @type {string}
     * @memberof V1OptimizationMetric
     */
    name?: string;
    /**
     * 
     * @type {V1Optimization}
     * @memberof V1OptimizationMetric
     */
    optimization?: V1Optimization;
}

/**
 * 
 * @export
 * @interface V1OptimizationResource
 */
export interface V1OptimizationResource {
    /**
     * 
     * @type {string}
     * @memberof V1OptimizationResource
     */
    name?: string;
    /**
     * 
     * @type {V1ResourceType}
     * @memberof V1OptimizationResource
     */
    type?: V1ResourceType;
}

/**
 * 
 * @export
 * @interface V1Organization
 */
export interface V1Organization {
    /**
     * 
     * @type {string}
     * @memberof V1Organization
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Organization
     */
    user_email?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Organization
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Organization
     */
    is_public?: string;
    /**
     * 
     * @type {Date}
     * @memberof V1Organization
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Organization
     */
    updated_at?: Date;
}

/**
 * 
 * @export
 * @interface V1OrganizationMember
 */
export interface V1OrganizationMember {
    /**
     * 
     * @type {string}
     * @memberof V1OrganizationMember
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof V1OrganizationMember
     */
    user_email?: string;
    /**
     * 
     * @type {string}
     * @memberof V1OrganizationMember
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof V1OrganizationMember
     */
    role?: string;
    /**
     * 
     * @type {Date}
     * @memberof V1OrganizationMember
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1OrganizationMember
     */
    updated_at?: Date;
}

/**
 * 
 * @export
 * @interface V1Parallel
 */
export interface V1Parallel {
    /**
     * 
     * @type {V1RandomSearch}
     * @memberof V1Parallel
     */
    random?: V1RandomSearch;
    /**
     * 
     * @type {V1GridSearch}
     * @memberof V1Parallel
     */
    grid?: V1GridSearch;
    /**
     * 
     * @type {V1Hyperband}
     * @memberof V1Parallel
     */
    hyperband?: V1Hyperband;
    /**
     * 
     * @type {V1BO}
     * @memberof V1Parallel
     */
    bo?: V1BO;
    /**
     * 
     * @type {V1Hyperopt}
     * @memberof V1Parallel
     */
    hyperopt?: V1Hyperopt;
    /**
     * 
     * @type {V1Iterative}
     * @memberof V1Parallel
     */
    iterative?: V1Iterative;
    /**
     * 
     * @type {V1Mapping}
     * @memberof V1Parallel
     */
    mapping?: V1Mapping;
}

/**
 * 
 * @export
 * @interface V1Project
 */
export interface V1Project {
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    user_email?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Project
     */
    tags?: Array<string>;
    /**
     * 
     * @type {Date}
     * @memberof V1Project
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Project
     */
    updated_at?: Date;
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    is_public?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1Project
     */
    deleted?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1Project
     */
    bookmarked?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    readme?: string;
}

/**
 * 
 * @export
 * @interface V1ProjectEntityResourceRequest
 */
export interface V1ProjectEntityResourceRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ProjectEntityResourceRequest
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ProjectEntityResourceRequest
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ProjectEntityResourceRequest
     */
    uuid?: string;
}

/**
 * 
 * @export
 * @interface V1ProjectSettings
 */
export interface V1ProjectSettings {
    /**
     * 
     * @type {string}
     * @memberof V1ProjectSettings
     */
    logs_store?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ProjectSettings
     */
    outputs_store?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1ProjectSettings
     */
    connections?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1ProjectSettings
     */
    git_accesses?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1ProjectSettings
     */
    registry_accesses?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1ProjectSettings
     */
    config_resouces?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof V1ProjectSettings
     */
    run_profile?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1ProjectSettings
     */
    run_profiles?: Array<string>;
}

/**
 * 
 * @export
 * @interface V1ProjectTeams
 */
export interface V1ProjectTeams {
    /**
     * 
     * @type {Array<string>}
     * @memberof V1ProjectTeams
     */
    teams?: Array<string>;
}

/**
 * 
 * @export
 * @interface V1PytorchJob
 */
export interface V1PytorchJob {
    /**
     * 
     * @type {string}
     * @memberof V1PytorchJob
     */
    kind?: string;
    /**
     * 
     * @type {V1Replica}
     * @memberof V1PytorchJob
     */
    master?: V1Replica;
    /**
     * 
     * @type {V1Replica}
     * @memberof V1PytorchJob
     */
    worker?: V1Replica;
}

/**
 * 
 * @export
 * @interface V1Queue
 */
export interface V1Queue {
    /**
     * 
     * @type {string}
     * @memberof V1Queue
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Queue
     */
    agent?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Queue
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof V1Queue
     */
    priority?: number;
    /**
     * 
     * @type {number}
     * @memberof V1Queue
     */
    concurrency?: number;
    /**
     * 
     * @type {Date}
     * @memberof V1Queue
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Queue
     */
    updated_at?: Date;
}

/**
 * 
 * @export
 * @interface V1RandomSearch
 */
export interface V1RandomSearch {
    /**
     * 
     * @type {string}
     * @memberof V1RandomSearch
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof V1RandomSearch
     */
    matrix?: string;
    /**
     * 
     * @type {number}
     * @memberof V1RandomSearch
     */
    n_runs?: number;
    /**
     * 
     * @type {number}
     * @memberof V1RandomSearch
     */
    seed?: number;
    /**
     * 
     * @type {number}
     * @memberof V1RandomSearch
     */
    concurrency?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1RandomSearch
     */
    early_stopping?: Array<any>;
}

/**
 * 
 * @export
 * @interface V1RepeatableSchedule
 */
export interface V1RepeatableSchedule {
    /**
     * 
     * @type {string}
     * @memberof V1RepeatableSchedule
     */
    kind?: string;
    /**
     * 
     * @type {number}
     * @memberof V1RepeatableSchedule
     */
    limit?: number;
    /**
     * 
     * @type {boolean}
     * @memberof V1RepeatableSchedule
     */
    depends_on_past?: boolean;
}

/**
 * 
 * @export
 * @interface V1Replica
 */
export interface V1Replica {
    /**
     * 
     * @type {number}
     * @memberof V1Replica
     */
    replicas?: number;
    /**
     * 
     * @type {V1Environment}
     * @memberof V1Replica
     */
    environment?: V1Environment;
    /**
     * 
     * @type {V1Termination}
     * @memberof V1Replica
     */
    termination?: V1Termination;
    /**
     * 
     * @type {V1Init}
     * @memberof V1Replica
     */
    init?: V1Init;
    /**
     * 
     * @type {V1Mounts}
     * @memberof V1Replica
     */
    mounts?: V1Mounts;
    /**
     * 
     * @type {V1Container}
     * @memberof V1Replica
     */
    container?: V1Container;
}

/**
 * 
 * @export
 * @interface V1RepoInit
 */
export interface V1RepoInit {
    /**
     * 
     * @type {string}
     * @memberof V1RepoInit
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1RepoInit
     */
    commit?: string;
    /**
     * 
     * @type {string}
     * @memberof V1RepoInit
     */
    branch?: string;
}

/**
 * 
 * @export
 * @interface V1ResourceRequirements
 */
export interface V1ResourceRequirements {
    /**
     * Limits describes the maximum amount of compute resources allowed.
     * @type {any}
     * @memberof V1ResourceRequirements
     */
    limits?: any;
    /**
     * Requests describes the minimum amount of compute resources required.
     * @type {any}
     * @memberof V1ResourceRequirements
     */
    requests?: any;
}

/**
 * - int: Int resource  - float: Float resource
 * @export
 * @enum {string}
 */
export enum V1ResourceType {
    Int = <any> 'int',
    Float = <any> 'float'
}

/**
 * 
 * @export
 * @interface V1Run
 */
export interface V1Run {
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Run
     */
    tags?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof V1Run
     */
    deleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    project?: string;
    /**
     * 
     * @type {Date}
     * @memberof V1Run
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Run
     */
    updated_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Run
     */
    started_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Run
     */
    finished_at?: Date;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    is_managed?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    readme?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1Run
     */
    bookmarked?: boolean;
    /**
     * 
     * @type {V1RunMetaInfo}
     * @memberof V1Run
     */
    meta_info?: V1RunMetaInfo;
    /**
     * 
     * @type {V1RunKind}
     * @memberof V1Run
     */
    kind?: V1RunKind;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    hub?: string;
    /**
     * 
     * @type {any}
     * @memberof V1Run
     */
    inputs?: any;
    /**
     * 
     * @type {any}
     * @memberof V1Run
     */
    outputs?: any;
    /**
     * 
     * @type {any}
     * @memberof V1Run
     */
    run_env?: any;
    /**
     * 
     * @type {boolean}
     * @memberof V1Run
     */
    is_resume?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1Run
     */
    is_clone?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    cloning_strategy?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    pipeline?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    original?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    pipeline_name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    original_name?: string;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum V1RunKind {
    Job = <any> 'job',
    Service = <any> 'service',
    Dag = <any> 'dag',
    Parallel = <any> 'parallel'
}

/**
 * 
 * @export
 * @interface V1RunMetaInfo
 */
export interface V1RunMetaInfo {
    /**
     * 
     * @type {boolean}
     * @memberof V1RunMetaInfo
     */
    service?: boolean;
    /**
     * 
     * @type {number}
     * @memberof V1RunMetaInfo
     */
    concurrency?: number;
    /**
     * 
     * @type {string}
     * @memberof V1RunMetaInfo
     */
    parallel_kind?: string;
    /**
     * 
     * @type {string}
     * @memberof V1RunMetaInfo
     */
    run_kind?: string;
}

/**
 * 
 * @export
 * @interface V1RunProfile
 */
export interface V1RunProfile {
    /**
     * 
     * @type {string}
     * @memberof V1RunProfile
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1RunProfile
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1RunProfile
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1RunProfile
     */
    tags?: Array<string>;
    /**
     * 
     * @type {Date}
     * @memberof V1RunProfile
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1RunProfile
     */
    updated_at?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof V1RunProfile
     */
    frozen?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1RunProfile
     */
    disabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1RunProfile
     */
    queue?: string;
    /**
     * 
     * @type {string}
     * @memberof V1RunProfile
     */
    namespace?: string;
    /**
     * 
     * @type {any}
     * @memberof V1RunProfile
     */
    termination?: any;
    /**
     * 
     * @type {any}
     * @memberof V1RunProfile
     */
    environment?: any;
}

/**
 * 
 * @export
 * @interface V1RunSchema
 */
export interface V1RunSchema {
    /**
     * 
     * @type {V1Container}
     * @memberof V1RunSchema
     */
    container?: V1Container;
    /**
     * 
     * @type {V1Dag}
     * @memberof V1RunSchema
     */
    dag?: V1Dag;
    /**
     * 
     * @type {V1TFJob}
     * @memberof V1RunSchema
     */
    tf_job?: V1TFJob;
    /**
     * 
     * @type {V1PytorchJob}
     * @memberof V1RunSchema
     */
    pytorch_job?: V1PytorchJob;
    /**
     * 
     * @type {V1MpiJob}
     * @memberof V1RunSchema
     */
    mpi_job?: V1MpiJob;
    /**
     * 
     * @type {V1Dask}
     * @memberof V1RunSchema
     */
    dask?: V1Dask;
    /**
     * 
     * @type {V1Spark}
     * @memberof V1RunSchema
     */
    spark?: V1Spark;
    /**
     * 
     * @type {V1Flink}
     * @memberof V1RunSchema
     */
    flink?: V1Flink;
}

/**
 * 
 * @export
 * @interface V1RunSettings
 */
export interface V1RunSettings {
    /**
     * 
     * @type {string}
     * @memberof V1RunSettings
     */
    namespace?: string;
    /**
     * 
     * @type {V1RunSettingsCatalog}
     * @memberof V1RunSettings
     */
    agent?: V1RunSettingsCatalog;
    /**
     * 
     * @type {V1RunSettingsCatalog}
     * @memberof V1RunSettings
     */
    queue?: V1RunSettingsCatalog;
    /**
     * 
     * @type {V1RunSettingsCatalog}
     * @memberof V1RunSettings
     */
    logs_store?: V1RunSettingsCatalog;
    /**
     * 
     * @type {V1RunSettingsCatalog}
     * @memberof V1RunSettings
     */
    outputs_store?: V1RunSettingsCatalog;
    /**
     * 
     * @type {Array<V1RunSettingsCatalog>}
     * @memberof V1RunSettings
     */
    init_connections?: Array<V1RunSettingsCatalog>;
    /**
     * 
     * @type {Array<V1RunSettingsCatalog>}
     * @memberof V1RunSettings
     */
    connections?: Array<V1RunSettingsCatalog>;
    /**
     * 
     * @type {Array<V1RunSettingsCatalog>}
     * @memberof V1RunSettings
     */
    git_accesses?: Array<V1RunSettingsCatalog>;
    /**
     * 
     * @type {V1RunSettingsCatalog}
     * @memberof V1RunSettings
     */
    registry_access?: V1RunSettingsCatalog;
    /**
     * 
     * @type {Array<V1RunSettingsCatalog>}
     * @memberof V1RunSettings
     */
    config_resources?: Array<V1RunSettingsCatalog>;
}

/**
 * 
 * @export
 * @interface V1RunSettingsCatalog
 */
export interface V1RunSettingsCatalog {
    /**
     * 
     * @type {string}
     * @memberof V1RunSettingsCatalog
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1RunSettingsCatalog
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface V1Schedule
 */
export interface V1Schedule {
    /**
     * 
     * @type {V1CronSchedule}
     * @memberof V1Schedule
     */
    cron?: V1CronSchedule;
    /**
     * 
     * @type {V1ExactTimeSchedule}
     * @memberof V1Schedule
     */
    exact_time?: V1ExactTimeSchedule;
    /**
     * 
     * @type {V1IntervalSchedule}
     * @memberof V1Schedule
     */
    interval?: V1IntervalSchedule;
    /**
     * 
     * @type {V1RepeatableSchedule}
     * @memberof V1Schedule
     */
    repeatable?: V1RepeatableSchedule;
}

/**
 * 
 * @export
 * @interface V1Schemas
 */
export interface V1Schemas {
    /**
     * 
     * @type {V1OpCondition}
     * @memberof V1Schemas
     */
    op_condition?: V1OpCondition;
    /**
     * 
     * @type {V1EarlyStopping}
     * @memberof V1Schemas
     */
    early_stopping?: V1EarlyStopping;
    /**
     * 
     * @type {V1Parallel}
     * @memberof V1Schemas
     */
    parallel?: V1Parallel;
    /**
     * 
     * @type {V1Op}
     * @memberof V1Schemas
     */
    op?: V1Op;
    /**
     * 
     * @type {V1RunSchema}
     * @memberof V1Schemas
     */
    run?: V1RunSchema;
    /**
     * 
     * @type {V1Schedule}
     * @memberof V1Schemas
     */
    schedule?: V1Schedule;
    /**
     * 
     * @type {V1ArtifactFormat}
     * @memberof V1Schemas
     */
    artifact_format?: V1ArtifactFormat;
    /**
     * 
     * @type {V1ConnectionScema}
     * @memberof V1Schemas
     */
    connection_schema?: V1ConnectionScema;
}

/**
 * 
 * @export
 * @interface V1Search
 */
export interface V1Search {
    /**
     * 
     * @type {string}
     * @memberof V1Search
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Search
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Search
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Search
     */
    tags?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof V1Search
     */
    disabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1Search
     */
    deleted?: boolean;
    /**
     * 
     * @type {V1SearchSpec}
     * @memberof V1Search
     */
    spec?: V1SearchSpec;
    /**
     * 
     * @type {Date}
     * @memberof V1Search
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Search
     */
    updated_at?: Date;
}

/**
 * 
 * @export
 * @interface V1SearchSpec
 */
export interface V1SearchSpec {
    /**
     * 
     * @type {string}
     * @memberof V1SearchSpec
     */
    query?: string;
    /**
     * 
     * @type {string}
     * @memberof V1SearchSpec
     */
    sort?: string;
    /**
     * 
     * @type {number}
     * @memberof V1SearchSpec
     */
    limit?: number;
    /**
     * 
     * @type {string}
     * @memberof V1SearchSpec
     */
    groupby?: string;
    /**
     * 
     * @type {string}
     * @memberof V1SearchSpec
     */
    columns?: string;
}

/**
 * 
 * @export
 * @interface V1Service
 */
export interface V1Service {
    /**
     * 
     * @type {boolean}
     * @memberof V1Service
     */
    enabled?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof V1Service
     */
    ports?: Array<number>;
}

/**
 * 
 * @export
 * @interface V1Spark
 */
export interface V1Spark {
    /**
     * 
     * @type {string}
     * @memberof V1Spark
     */
    kind?: string;
    /**
     * 
     * @type {any}
     * @memberof V1Spark
     */
    spec?: any;
}

/**
 * 
 * @export
 * @interface V1Status
 */
export interface V1Status {
    /**
     * 
     * @type {string}
     * @memberof V1Status
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Status
     */
    status?: string;
    /**
     * 
     * @type {Array<V1StatusCondition>}
     * @memberof V1Status
     */
    status_conditions?: Array<V1StatusCondition>;
}

/**
 * 
 * @export
 * @interface V1StatusCondition
 */
export interface V1StatusCondition {
    /**
     * 
     * @type {string}
     * @memberof V1StatusCondition
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof V1StatusCondition
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof V1StatusCondition
     */
    reason?: string;
    /**
     * 
     * @type {string}
     * @memberof V1StatusCondition
     */
    message?: string;
    /**
     * 
     * @type {Date}
     * @memberof V1StatusCondition
     */
    last_update_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1StatusCondition
     */
    last_transition_time?: Date;
}

/**
 * 
 * @export
 * @interface V1TFJob
 */
export interface V1TFJob {
    /**
     * 
     * @type {string}
     * @memberof V1TFJob
     */
    kind?: string;
    /**
     * 
     * @type {V1Replica}
     * @memberof V1TFJob
     */
    chief?: V1Replica;
    /**
     * 
     * @type {V1Replica}
     * @memberof V1TFJob
     */
    ps?: V1Replica;
    /**
     * 
     * @type {V1Replica}
     * @memberof V1TFJob
     */
    worker?: V1Replica;
    /**
     * 
     * @type {V1Replica}
     * @memberof V1TFJob
     */
    evaluator?: V1Replica;
}

/**
 * 
 * @export
 * @interface V1Team
 */
export interface V1Team {
    /**
     * 
     * @type {string}
     * @memberof V1Team
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Team
     */
    name?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Team
     */
    projects?: Array<string>;
    /**
     * 
     * @type {Date}
     * @memberof V1Team
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Team
     */
    updated_at?: Date;
}

/**
 * 
 * @export
 * @interface V1TeamMember
 */
export interface V1TeamMember {
    /**
     * 
     * @type {string}
     * @memberof V1TeamMember
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof V1TeamMember
     */
    user_email?: string;
    /**
     * 
     * @type {string}
     * @memberof V1TeamMember
     */
    role?: string;
    /**
     * 
     * @type {string}
     * @memberof V1TeamMember
     */
    org_role?: string;
    /**
     * 
     * @type {Date}
     * @memberof V1TeamMember
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1TeamMember
     */
    updated_at?: Date;
}

/**
 * Termination specification Termination defines how to handle failures, job runtime, and cleanup policy.
 * @export
 * @interface V1Termination
 */
export interface V1Termination {
    /**
     * 
     * @type {number}
     * @memberof V1Termination
     */
    max_retries?: number;
    /**
     * 
     * @type {string}
     * @memberof V1Termination
     */
    restart_policy?: string;
    /**
     * 
     * @type {number}
     * @memberof V1Termination
     */
    ttl?: number;
    /**
     * 
     * @type {number}
     * @memberof V1Termination
     */
    timeout?: number;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum V1TriggerPolicy {
    AllSucceeded = <any> 'all_succeeded',
    AllFailed = <any> 'all_failed',
    AllDone = <any> 'all_done',
    OneSucceeded = <any> 'one_succeeded',
    OneFailed = <any> 'one_failed',
    OneDone = <any> 'one_done'
}

/**
 * Early stopping with truncation stopping, this policy stops a percentage of all running runs at every evaluation.
 * @export
 * @interface V1TruncationStoppingPolicy
 */
export interface V1TruncationStoppingPolicy {
    /**
     * 
     * @type {string}
     * @memberof V1TruncationStoppingPolicy
     */
    kind?: string;
    /**
     * The percentage of runs to stop, at each evaluation interval. e.g. 1 - 99.
     * @type {number}
     * @memberof V1TruncationStoppingPolicy
     */
    percent?: number;
    /**
     * Interval/Frequency for applying the policy.
     * @type {number}
     * @memberof V1TruncationStoppingPolicy
     */
    evaluation_interval?: number;
}

/**
 * 
 * @export
 * @interface V1User
 */
export interface V1User {
    /**
     * 
     * @type {string}
     * @memberof V1User
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof V1User
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof V1User
     */
    role?: string;
}

/**
 * 
 * @export
 * @interface V1Uuids
 */
export interface V1Uuids {
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Uuids
     */
    uuids?: Array<string>;
}

/**
 * 
 * @export
 * @interface V1Version
 */
export interface V1Version {
    /**
     * 
     * @type {string}
     * @memberof V1Version
     */
    min_version?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Version
     */
    latest_version?: string;
}

/**
 * 
 * @export
 * @interface V1Versions
 */
export interface V1Versions {
    /**
     * 
     * @type {string}
     * @memberof V1Versions
     */
    platform_version?: string;
    /**
     * 
     * @type {V1Version}
     * @memberof V1Versions
     */
    cli?: V1Version;
    /**
     * 
     * @type {V1Version}
     * @memberof V1Versions
     */
    platform?: V1Version;
    /**
     * 
     * @type {V1Version}
     * @memberof V1Versions
     */
    agent?: V1Version;
}

/**
 * 
 * @export
 * @interface V1WidgetSpec
 */
export interface V1WidgetSpec {
    /**
     * 
     * @type {string}
     * @memberof V1WidgetSpec
     */
    kind?: string;
    /**
     * 
     * @type {V1SearchSpec}
     * @memberof V1WidgetSpec
     */
    search?: V1SearchSpec;
    /**
     * 
     * @type {any}
     * @memberof V1WidgetSpec
     */
    meta?: any;
}


/**
 * AgentsV1Api - fetch parameter creator
 * @export
 */
export const AgentsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1Agent} body Agent body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAgent(owner: string, body: V1Agent, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createAgent.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createAgent.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Agent" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAgent(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteAgent.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteAgent.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgent(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getAgent.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getAgent.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listAgentNames.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgents(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listAgents.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} agent_uuid UUID
         * @param {V1Agent} body Agent body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAgent(owner: string, agent_uuid: string, body: V1Agent, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchAgent.');
            }
            // verify required parameter 'agent_uuid' is not null or undefined
            if (agent_uuid === null || agent_uuid === undefined) {
                throw new RequiredError('agent_uuid','Required parameter agent_uuid was null or undefined when calling patchAgent.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchAgent.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{agent.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"agent.uuid"}}`, encodeURIComponent(String(agent_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Agent" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} agent_uuid UUID
         * @param {V1Agent} body Agent body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAgent(owner: string, agent_uuid: string, body: V1Agent, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateAgent.');
            }
            // verify required parameter 'agent_uuid' is not null or undefined
            if (agent_uuid === null || agent_uuid === undefined) {
                throw new RequiredError('agent_uuid','Required parameter agent_uuid was null or undefined when calling updateAgent.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateAgent.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{agent.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"agent.uuid"}}`, encodeURIComponent(String(agent_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Agent" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AgentsV1Api - functional programming interface
 * @export
 */
export const AgentsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1Agent} body Agent body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAgent(owner: string, body: V1Agent, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Agent> {
            const localVarFetchArgs = AgentsV1ApiFetchParamCreator(configuration).createAgent(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAgent(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AgentsV1ApiFetchParamCreator(configuration).deleteAgent(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgent(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Agent> {
            const localVarFetchArgs = AgentsV1ApiFetchParamCreator(configuration).getAgent(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListAgentsResponse> {
            const localVarFetchArgs = AgentsV1ApiFetchParamCreator(configuration).listAgentNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgents(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListAgentsResponse> {
            const localVarFetchArgs = AgentsV1ApiFetchParamCreator(configuration).listAgents(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} agent_uuid UUID
         * @param {V1Agent} body Agent body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAgent(owner: string, agent_uuid: string, body: V1Agent, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Agent> {
            const localVarFetchArgs = AgentsV1ApiFetchParamCreator(configuration).patchAgent(owner, agent_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} agent_uuid UUID
         * @param {V1Agent} body Agent body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAgent(owner: string, agent_uuid: string, body: V1Agent, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Agent> {
            const localVarFetchArgs = AgentsV1ApiFetchParamCreator(configuration).updateAgent(owner, agent_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AgentsV1Api - factory interface
 * @export
 */
export const AgentsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1Agent} body Agent body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAgent(owner: string, body: V1Agent, options?: any) {
            return AgentsV1ApiFp(configuration).createAgent(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAgent(owner: string, uuid: string, options?: any) {
            return AgentsV1ApiFp(configuration).deleteAgent(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgent(owner: string, uuid: string, options?: any) {
            return AgentsV1ApiFp(configuration).getAgent(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return AgentsV1ApiFp(configuration).listAgentNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgents(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return AgentsV1ApiFp(configuration).listAgents(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} agent_uuid UUID
         * @param {V1Agent} body Agent body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAgent(owner: string, agent_uuid: string, body: V1Agent, options?: any) {
            return AgentsV1ApiFp(configuration).patchAgent(owner, agent_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} agent_uuid UUID
         * @param {V1Agent} body Agent body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAgent(owner: string, agent_uuid: string, body: V1Agent, options?: any) {
            return AgentsV1ApiFp(configuration).updateAgent(owner, agent_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * AgentsV1Api - object-oriented interface
 * @export
 * @class AgentsV1Api
 * @extends {BaseAPI}
 */
export class AgentsV1Api extends BaseAPI {
    /**
     * 
     * @summary List runs
     * @param {string} owner Owner of the namespace
     * @param {V1Agent} body Agent body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsV1Api
     */
    public createAgent(owner: string, body: V1Agent, options?: any) {
        return AgentsV1ApiFp(this.configuration).createAgent(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch run
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsV1Api
     */
    public deleteAgent(owner: string, uuid: string, options?: any) {
        return AgentsV1ApiFp(this.configuration).deleteAgent(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsV1Api
     */
    public getAgent(owner: string, uuid: string, options?: any) {
        return AgentsV1ApiFp(this.configuration).getAgent(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsV1Api
     */
    public listAgentNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return AgentsV1ApiFp(this.configuration).listAgentNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List archived runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsV1Api
     */
    public listAgents(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return AgentsV1ApiFp(this.configuration).listAgents(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update run
     * @param {string} owner Owner of the namespace
     * @param {string} agent_uuid UUID
     * @param {V1Agent} body Agent body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsV1Api
     */
    public patchAgent(owner: string, agent_uuid: string, body: V1Agent, options?: any) {
        return AgentsV1ApiFp(this.configuration).patchAgent(owner, agent_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run
     * @param {string} owner Owner of the namespace
     * @param {string} agent_uuid UUID
     * @param {V1Agent} body Agent body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsV1Api
     */
    public updateAgent(owner: string, agent_uuid: string, body: V1Agent, options?: any) {
        return AgentsV1ApiFp(this.configuration).updateAgent(owner, agent_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * ArtifactsStoresV1Api - fetch parameter creator
 * @export
 */
export const ArtifactsStoresV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Upload artifact to a store
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadArtifact(owner: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling uploadArtifact.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling uploadArtifact.');
            }
            // verify required parameter 'uploadfile' is not null or undefined
            if (uploadfile === null || uploadfile === undefined) {
                throw new RequiredError('uploadfile','Required parameter uploadfile was null or undefined when calling uploadArtifact.');
            }
            const localVarPath = `/api/v1/catalogs/{owner}/artifacts/{uuid}/upload`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (overwrite !== undefined) {
                localVarQueryParameter['overwrite'] = overwrite;
            }

            if (uploadfile !== undefined) {
                localVarFormParams.set('uploadfile', uploadfile as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtifactsStoresV1Api - functional programming interface
 * @export
 */
export const ArtifactsStoresV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Upload artifact to a store
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadArtifact(owner: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ArtifactsStoresV1ApiFetchParamCreator(configuration).uploadArtifact(owner, uuid, uploadfile, path, overwrite, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ArtifactsStoresV1Api - factory interface
 * @export
 */
export const ArtifactsStoresV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Upload artifact to a store
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadArtifact(owner: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any) {
            return ArtifactsStoresV1ApiFp(configuration).uploadArtifact(owner, uuid, uploadfile, path, overwrite, options)(fetch, basePath);
        },
    };
};

/**
 * ArtifactsStoresV1Api - object-oriented interface
 * @export
 * @class ArtifactsStoresV1Api
 * @extends {BaseAPI}
 */
export class ArtifactsStoresV1Api extends BaseAPI {
    /**
     * 
     * @summary Upload artifact to a store
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Unique integer identifier of the entity
     * @param {any} uploadfile The file to upload.
     * @param {string} [path] File path query params.
     * @param {boolean} [overwrite] File path query params.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsStoresV1Api
     */
    public uploadArtifact(owner: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any) {
        return ArtifactsStoresV1ApiFp(this.configuration).uploadArtifact(owner, uuid, uploadfile, path, overwrite, options)(this.fetch, this.basePath);
    }

}

/**
 * AuthV1Api - fetch parameter creator
 * @export
 */
export const AuthV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {V1CredsBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body: V1CredsBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling login.');
            }
            const localVarPath = `/api/v1/users/token`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1CredsBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthV1Api - functional programming interface
 * @export
 */
export const AuthV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {V1CredsBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body: V1CredsBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Auth> {
            const localVarFetchArgs = AuthV1ApiFetchParamCreator(configuration).login(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuthV1Api - factory interface
 * @export
 */
export const AuthV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {V1CredsBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body: V1CredsBodyRequest, options?: any) {
            return AuthV1ApiFp(configuration).login(body, options)(fetch, basePath);
        },
    };
};

/**
 * AuthV1Api - object-oriented interface
 * @export
 * @class AuthV1Api
 * @extends {BaseAPI}
 */
export class AuthV1Api extends BaseAPI {
    /**
     * 
     * @summary List bookmarked runs for user
     * @param {V1CredsBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthV1Api
     */
    public login(body: V1CredsBodyRequest, options?: any) {
        return AuthV1ApiFp(this.configuration).login(body, options)(this.fetch, this.basePath);
    }

}

/**
 * ConfigResourcesV1Api - fetch parameter creator
 * @export
 */
export const ConfigResourcesV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1ConfigResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConfigResource(owner: string, body: V1ConfigResource, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createConfigResource.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createConfigResource.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/config_resources`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ConfigResource" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConfigResource(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteConfigResource.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteConfigResource.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/config_resources/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigResource(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getConfigResource.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getConfigResource.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/config_resources/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConfigResourceNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listConfigResourceNames.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/config_resources/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConfigResources(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listConfigResources.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/config_resources`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} config_resource_uuid UUID
         * @param {V1ConfigResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchConfigResource(owner: string, config_resource_uuid: string, body: V1ConfigResource, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchConfigResource.');
            }
            // verify required parameter 'config_resource_uuid' is not null or undefined
            if (config_resource_uuid === null || config_resource_uuid === undefined) {
                throw new RequiredError('config_resource_uuid','Required parameter config_resource_uuid was null or undefined when calling patchConfigResource.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchConfigResource.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/config_resources/{config_resource.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"config_resource.uuid"}}`, encodeURIComponent(String(config_resource_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ConfigResource" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} config_resource_uuid UUID
         * @param {V1ConfigResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfigResource(owner: string, config_resource_uuid: string, body: V1ConfigResource, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateConfigResource.');
            }
            // verify required parameter 'config_resource_uuid' is not null or undefined
            if (config_resource_uuid === null || config_resource_uuid === undefined) {
                throw new RequiredError('config_resource_uuid','Required parameter config_resource_uuid was null or undefined when calling updateConfigResource.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateConfigResource.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/config_resources/{config_resource.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"config_resource.uuid"}}`, encodeURIComponent(String(config_resource_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ConfigResource" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigResourcesV1Api - functional programming interface
 * @export
 */
export const ConfigResourcesV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1ConfigResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConfigResource(owner: string, body: V1ConfigResource, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ConfigResource> {
            const localVarFetchArgs = ConfigResourcesV1ApiFetchParamCreator(configuration).createConfigResource(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConfigResource(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ConfigResourcesV1ApiFetchParamCreator(configuration).deleteConfigResource(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigResource(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ConfigResource> {
            const localVarFetchArgs = ConfigResourcesV1ApiFetchParamCreator(configuration).getConfigResource(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConfigResourceNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListConfigResourcesResponse> {
            const localVarFetchArgs = ConfigResourcesV1ApiFetchParamCreator(configuration).listConfigResourceNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConfigResources(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListConfigResourcesResponse> {
            const localVarFetchArgs = ConfigResourcesV1ApiFetchParamCreator(configuration).listConfigResources(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} config_resource_uuid UUID
         * @param {V1ConfigResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchConfigResource(owner: string, config_resource_uuid: string, body: V1ConfigResource, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ConfigResource> {
            const localVarFetchArgs = ConfigResourcesV1ApiFetchParamCreator(configuration).patchConfigResource(owner, config_resource_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} config_resource_uuid UUID
         * @param {V1ConfigResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfigResource(owner: string, config_resource_uuid: string, body: V1ConfigResource, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ConfigResource> {
            const localVarFetchArgs = ConfigResourcesV1ApiFetchParamCreator(configuration).updateConfigResource(owner, config_resource_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ConfigResourcesV1Api - factory interface
 * @export
 */
export const ConfigResourcesV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1ConfigResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConfigResource(owner: string, body: V1ConfigResource, options?: any) {
            return ConfigResourcesV1ApiFp(configuration).createConfigResource(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConfigResource(owner: string, uuid: string, options?: any) {
            return ConfigResourcesV1ApiFp(configuration).deleteConfigResource(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigResource(owner: string, uuid: string, options?: any) {
            return ConfigResourcesV1ApiFp(configuration).getConfigResource(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConfigResourceNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ConfigResourcesV1ApiFp(configuration).listConfigResourceNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConfigResources(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ConfigResourcesV1ApiFp(configuration).listConfigResources(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} config_resource_uuid UUID
         * @param {V1ConfigResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchConfigResource(owner: string, config_resource_uuid: string, body: V1ConfigResource, options?: any) {
            return ConfigResourcesV1ApiFp(configuration).patchConfigResource(owner, config_resource_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} config_resource_uuid UUID
         * @param {V1ConfigResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfigResource(owner: string, config_resource_uuid: string, body: V1ConfigResource, options?: any) {
            return ConfigResourcesV1ApiFp(configuration).updateConfigResource(owner, config_resource_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * ConfigResourcesV1Api - object-oriented interface
 * @export
 * @class ConfigResourcesV1Api
 * @extends {BaseAPI}
 */
export class ConfigResourcesV1Api extends BaseAPI {
    /**
     * 
     * @summary List runs
     * @param {string} owner Owner of the namespace
     * @param {V1ConfigResource} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigResourcesV1Api
     */
    public createConfigResource(owner: string, body: V1ConfigResource, options?: any) {
        return ConfigResourcesV1ApiFp(this.configuration).createConfigResource(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch run
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigResourcesV1Api
     */
    public deleteConfigResource(owner: string, uuid: string, options?: any) {
        return ConfigResourcesV1ApiFp(this.configuration).deleteConfigResource(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigResourcesV1Api
     */
    public getConfigResource(owner: string, uuid: string, options?: any) {
        return ConfigResourcesV1ApiFp(this.configuration).getConfigResource(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigResourcesV1Api
     */
    public listConfigResourceNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ConfigResourcesV1ApiFp(this.configuration).listConfigResourceNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List archived runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigResourcesV1Api
     */
    public listConfigResources(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ConfigResourcesV1ApiFp(this.configuration).listConfigResources(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update run
     * @param {string} owner Owner of the namespace
     * @param {string} config_resource_uuid UUID
     * @param {V1ConfigResource} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigResourcesV1Api
     */
    public patchConfigResource(owner: string, config_resource_uuid: string, body: V1ConfigResource, options?: any) {
        return ConfigResourcesV1ApiFp(this.configuration).patchConfigResource(owner, config_resource_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run
     * @param {string} owner Owner of the namespace
     * @param {string} config_resource_uuid UUID
     * @param {V1ConfigResource} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigResourcesV1Api
     */
    public updateConfigResource(owner: string, config_resource_uuid: string, body: V1ConfigResource, options?: any) {
        return ConfigResourcesV1ApiFp(this.configuration).updateConfigResource(owner, config_resource_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * ConnectionsV1Api - fetch parameter creator
 * @export
 */
export const ConnectionsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1Connection} body Connection body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection(owner: string, body: V1Connection, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createConnection.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createConnection.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/connections`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Connection" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnection(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteConnection.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteConnection.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/connections/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnection(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getConnection.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getConnection.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/connections/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectionNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listConnectionNames.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/connections/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnections(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listConnections.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/connections`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} connection_uuid UUID
         * @param {V1Connection} body Connection body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchConnection(owner: string, connection_uuid: string, body: V1Connection, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchConnection.');
            }
            // verify required parameter 'connection_uuid' is not null or undefined
            if (connection_uuid === null || connection_uuid === undefined) {
                throw new RequiredError('connection_uuid','Required parameter connection_uuid was null or undefined when calling patchConnection.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchConnection.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/connections/{connection.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"connection.uuid"}}`, encodeURIComponent(String(connection_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Connection" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} connection_uuid UUID
         * @param {V1Connection} body Connection body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConnection(owner: string, connection_uuid: string, body: V1Connection, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateConnection.');
            }
            // verify required parameter 'connection_uuid' is not null or undefined
            if (connection_uuid === null || connection_uuid === undefined) {
                throw new RequiredError('connection_uuid','Required parameter connection_uuid was null or undefined when calling updateConnection.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateConnection.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/connections/{connection.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"connection.uuid"}}`, encodeURIComponent(String(connection_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Connection" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectionsV1Api - functional programming interface
 * @export
 */
export const ConnectionsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1Connection} body Connection body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection(owner: string, body: V1Connection, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Connection> {
            const localVarFetchArgs = ConnectionsV1ApiFetchParamCreator(configuration).createConnection(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnection(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ConnectionsV1ApiFetchParamCreator(configuration).deleteConnection(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnection(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Connection> {
            const localVarFetchArgs = ConnectionsV1ApiFetchParamCreator(configuration).getConnection(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectionNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListConnectionsResponse> {
            const localVarFetchArgs = ConnectionsV1ApiFetchParamCreator(configuration).listConnectionNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnections(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListConnectionsResponse> {
            const localVarFetchArgs = ConnectionsV1ApiFetchParamCreator(configuration).listConnections(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} connection_uuid UUID
         * @param {V1Connection} body Connection body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchConnection(owner: string, connection_uuid: string, body: V1Connection, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Connection> {
            const localVarFetchArgs = ConnectionsV1ApiFetchParamCreator(configuration).patchConnection(owner, connection_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} connection_uuid UUID
         * @param {V1Connection} body Connection body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConnection(owner: string, connection_uuid: string, body: V1Connection, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Connection> {
            const localVarFetchArgs = ConnectionsV1ApiFetchParamCreator(configuration).updateConnection(owner, connection_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ConnectionsV1Api - factory interface
 * @export
 */
export const ConnectionsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1Connection} body Connection body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection(owner: string, body: V1Connection, options?: any) {
            return ConnectionsV1ApiFp(configuration).createConnection(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnection(owner: string, uuid: string, options?: any) {
            return ConnectionsV1ApiFp(configuration).deleteConnection(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnection(owner: string, uuid: string, options?: any) {
            return ConnectionsV1ApiFp(configuration).getConnection(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectionNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ConnectionsV1ApiFp(configuration).listConnectionNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnections(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ConnectionsV1ApiFp(configuration).listConnections(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} connection_uuid UUID
         * @param {V1Connection} body Connection body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchConnection(owner: string, connection_uuid: string, body: V1Connection, options?: any) {
            return ConnectionsV1ApiFp(configuration).patchConnection(owner, connection_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} connection_uuid UUID
         * @param {V1Connection} body Connection body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConnection(owner: string, connection_uuid: string, body: V1Connection, options?: any) {
            return ConnectionsV1ApiFp(configuration).updateConnection(owner, connection_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * ConnectionsV1Api - object-oriented interface
 * @export
 * @class ConnectionsV1Api
 * @extends {BaseAPI}
 */
export class ConnectionsV1Api extends BaseAPI {
    /**
     * 
     * @summary List runs
     * @param {string} owner Owner of the namespace
     * @param {V1Connection} body Connection body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsV1Api
     */
    public createConnection(owner: string, body: V1Connection, options?: any) {
        return ConnectionsV1ApiFp(this.configuration).createConnection(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch run
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsV1Api
     */
    public deleteConnection(owner: string, uuid: string, options?: any) {
        return ConnectionsV1ApiFp(this.configuration).deleteConnection(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsV1Api
     */
    public getConnection(owner: string, uuid: string, options?: any) {
        return ConnectionsV1ApiFp(this.configuration).getConnection(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsV1Api
     */
    public listConnectionNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ConnectionsV1ApiFp(this.configuration).listConnectionNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List archived runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsV1Api
     */
    public listConnections(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ConnectionsV1ApiFp(this.configuration).listConnections(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update run
     * @param {string} owner Owner of the namespace
     * @param {string} connection_uuid UUID
     * @param {V1Connection} body Connection body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsV1Api
     */
    public patchConnection(owner: string, connection_uuid: string, body: V1Connection, options?: any) {
        return ConnectionsV1ApiFp(this.configuration).patchConnection(owner, connection_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run
     * @param {string} owner Owner of the namespace
     * @param {string} connection_uuid UUID
     * @param {V1Connection} body Connection body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsV1Api
     */
    public updateConnection(owner: string, connection_uuid: string, body: V1Connection, options?: any) {
        return ConnectionsV1ApiFp(this.configuration).updateConnection(owner, connection_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * DashboardsV1Api - fetch parameter creator
 * @export
 */
export const DashboardsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDashboard(owner: string, body: V1Dashboard, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createDashboard.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createDashboard.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/dashboards`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Dashboard" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboard(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteDashboard.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteDashboard.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/dashboards/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboard(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getDashboard.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getDashboard.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/dashboards/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDashboardNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listDashboardNames.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/dashboards/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDashboards(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listDashboards.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/dashboards`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} dashboard_uuid UUID
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDashboard(owner: string, dashboard_uuid: string, body: V1Dashboard, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchDashboard.');
            }
            // verify required parameter 'dashboard_uuid' is not null or undefined
            if (dashboard_uuid === null || dashboard_uuid === undefined) {
                throw new RequiredError('dashboard_uuid','Required parameter dashboard_uuid was null or undefined when calling patchDashboard.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchDashboard.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/dashboards/{dashboard.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"dashboard.uuid"}}`, encodeURIComponent(String(dashboard_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Dashboard" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} dashboard_uuid UUID
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDashboard(owner: string, dashboard_uuid: string, body: V1Dashboard, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateDashboard.');
            }
            // verify required parameter 'dashboard_uuid' is not null or undefined
            if (dashboard_uuid === null || dashboard_uuid === undefined) {
                throw new RequiredError('dashboard_uuid','Required parameter dashboard_uuid was null or undefined when calling updateDashboard.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateDashboard.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/dashboards/{dashboard.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"dashboard.uuid"}}`, encodeURIComponent(String(dashboard_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Dashboard" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardsV1Api - functional programming interface
 * @export
 */
export const DashboardsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDashboard(owner: string, body: V1Dashboard, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Dashboard> {
            const localVarFetchArgs = DashboardsV1ApiFetchParamCreator(configuration).createDashboard(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboard(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DashboardsV1ApiFetchParamCreator(configuration).deleteDashboard(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboard(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Dashboard> {
            const localVarFetchArgs = DashboardsV1ApiFetchParamCreator(configuration).getDashboard(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDashboardNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListDashboardsResponse> {
            const localVarFetchArgs = DashboardsV1ApiFetchParamCreator(configuration).listDashboardNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDashboards(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListDashboardsResponse> {
            const localVarFetchArgs = DashboardsV1ApiFetchParamCreator(configuration).listDashboards(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} dashboard_uuid UUID
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDashboard(owner: string, dashboard_uuid: string, body: V1Dashboard, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Dashboard> {
            const localVarFetchArgs = DashboardsV1ApiFetchParamCreator(configuration).patchDashboard(owner, dashboard_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} dashboard_uuid UUID
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDashboard(owner: string, dashboard_uuid: string, body: V1Dashboard, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Dashboard> {
            const localVarFetchArgs = DashboardsV1ApiFetchParamCreator(configuration).updateDashboard(owner, dashboard_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DashboardsV1Api - factory interface
 * @export
 */
export const DashboardsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDashboard(owner: string, body: V1Dashboard, options?: any) {
            return DashboardsV1ApiFp(configuration).createDashboard(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboard(owner: string, uuid: string, options?: any) {
            return DashboardsV1ApiFp(configuration).deleteDashboard(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboard(owner: string, uuid: string, options?: any) {
            return DashboardsV1ApiFp(configuration).getDashboard(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDashboardNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return DashboardsV1ApiFp(configuration).listDashboardNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDashboards(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return DashboardsV1ApiFp(configuration).listDashboards(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} dashboard_uuid UUID
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDashboard(owner: string, dashboard_uuid: string, body: V1Dashboard, options?: any) {
            return DashboardsV1ApiFp(configuration).patchDashboard(owner, dashboard_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} dashboard_uuid UUID
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDashboard(owner: string, dashboard_uuid: string, body: V1Dashboard, options?: any) {
            return DashboardsV1ApiFp(configuration).updateDashboard(owner, dashboard_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * DashboardsV1Api - object-oriented interface
 * @export
 * @class DashboardsV1Api
 * @extends {BaseAPI}
 */
export class DashboardsV1Api extends BaseAPI {
    /**
     * 
     * @summary List runs
     * @param {string} owner Owner of the namespace
     * @param {V1Dashboard} body Dashboard body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsV1Api
     */
    public createDashboard(owner: string, body: V1Dashboard, options?: any) {
        return DashboardsV1ApiFp(this.configuration).createDashboard(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch run
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsV1Api
     */
    public deleteDashboard(owner: string, uuid: string, options?: any) {
        return DashboardsV1ApiFp(this.configuration).deleteDashboard(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsV1Api
     */
    public getDashboard(owner: string, uuid: string, options?: any) {
        return DashboardsV1ApiFp(this.configuration).getDashboard(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsV1Api
     */
    public listDashboardNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return DashboardsV1ApiFp(this.configuration).listDashboardNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List archived runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsV1Api
     */
    public listDashboards(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return DashboardsV1ApiFp(this.configuration).listDashboards(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update run
     * @param {string} owner Owner of the namespace
     * @param {string} dashboard_uuid UUID
     * @param {V1Dashboard} body Dashboard body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsV1Api
     */
    public patchDashboard(owner: string, dashboard_uuid: string, body: V1Dashboard, options?: any) {
        return DashboardsV1ApiFp(this.configuration).patchDashboard(owner, dashboard_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run
     * @param {string} owner Owner of the namespace
     * @param {string} dashboard_uuid UUID
     * @param {V1Dashboard} body Dashboard body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsV1Api
     */
    public updateDashboard(owner: string, dashboard_uuid: string, body: V1Dashboard, options?: any) {
        return DashboardsV1ApiFp(this.configuration).updateDashboard(owner, dashboard_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * OrganizationsV1Api - fetch parameter creator
 * @export
 */
export const OrganizationsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {V1Organization} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization(body: V1Organization, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createOrganization.');
            }
            const localVarPath = `/api/v1/orgs/create`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Organization" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {V1OrganizationMember} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationMember(owner: string, body: V1OrganizationMember, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createOrganizationMember.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createOrganizationMember.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/members`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1OrganizationMember" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization(owner: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteOrganization.');
            }
            const localVarPath = `/api/v1/orgs/{owner}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invalidate runs
         * @param {string} owner Owner of the namespace
         * @param {string} user Memeber under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationMember(owner: string, user: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteOrganizationMember.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling deleteOrganizationMember.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/members/{user}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(owner: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getOrganization.');
            }
            const localVarPath = `/api/v1/orgs/{owner}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} user Memeber under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationMember(owner: string, user: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getOrganizationMember.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling getOrganizationMember.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/members/{user}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationMembers(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listOrganizationMembers.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/members`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationNames(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/orgs/names`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizations(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/orgs/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {V1Organization} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOrganization(owner: string, body: V1Organization, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchOrganization.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchOrganization.');
            }
            const localVarPath = `/api/v1/orgs/{owner}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Organization" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invalidate run
         * @param {string} owner Owner of the namespace
         * @param {string} member_user User
         * @param {V1OrganizationMember} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOrganizationMember(owner: string, member_user: string, body: V1OrganizationMember, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchOrganizationMember.');
            }
            // verify required parameter 'member_user' is not null or undefined
            if (member_user === null || member_user === undefined) {
                throw new RequiredError('member_user','Required parameter member_user was null or undefined when calling patchOrganizationMember.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchOrganizationMember.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/members/{member.user}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"member.user"}}`, encodeURIComponent(String(member_user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1OrganizationMember" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {V1Organization} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization(owner: string, body: V1Organization, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateOrganization.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateOrganization.');
            }
            const localVarPath = `/api/v1/orgs/{owner}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Organization" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop runs
         * @param {string} owner Owner of the namespace
         * @param {string} member_user User
         * @param {V1OrganizationMember} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationMember(owner: string, member_user: string, body: V1OrganizationMember, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateOrganizationMember.');
            }
            // verify required parameter 'member_user' is not null or undefined
            if (member_user === null || member_user === undefined) {
                throw new RequiredError('member_user','Required parameter member_user was null or undefined when calling updateOrganizationMember.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateOrganizationMember.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/members/{member.user}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"member.user"}}`, encodeURIComponent(String(member_user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1OrganizationMember" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationsV1Api - functional programming interface
 * @export
 */
export const OrganizationsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {V1Organization} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization(body: V1Organization, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Organization> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).createOrganization(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {V1OrganizationMember} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationMember(owner: string, body: V1OrganizationMember, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1OrganizationMember> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).createOrganizationMember(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization(owner: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).deleteOrganization(owner, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Invalidate runs
         * @param {string} owner Owner of the namespace
         * @param {string} user Memeber under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationMember(owner: string, user: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).deleteOrganizationMember(owner, user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(owner: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Organization> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).getOrganization(owner, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} user Memeber under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationMember(owner: string, user: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1OrganizationMember> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).getOrganizationMember(owner, user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationMembers(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListOrganizationMembersResponse> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).listOrganizationMembers(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationNames(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListOrganizationsResponse> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).listOrganizationNames(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizations(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListOrganizationsResponse> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).listOrganizations(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {V1Organization} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOrganization(owner: string, body: V1Organization, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Organization> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).patchOrganization(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Invalidate run
         * @param {string} owner Owner of the namespace
         * @param {string} member_user User
         * @param {V1OrganizationMember} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOrganizationMember(owner: string, member_user: string, body: V1OrganizationMember, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1OrganizationMember> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).patchOrganizationMember(owner, member_user, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {V1Organization} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization(owner: string, body: V1Organization, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Organization> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).updateOrganization(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stop runs
         * @param {string} owner Owner of the namespace
         * @param {string} member_user User
         * @param {V1OrganizationMember} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationMember(owner: string, member_user: string, body: V1OrganizationMember, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1OrganizationMember> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).updateOrganizationMember(owner, member_user, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OrganizationsV1Api - factory interface
 * @export
 */
export const OrganizationsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List runs
         * @param {V1Organization} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization(body: V1Organization, options?: any) {
            return OrganizationsV1ApiFp(configuration).createOrganization(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {V1OrganizationMember} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationMember(owner: string, body: V1OrganizationMember, options?: any) {
            return OrganizationsV1ApiFp(configuration).createOrganizationMember(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization(owner: string, options?: any) {
            return OrganizationsV1ApiFp(configuration).deleteOrganization(owner, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Invalidate runs
         * @param {string} owner Owner of the namespace
         * @param {string} user Memeber under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationMember(owner: string, user: string, options?: any) {
            return OrganizationsV1ApiFp(configuration).deleteOrganizationMember(owner, user, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(owner: string, options?: any) {
            return OrganizationsV1ApiFp(configuration).getOrganization(owner, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} user Memeber under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationMember(owner: string, user: string, options?: any) {
            return OrganizationsV1ApiFp(configuration).getOrganizationMember(owner, user, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationMembers(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return OrganizationsV1ApiFp(configuration).listOrganizationMembers(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationNames(options?: any) {
            return OrganizationsV1ApiFp(configuration).listOrganizationNames(options)(fetch, basePath);
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizations(options?: any) {
            return OrganizationsV1ApiFp(configuration).listOrganizations(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {V1Organization} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOrganization(owner: string, body: V1Organization, options?: any) {
            return OrganizationsV1ApiFp(configuration).patchOrganization(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Invalidate run
         * @param {string} owner Owner of the namespace
         * @param {string} member_user User
         * @param {V1OrganizationMember} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOrganizationMember(owner: string, member_user: string, body: V1OrganizationMember, options?: any) {
            return OrganizationsV1ApiFp(configuration).patchOrganizationMember(owner, member_user, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {V1Organization} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization(owner: string, body: V1Organization, options?: any) {
            return OrganizationsV1ApiFp(configuration).updateOrganization(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stop runs
         * @param {string} owner Owner of the namespace
         * @param {string} member_user User
         * @param {V1OrganizationMember} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationMember(owner: string, member_user: string, body: V1OrganizationMember, options?: any) {
            return OrganizationsV1ApiFp(configuration).updateOrganizationMember(owner, member_user, body, options)(fetch, basePath);
        },
    };
};

/**
 * OrganizationsV1Api - object-oriented interface
 * @export
 * @class OrganizationsV1Api
 * @extends {BaseAPI}
 */
export class OrganizationsV1Api extends BaseAPI {
    /**
     * 
     * @summary List runs
     * @param {V1Organization} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public createOrganization(body: V1Organization, options?: any) {
        return OrganizationsV1ApiFp(this.configuration).createOrganization(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete runs
     * @param {string} owner Owner of the namespace
     * @param {V1OrganizationMember} body Organization body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public createOrganizationMember(owner: string, body: V1OrganizationMember, options?: any) {
        return OrganizationsV1ApiFp(this.configuration).createOrganizationMember(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch run
     * @param {string} owner Owner of the namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public deleteOrganization(owner: string, options?: any) {
        return OrganizationsV1ApiFp(this.configuration).deleteOrganization(owner, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Invalidate runs
     * @param {string} owner Owner of the namespace
     * @param {string} user Memeber under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public deleteOrganizationMember(owner: string, user: string, options?: any) {
        return OrganizationsV1ApiFp(this.configuration).deleteOrganizationMember(owner, user, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run
     * @param {string} owner Owner of the namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public getOrganization(owner: string, options?: any) {
        return OrganizationsV1ApiFp(this.configuration).getOrganization(owner, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stop run
     * @param {string} owner Owner of the namespace
     * @param {string} user Memeber under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public getOrganizationMember(owner: string, user: string, options?: any) {
        return OrganizationsV1ApiFp(this.configuration).getOrganizationMember(owner, user, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete run
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public listOrganizationMembers(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return OrganizationsV1ApiFp(this.configuration).listOrganizationMembers(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked runs for user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public listOrganizationNames(options?: any) {
        return OrganizationsV1ApiFp(this.configuration).listOrganizationNames(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List archived runs for user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public listOrganizations(options?: any) {
        return OrganizationsV1ApiFp(this.configuration).listOrganizations(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update run
     * @param {string} owner Owner of the namespace
     * @param {V1Organization} body Organization body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public patchOrganization(owner: string, body: V1Organization, options?: any) {
        return OrganizationsV1ApiFp(this.configuration).patchOrganization(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Invalidate run
     * @param {string} owner Owner of the namespace
     * @param {string} member_user User
     * @param {V1OrganizationMember} body Organization body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public patchOrganizationMember(owner: string, member_user: string, body: V1OrganizationMember, options?: any) {
        return OrganizationsV1ApiFp(this.configuration).patchOrganizationMember(owner, member_user, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run
     * @param {string} owner Owner of the namespace
     * @param {V1Organization} body Organization body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public updateOrganization(owner: string, body: V1Organization, options?: any) {
        return OrganizationsV1ApiFp(this.configuration).updateOrganization(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stop runs
     * @param {string} owner Owner of the namespace
     * @param {string} member_user User
     * @param {V1OrganizationMember} body Organization body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public updateOrganizationMember(owner: string, member_user: string, body: V1OrganizationMember, options?: any) {
        return OrganizationsV1ApiFp(this.configuration).updateOrganizationMember(owner, member_user, body, options)(this.fetch, this.basePath);
    }

}

/**
 * ProjectDashboardsV1Api - fetch parameter creator
 * @export
 */
export const ProjectDashboardsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectDashboard(owner: string, project: string, body: V1Dashboard, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createProjectDashboard.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling createProjectDashboard.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createProjectDashboard.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/dashboards`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Dashboard" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectDashboard(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteProjectDashboard.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling deleteProjectDashboard.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteProjectDashboard.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/dashboards/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectDashboard(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getProjectDashboard.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getProjectDashboard.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getProjectDashboard.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/dashboards/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectDashboardNames(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listProjectDashboardNames.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling listProjectDashboardNames.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/dashboards/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectDashboards(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listProjectDashboards.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling listProjectDashboards.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/dashboards`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} dashboard_uuid UUID
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProjectDashboard(owner: string, project: string, dashboard_uuid: string, body: V1Dashboard, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchProjectDashboard.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling patchProjectDashboard.');
            }
            // verify required parameter 'dashboard_uuid' is not null or undefined
            if (dashboard_uuid === null || dashboard_uuid === undefined) {
                throw new RequiredError('dashboard_uuid','Required parameter dashboard_uuid was null or undefined when calling patchProjectDashboard.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchProjectDashboard.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/dashboards/{dashboard.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"dashboard.uuid"}}`, encodeURIComponent(String(dashboard_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Dashboard" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} dashboard_uuid UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoteProjectDashboard(owner: string, project: string, dashboard_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling promoteProjectDashboard.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling promoteProjectDashboard.');
            }
            // verify required parameter 'dashboard_uuid' is not null or undefined
            if (dashboard_uuid === null || dashboard_uuid === undefined) {
                throw new RequiredError('dashboard_uuid','Required parameter dashboard_uuid was null or undefined when calling promoteProjectDashboard.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/dashboards/{dashboard.uuid}/promote`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"dashboard.uuid"}}`, encodeURIComponent(String(dashboard_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} dashboard_uuid UUID
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectDashboard(owner: string, project: string, dashboard_uuid: string, body: V1Dashboard, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateProjectDashboard.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling updateProjectDashboard.');
            }
            // verify required parameter 'dashboard_uuid' is not null or undefined
            if (dashboard_uuid === null || dashboard_uuid === undefined) {
                throw new RequiredError('dashboard_uuid','Required parameter dashboard_uuid was null or undefined when calling updateProjectDashboard.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateProjectDashboard.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/dashboards/{dashboard.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"dashboard.uuid"}}`, encodeURIComponent(String(dashboard_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Dashboard" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectDashboardsV1Api - functional programming interface
 * @export
 */
export const ProjectDashboardsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectDashboard(owner: string, project: string, body: V1Dashboard, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Dashboard> {
            const localVarFetchArgs = ProjectDashboardsV1ApiFetchParamCreator(configuration).createProjectDashboard(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectDashboard(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectDashboardsV1ApiFetchParamCreator(configuration).deleteProjectDashboard(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectDashboard(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Dashboard> {
            const localVarFetchArgs = ProjectDashboardsV1ApiFetchParamCreator(configuration).getProjectDashboard(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectDashboardNames(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListDashboardsResponse> {
            const localVarFetchArgs = ProjectDashboardsV1ApiFetchParamCreator(configuration).listProjectDashboardNames(owner, project, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectDashboards(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListDashboardsResponse> {
            const localVarFetchArgs = ProjectDashboardsV1ApiFetchParamCreator(configuration).listProjectDashboards(owner, project, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} dashboard_uuid UUID
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProjectDashboard(owner: string, project: string, dashboard_uuid: string, body: V1Dashboard, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Dashboard> {
            const localVarFetchArgs = ProjectDashboardsV1ApiFetchParamCreator(configuration).patchProjectDashboard(owner, project, dashboard_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} dashboard_uuid UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoteProjectDashboard(owner: string, project: string, dashboard_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Dashboard> {
            const localVarFetchArgs = ProjectDashboardsV1ApiFetchParamCreator(configuration).promoteProjectDashboard(owner, project, dashboard_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} dashboard_uuid UUID
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectDashboard(owner: string, project: string, dashboard_uuid: string, body: V1Dashboard, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Dashboard> {
            const localVarFetchArgs = ProjectDashboardsV1ApiFetchParamCreator(configuration).updateProjectDashboard(owner, project, dashboard_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProjectDashboardsV1Api - factory interface
 * @export
 */
export const ProjectDashboardsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectDashboard(owner: string, project: string, body: V1Dashboard, options?: any) {
            return ProjectDashboardsV1ApiFp(configuration).createProjectDashboard(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectDashboard(owner: string, project: string, uuid: string, options?: any) {
            return ProjectDashboardsV1ApiFp(configuration).deleteProjectDashboard(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectDashboard(owner: string, project: string, uuid: string, options?: any) {
            return ProjectDashboardsV1ApiFp(configuration).getProjectDashboard(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectDashboardNames(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ProjectDashboardsV1ApiFp(configuration).listProjectDashboardNames(owner, project, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectDashboards(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ProjectDashboardsV1ApiFp(configuration).listProjectDashboards(owner, project, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} dashboard_uuid UUID
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProjectDashboard(owner: string, project: string, dashboard_uuid: string, body: V1Dashboard, options?: any) {
            return ProjectDashboardsV1ApiFp(configuration).patchProjectDashboard(owner, project, dashboard_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} dashboard_uuid UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoteProjectDashboard(owner: string, project: string, dashboard_uuid: string, options?: any) {
            return ProjectDashboardsV1ApiFp(configuration).promoteProjectDashboard(owner, project, dashboard_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} dashboard_uuid UUID
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectDashboard(owner: string, project: string, dashboard_uuid: string, body: V1Dashboard, options?: any) {
            return ProjectDashboardsV1ApiFp(configuration).updateProjectDashboard(owner, project, dashboard_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * ProjectDashboardsV1Api - object-oriented interface
 * @export
 * @class ProjectDashboardsV1Api
 * @extends {BaseAPI}
 */
export class ProjectDashboardsV1Api extends BaseAPI {
    /**
     * 
     * @summary List runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {V1Dashboard} body Dashboard body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDashboardsV1Api
     */
    public createProjectDashboard(owner: string, project: string, body: V1Dashboard, options?: any) {
        return ProjectDashboardsV1ApiFp(this.configuration).createProjectDashboard(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDashboardsV1Api
     */
    public deleteProjectDashboard(owner: string, project: string, uuid: string, options?: any) {
        return ProjectDashboardsV1ApiFp(this.configuration).deleteProjectDashboard(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDashboardsV1Api
     */
    public getProjectDashboard(owner: string, project: string, uuid: string, options?: any) {
        return ProjectDashboardsV1ApiFp(this.configuration).getProjectDashboard(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked runs for user
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDashboardsV1Api
     */
    public listProjectDashboardNames(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ProjectDashboardsV1ApiFp(this.configuration).listProjectDashboardNames(owner, project, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List archived runs for user
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDashboardsV1Api
     */
    public listProjectDashboards(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ProjectDashboardsV1ApiFp(this.configuration).listProjectDashboards(owner, project, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {string} dashboard_uuid UUID
     * @param {V1Dashboard} body Dashboard body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDashboardsV1Api
     */
    public patchProjectDashboard(owner: string, project: string, dashboard_uuid: string, body: V1Dashboard, options?: any) {
        return ProjectDashboardsV1ApiFp(this.configuration).patchProjectDashboard(owner, project, dashboard_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {string} dashboard_uuid UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDashboardsV1Api
     */
    public promoteProjectDashboard(owner: string, project: string, dashboard_uuid: string, options?: any) {
        return ProjectDashboardsV1ApiFp(this.configuration).promoteProjectDashboard(owner, project, dashboard_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {string} dashboard_uuid UUID
     * @param {V1Dashboard} body Dashboard body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDashboardsV1Api
     */
    public updateProjectDashboard(owner: string, project: string, dashboard_uuid: string, body: V1Dashboard, options?: any) {
        return ProjectDashboardsV1ApiFp(this.configuration).updateProjectDashboard(owner, project, dashboard_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * ProjectSearchesV1Api - fetch parameter creator
 * @export
 */
export const ProjectSearchesV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectSearch(owner: string, project: string, body: V1Search, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createProjectSearch.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling createProjectSearch.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createProjectSearch.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/searches`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Search" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectSearch(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteProjectSearch.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling deleteProjectSearch.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteProjectSearch.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/searches/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSearch(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getProjectSearch.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getProjectSearch.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getProjectSearch.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/searches/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectSearchNames(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listProjectSearchNames.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling listProjectSearchNames.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/searches/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectSearches(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listProjectSearches.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling listProjectSearches.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/searches`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} search_uuid UUID
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProjectSearch(owner: string, project: string, search_uuid: string, body: V1Search, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchProjectSearch.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling patchProjectSearch.');
            }
            // verify required parameter 'search_uuid' is not null or undefined
            if (search_uuid === null || search_uuid === undefined) {
                throw new RequiredError('search_uuid','Required parameter search_uuid was null or undefined when calling patchProjectSearch.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchProjectSearch.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/searches/{search.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"search.uuid"}}`, encodeURIComponent(String(search_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Search" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoteProjectSearch(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling promoteProjectSearch.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling promoteProjectSearch.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling promoteProjectSearch.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/searches/{uuid}/promote`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} search_uuid UUID
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectSearch(owner: string, project: string, search_uuid: string, body: V1Search, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateProjectSearch.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling updateProjectSearch.');
            }
            // verify required parameter 'search_uuid' is not null or undefined
            if (search_uuid === null || search_uuid === undefined) {
                throw new RequiredError('search_uuid','Required parameter search_uuid was null or undefined when calling updateProjectSearch.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateProjectSearch.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/searches/{search.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"search.uuid"}}`, encodeURIComponent(String(search_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Search" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectSearchesV1Api - functional programming interface
 * @export
 */
export const ProjectSearchesV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectSearch(owner: string, project: string, body: V1Search, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Search> {
            const localVarFetchArgs = ProjectSearchesV1ApiFetchParamCreator(configuration).createProjectSearch(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectSearch(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectSearchesV1ApiFetchParamCreator(configuration).deleteProjectSearch(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSearch(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Search> {
            const localVarFetchArgs = ProjectSearchesV1ApiFetchParamCreator(configuration).getProjectSearch(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectSearchNames(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListSearchesResponse> {
            const localVarFetchArgs = ProjectSearchesV1ApiFetchParamCreator(configuration).listProjectSearchNames(owner, project, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectSearches(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListSearchesResponse> {
            const localVarFetchArgs = ProjectSearchesV1ApiFetchParamCreator(configuration).listProjectSearches(owner, project, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} search_uuid UUID
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProjectSearch(owner: string, project: string, search_uuid: string, body: V1Search, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Search> {
            const localVarFetchArgs = ProjectSearchesV1ApiFetchParamCreator(configuration).patchProjectSearch(owner, project, search_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoteProjectSearch(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectSearchesV1ApiFetchParamCreator(configuration).promoteProjectSearch(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} search_uuid UUID
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectSearch(owner: string, project: string, search_uuid: string, body: V1Search, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Search> {
            const localVarFetchArgs = ProjectSearchesV1ApiFetchParamCreator(configuration).updateProjectSearch(owner, project, search_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProjectSearchesV1Api - factory interface
 * @export
 */
export const ProjectSearchesV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectSearch(owner: string, project: string, body: V1Search, options?: any) {
            return ProjectSearchesV1ApiFp(configuration).createProjectSearch(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectSearch(owner: string, project: string, uuid: string, options?: any) {
            return ProjectSearchesV1ApiFp(configuration).deleteProjectSearch(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSearch(owner: string, project: string, uuid: string, options?: any) {
            return ProjectSearchesV1ApiFp(configuration).getProjectSearch(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectSearchNames(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ProjectSearchesV1ApiFp(configuration).listProjectSearchNames(owner, project, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectSearches(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ProjectSearchesV1ApiFp(configuration).listProjectSearches(owner, project, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} search_uuid UUID
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProjectSearch(owner: string, project: string, search_uuid: string, body: V1Search, options?: any) {
            return ProjectSearchesV1ApiFp(configuration).patchProjectSearch(owner, project, search_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoteProjectSearch(owner: string, project: string, uuid: string, options?: any) {
            return ProjectSearchesV1ApiFp(configuration).promoteProjectSearch(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} search_uuid UUID
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectSearch(owner: string, project: string, search_uuid: string, body: V1Search, options?: any) {
            return ProjectSearchesV1ApiFp(configuration).updateProjectSearch(owner, project, search_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * ProjectSearchesV1Api - object-oriented interface
 * @export
 * @class ProjectSearchesV1Api
 * @extends {BaseAPI}
 */
export class ProjectSearchesV1Api extends BaseAPI {
    /**
     * 
     * @summary List runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {V1Search} body Search body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSearchesV1Api
     */
    public createProjectSearch(owner: string, project: string, body: V1Search, options?: any) {
        return ProjectSearchesV1ApiFp(this.configuration).createProjectSearch(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSearchesV1Api
     */
    public deleteProjectSearch(owner: string, project: string, uuid: string, options?: any) {
        return ProjectSearchesV1ApiFp(this.configuration).deleteProjectSearch(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSearchesV1Api
     */
    public getProjectSearch(owner: string, project: string, uuid: string, options?: any) {
        return ProjectSearchesV1ApiFp(this.configuration).getProjectSearch(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked runs for user
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSearchesV1Api
     */
    public listProjectSearchNames(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ProjectSearchesV1ApiFp(this.configuration).listProjectSearchNames(owner, project, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List archived runs for user
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSearchesV1Api
     */
    public listProjectSearches(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ProjectSearchesV1ApiFp(this.configuration).listProjectSearches(owner, project, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {string} search_uuid UUID
     * @param {V1Search} body Search body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSearchesV1Api
     */
    public patchProjectSearch(owner: string, project: string, search_uuid: string, body: V1Search, options?: any) {
        return ProjectSearchesV1ApiFp(this.configuration).patchProjectSearch(owner, project, search_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSearchesV1Api
     */
    public promoteProjectSearch(owner: string, project: string, uuid: string, options?: any) {
        return ProjectSearchesV1ApiFp(this.configuration).promoteProjectSearch(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {string} search_uuid UUID
     * @param {V1Search} body Search body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSearchesV1Api
     */
    public updateProjectSearch(owner: string, project: string, search_uuid: string, body: V1Search, options?: any) {
        return ProjectSearchesV1ApiFp(this.configuration).updateProjectSearch(owner, project, search_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * ProjectsV1Api - fetch parameter creator
 * @export
 */
export const ProjectsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveProject(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling archiveProject.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling archiveProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/archive`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invalidate run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkProject(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling bookmarkProject.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling bookmarkProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/bookmark`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(owner: string, body: V1Project, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createProject.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createProject.');
            }
            const localVarPath = `/api/v1/{owner}/projects/create`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Project" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteProject.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling deleteProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restart run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableProjectCI(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling disableProjectCI.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling disableProjectCI.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/ci`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restart run with copy
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableProjectCI(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling enableProjectCI.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling enableProjectCI.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/ci`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getProject.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resume run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSettings(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getProjectSettings.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getProjectSettings.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/settings`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Bookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectTeams(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getProjectTeams.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getProjectTeams.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/teams`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling listArchivedProjects.');
            }
            const localVarPath = `/api/v1/archives/{user}/projects`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling listBookmarkedProjects.');
            }
            const localVarPath = `/api/v1/bookmarks/{user}/projects`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listProjectNames.');
            }
            const localVarPath = `/api/v1/{owner}/projects/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listProjects.');
            }
            const localVarPath = `/api/v1/{owner}/projects/list`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} project_name Required name
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProject(owner: string, project_name: string, body: V1Project, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchProject.');
            }
            // verify required parameter 'project_name' is not null or undefined
            if (project_name === null || project_name === undefined) {
                throw new RequiredError('project_name','Required parameter project_name was null or undefined when calling patchProject.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project.name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project.name"}}`, encodeURIComponent(String(project_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Project" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project name
         * @param {V1ProjectSettings} body Project settings body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProjectSettings(owner: string, project: string, body: V1ProjectSettings, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchProjectSettings.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling patchProjectSettings.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchProjectSettings.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/settings`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ProjectSettings" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project name
         * @param {V1ProjectTeams} body Project settings body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProjectTeams(owner: string, project: string, body: V1ProjectTeams, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchProjectTeams.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling patchProjectTeams.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchProjectTeams.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/teams`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ProjectTeams" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreProject(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling restoreProject.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling restoreProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/restore`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invalidate runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbookmarkProject(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling unbookmarkProject.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling unbookmarkProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/unbookmark`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} project_name Required name
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject(owner: string, project_name: string, body: V1Project, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateProject.');
            }
            // verify required parameter 'project_name' is not null or undefined
            if (project_name === null || project_name === undefined) {
                throw new RequiredError('project_name','Required parameter project_name was null or undefined when calling updateProject.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project.name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project.name"}}`, encodeURIComponent(String(project_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Project" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Archive run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project name
         * @param {V1ProjectSettings} body Project settings body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectSettings(owner: string, project: string, body: V1ProjectSettings, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateProjectSettings.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling updateProjectSettings.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateProjectSettings.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/settings`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ProjectSettings" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unbookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project name
         * @param {V1ProjectTeams} body Project settings body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectTeams(owner: string, project: string, body: V1ProjectTeams, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateProjectTeams.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling updateProjectTeams.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateProjectTeams.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/teams`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ProjectTeams" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload artifact to a store via project access
         * @param {string} owner Owner of the namespace
         * @param {string} project Project having access to the store
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProjectArtifact(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling uploadProjectArtifact.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling uploadProjectArtifact.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling uploadProjectArtifact.');
            }
            // verify required parameter 'uploadfile' is not null or undefined
            if (uploadfile === null || uploadfile === undefined) {
                throw new RequiredError('uploadfile','Required parameter uploadfile was null or undefined when calling uploadProjectArtifact.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/artifacts/{uuid}/upload`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (overwrite !== undefined) {
                localVarQueryParameter['overwrite'] = overwrite;
            }

            if (uploadfile !== undefined) {
                localVarFormParams.set('uploadfile', uploadfile as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsV1Api - functional programming interface
 * @export
 */
export const ProjectsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveProject(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).archiveProject(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Invalidate run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkProject(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).bookmarkProject(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(owner: string, body: V1Project, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Project> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).createProject(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).deleteProject(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Restart run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableProjectCI(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).disableProjectCI(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Restart run with copy
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableProjectCI(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).enableProjectCI(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Project> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).getProject(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Resume run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSettings(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ProjectSettings> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).getProjectSettings(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Bookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectTeams(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ProjectTeams> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).getProjectTeams(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListProjectsResponse> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).listArchivedProjects(user, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListProjectsResponse> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).listBookmarkedProjects(user, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListProjectsResponse> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).listProjectNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListProjectsResponse> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).listProjects(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} project_name Required name
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProject(owner: string, project_name: string, body: V1Project, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Project> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).patchProject(owner, project_name, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Restore run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project name
         * @param {V1ProjectSettings} body Project settings body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProjectSettings(owner: string, project: string, body: V1ProjectSettings, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ProjectSettings> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).patchProjectSettings(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Start run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project name
         * @param {V1ProjectTeams} body Project settings body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProjectTeams(owner: string, project: string, body: V1ProjectTeams, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ProjectTeams> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).patchProjectTeams(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stop runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreProject(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).restoreProject(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Invalidate runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbookmarkProject(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).unbookmarkProject(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} project_name Required name
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject(owner: string, project_name: string, body: V1Project, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Project> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).updateProject(owner, project_name, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Archive run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project name
         * @param {V1ProjectSettings} body Project settings body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectSettings(owner: string, project: string, body: V1ProjectSettings, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ProjectSettings> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).updateProjectSettings(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Unbookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project name
         * @param {V1ProjectTeams} body Project settings body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectTeams(owner: string, project: string, body: V1ProjectTeams, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ProjectTeams> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).updateProjectTeams(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Upload artifact to a store via project access
         * @param {string} owner Owner of the namespace
         * @param {string} project Project having access to the store
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProjectArtifact(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).uploadProjectArtifact(owner, project, uuid, uploadfile, path, overwrite, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProjectsV1Api - factory interface
 * @export
 */
export const ProjectsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveProject(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).archiveProject(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Invalidate run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkProject(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).bookmarkProject(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(owner: string, body: V1Project, options?: any) {
            return ProjectsV1ApiFp(configuration).createProject(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).deleteProject(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Restart run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableProjectCI(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).disableProjectCI(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Restart run with copy
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableProjectCI(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).enableProjectCI(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).getProject(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Resume run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSettings(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).getProjectSettings(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Bookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectTeams(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).getProjectTeams(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ProjectsV1ApiFp(configuration).listArchivedProjects(user, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ProjectsV1ApiFp(configuration).listBookmarkedProjects(user, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ProjectsV1ApiFp(configuration).listProjectNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ProjectsV1ApiFp(configuration).listProjects(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} project_name Required name
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProject(owner: string, project_name: string, body: V1Project, options?: any) {
            return ProjectsV1ApiFp(configuration).patchProject(owner, project_name, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Restore run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project name
         * @param {V1ProjectSettings} body Project settings body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProjectSettings(owner: string, project: string, body: V1ProjectSettings, options?: any) {
            return ProjectsV1ApiFp(configuration).patchProjectSettings(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Start run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project name
         * @param {V1ProjectTeams} body Project settings body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProjectTeams(owner: string, project: string, body: V1ProjectTeams, options?: any) {
            return ProjectsV1ApiFp(configuration).patchProjectTeams(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stop runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreProject(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).restoreProject(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Invalidate runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbookmarkProject(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).unbookmarkProject(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} project_name Required name
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject(owner: string, project_name: string, body: V1Project, options?: any) {
            return ProjectsV1ApiFp(configuration).updateProject(owner, project_name, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Archive run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project name
         * @param {V1ProjectSettings} body Project settings body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectSettings(owner: string, project: string, body: V1ProjectSettings, options?: any) {
            return ProjectsV1ApiFp(configuration).updateProjectSettings(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Unbookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project name
         * @param {V1ProjectTeams} body Project settings body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectTeams(owner: string, project: string, body: V1ProjectTeams, options?: any) {
            return ProjectsV1ApiFp(configuration).updateProjectTeams(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Upload artifact to a store via project access
         * @param {string} owner Owner of the namespace
         * @param {string} project Project having access to the store
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProjectArtifact(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any) {
            return ProjectsV1ApiFp(configuration).uploadProjectArtifact(owner, project, uuid, uploadfile, path, overwrite, options)(fetch, basePath);
        },
    };
};

/**
 * ProjectsV1Api - object-oriented interface
 * @export
 * @class ProjectsV1Api
 * @extends {BaseAPI}
 */
export class ProjectsV1Api extends BaseAPI {
    /**
     * 
     * @summary Stop run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public archiveProject(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).archiveProject(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Invalidate run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public bookmarkProject(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).bookmarkProject(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List archived runs for user
     * @param {string} owner Owner of the namespace
     * @param {V1Project} body Project body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public createProject(owner: string, body: V1Project, options?: any) {
        return ProjectsV1ApiFp(this.configuration).createProject(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public deleteProject(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).deleteProject(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Restart run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public disableProjectCI(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).disableProjectCI(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Restart run with copy
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public enableProjectCI(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).enableProjectCI(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public getProject(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).getProject(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Resume run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public getProjectSettings(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).getProjectSettings(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Bookmark run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public getProjectTeams(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).getProjectTeams(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run
     * @param {string} user User
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public listArchivedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).listArchivedProjects(user, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run
     * @param {string} user User
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public listBookmarkedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).listBookmarkedProjects(user, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List runs
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public listProjectNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).listProjectNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public listProjects(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).listProjects(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete run
     * @param {string} owner Owner of the namespace
     * @param {string} project_name Required name
     * @param {V1Project} body Project body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public patchProject(owner: string, project_name: string, body: V1Project, options?: any) {
        return ProjectsV1ApiFp(this.configuration).patchProject(owner, project_name, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Restore run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project name
     * @param {V1ProjectSettings} body Project settings body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public patchProjectSettings(owner: string, project: string, body: V1ProjectSettings, options?: any) {
        return ProjectsV1ApiFp(this.configuration).patchProjectSettings(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Start run tensorboard
     * @param {string} owner Owner of the namespace
     * @param {string} project Project name
     * @param {V1ProjectTeams} body Project settings body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public patchProjectTeams(owner: string, project: string, body: V1ProjectTeams, options?: any) {
        return ProjectsV1ApiFp(this.configuration).patchProjectTeams(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stop runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public restoreProject(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).restoreProject(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Invalidate runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public unbookmarkProject(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).unbookmarkProject(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch run
     * @param {string} owner Owner of the namespace
     * @param {string} project_name Required name
     * @param {V1Project} body Project body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public updateProject(owner: string, project_name: string, body: V1Project, options?: any) {
        return ProjectsV1ApiFp(this.configuration).updateProject(owner, project_name, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Archive run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project name
     * @param {V1ProjectSettings} body Project settings body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public updateProjectSettings(owner: string, project: string, body: V1ProjectSettings, options?: any) {
        return ProjectsV1ApiFp(this.configuration).updateProjectSettings(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Unbookmark run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project name
     * @param {V1ProjectTeams} body Project settings body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public updateProjectTeams(owner: string, project: string, body: V1ProjectTeams, options?: any) {
        return ProjectsV1ApiFp(this.configuration).updateProjectTeams(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Upload artifact to a store via project access
     * @param {string} owner Owner of the namespace
     * @param {string} project Project having access to the store
     * @param {string} uuid Unique integer identifier of the entity
     * @param {any} uploadfile The file to upload.
     * @param {string} [path] File path query params.
     * @param {boolean} [overwrite] File path query params.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public uploadProjectArtifact(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any) {
        return ProjectsV1ApiFp(this.configuration).uploadProjectArtifact(owner, project, uuid, uploadfile, path, overwrite, options)(this.fetch, this.basePath);
    }

}

/**
 * QueuesV1Api - fetch parameter creator
 * @export
 */
export const QueuesV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent that consumes the queue
         * @param {V1Queue} body Queue body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQueue(owner: string, agent: string, body: V1Queue, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createQueue.');
            }
            // verify required parameter 'agent' is not null or undefined
            if (agent === null || agent === undefined) {
                throw new RequiredError('agent','Required parameter agent was null or undefined when calling createQueue.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createQueue.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{agent}/queues`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"agent"}}`, encodeURIComponent(String(agent)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Queue" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent managing the resource
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueue(owner: string, agent: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteQueue.');
            }
            // verify required parameter 'agent' is not null or undefined
            if (agent === null || agent === undefined) {
                throw new RequiredError('agent','Required parameter agent was null or undefined when calling deleteQueue.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteQueue.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{agent}/queues/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"agent"}}`, encodeURIComponent(String(agent)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent managing the resource
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueue(owner: string, agent: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getQueue.');
            }
            // verify required parameter 'agent' is not null or undefined
            if (agent === null || agent === undefined) {
                throw new RequiredError('agent','Required parameter agent was null or undefined when calling getQueue.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getQueue.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{agent}/queues/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"agent"}}`, encodeURIComponent(String(agent)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationQueueNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listOrganizationQueueNames.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/queues/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationQueues(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listOrganizationQueues.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/queues`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent man managing the resource
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueueNames(owner: string, agent: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listQueueNames.');
            }
            // verify required parameter 'agent' is not null or undefined
            if (agent === null || agent === undefined) {
                throw new RequiredError('agent','Required parameter agent was null or undefined when calling listQueueNames.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{agent}/queues/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"agent"}}`, encodeURIComponent(String(agent)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent man managing the resource
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueues(owner: string, agent: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listQueues.');
            }
            // verify required parameter 'agent' is not null or undefined
            if (agent === null || agent === undefined) {
                throw new RequiredError('agent','Required parameter agent was null or undefined when calling listQueues.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{agent}/queues`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"agent"}}`, encodeURIComponent(String(agent)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} queue_agent Agent
         * @param {string} queue_uuid UUID
         * @param {V1Queue} body Queue body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchQueue(owner: string, queue_agent: string, queue_uuid: string, body: V1Queue, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchQueue.');
            }
            // verify required parameter 'queue_agent' is not null or undefined
            if (queue_agent === null || queue_agent === undefined) {
                throw new RequiredError('queue_agent','Required parameter queue_agent was null or undefined when calling patchQueue.');
            }
            // verify required parameter 'queue_uuid' is not null or undefined
            if (queue_uuid === null || queue_uuid === undefined) {
                throw new RequiredError('queue_uuid','Required parameter queue_uuid was null or undefined when calling patchQueue.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchQueue.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{queue.agent}/queues/{queue.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"queue.agent"}}`, encodeURIComponent(String(queue_agent)))
                .replace(`{${"queue.uuid"}}`, encodeURIComponent(String(queue_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Queue" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} queue_agent Agent
         * @param {string} queue_uuid UUID
         * @param {V1Queue} body Queue body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQueue(owner: string, queue_agent: string, queue_uuid: string, body: V1Queue, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateQueue.');
            }
            // verify required parameter 'queue_agent' is not null or undefined
            if (queue_agent === null || queue_agent === undefined) {
                throw new RequiredError('queue_agent','Required parameter queue_agent was null or undefined when calling updateQueue.');
            }
            // verify required parameter 'queue_uuid' is not null or undefined
            if (queue_uuid === null || queue_uuid === undefined) {
                throw new RequiredError('queue_uuid','Required parameter queue_uuid was null or undefined when calling updateQueue.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateQueue.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{queue.agent}/queues/{queue.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"queue.agent"}}`, encodeURIComponent(String(queue_agent)))
                .replace(`{${"queue.uuid"}}`, encodeURIComponent(String(queue_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Queue" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueuesV1Api - functional programming interface
 * @export
 */
export const QueuesV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent that consumes the queue
         * @param {V1Queue} body Queue body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQueue(owner: string, agent: string, body: V1Queue, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Agent> {
            const localVarFetchArgs = QueuesV1ApiFetchParamCreator(configuration).createQueue(owner, agent, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent managing the resource
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueue(owner: string, agent: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = QueuesV1ApiFetchParamCreator(configuration).deleteQueue(owner, agent, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent managing the resource
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueue(owner: string, agent: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Queue> {
            const localVarFetchArgs = QueuesV1ApiFetchParamCreator(configuration).getQueue(owner, agent, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationQueueNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListQueuesResponse> {
            const localVarFetchArgs = QueuesV1ApiFetchParamCreator(configuration).listOrganizationQueueNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationQueues(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListQueuesResponse> {
            const localVarFetchArgs = QueuesV1ApiFetchParamCreator(configuration).listOrganizationQueues(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent man managing the resource
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueueNames(owner: string, agent: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListQueuesResponse> {
            const localVarFetchArgs = QueuesV1ApiFetchParamCreator(configuration).listQueueNames(owner, agent, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent man managing the resource
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueues(owner: string, agent: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListQueuesResponse> {
            const localVarFetchArgs = QueuesV1ApiFetchParamCreator(configuration).listQueues(owner, agent, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} queue_agent Agent
         * @param {string} queue_uuid UUID
         * @param {V1Queue} body Queue body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchQueue(owner: string, queue_agent: string, queue_uuid: string, body: V1Queue, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Queue> {
            const localVarFetchArgs = QueuesV1ApiFetchParamCreator(configuration).patchQueue(owner, queue_agent, queue_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} queue_agent Agent
         * @param {string} queue_uuid UUID
         * @param {V1Queue} body Queue body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQueue(owner: string, queue_agent: string, queue_uuid: string, body: V1Queue, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Queue> {
            const localVarFetchArgs = QueuesV1ApiFetchParamCreator(configuration).updateQueue(owner, queue_agent, queue_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QueuesV1Api - factory interface
 * @export
 */
export const QueuesV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent that consumes the queue
         * @param {V1Queue} body Queue body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQueue(owner: string, agent: string, body: V1Queue, options?: any) {
            return QueuesV1ApiFp(configuration).createQueue(owner, agent, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent managing the resource
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueue(owner: string, agent: string, uuid: string, options?: any) {
            return QueuesV1ApiFp(configuration).deleteQueue(owner, agent, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent managing the resource
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueue(owner: string, agent: string, uuid: string, options?: any) {
            return QueuesV1ApiFp(configuration).getQueue(owner, agent, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationQueueNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return QueuesV1ApiFp(configuration).listOrganizationQueueNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationQueues(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return QueuesV1ApiFp(configuration).listOrganizationQueues(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent man managing the resource
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueueNames(owner: string, agent: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return QueuesV1ApiFp(configuration).listQueueNames(owner, agent, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent man managing the resource
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueues(owner: string, agent: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return QueuesV1ApiFp(configuration).listQueues(owner, agent, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} queue_agent Agent
         * @param {string} queue_uuid UUID
         * @param {V1Queue} body Queue body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchQueue(owner: string, queue_agent: string, queue_uuid: string, body: V1Queue, options?: any) {
            return QueuesV1ApiFp(configuration).patchQueue(owner, queue_agent, queue_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} queue_agent Agent
         * @param {string} queue_uuid UUID
         * @param {V1Queue} body Queue body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQueue(owner: string, queue_agent: string, queue_uuid: string, body: V1Queue, options?: any) {
            return QueuesV1ApiFp(configuration).updateQueue(owner, queue_agent, queue_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * QueuesV1Api - object-oriented interface
 * @export
 * @class QueuesV1Api
 * @extends {BaseAPI}
 */
export class QueuesV1Api extends BaseAPI {
    /**
     * 
     * @summary Get run
     * @param {string} owner Owner of the namespace
     * @param {string} agent Agent that consumes the queue
     * @param {V1Queue} body Queue body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesV1Api
     */
    public createQueue(owner: string, agent: string, body: V1Queue, options?: any) {
        return QueuesV1ApiFp(this.configuration).createQueue(owner, agent, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete runs
     * @param {string} owner Owner of the namespace
     * @param {string} agent Agent managing the resource
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesV1Api
     */
    public deleteQueue(owner: string, agent: string, uuid: string, options?: any) {
        return QueuesV1ApiFp(this.configuration).deleteQueue(owner, agent, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update run
     * @param {string} owner Owner of the namespace
     * @param {string} agent Agent managing the resource
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesV1Api
     */
    public getQueue(owner: string, agent: string, uuid: string, options?: any) {
        return QueuesV1ApiFp(this.configuration).getQueue(owner, agent, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesV1Api
     */
    public listOrganizationQueueNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return QueuesV1ApiFp(this.configuration).listOrganizationQueueNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List archived runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesV1Api
     */
    public listOrganizationQueues(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return QueuesV1ApiFp(this.configuration).listOrganizationQueues(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List runs
     * @param {string} owner Owner of the namespace
     * @param {string} agent Agent man managing the resource
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesV1Api
     */
    public listQueueNames(owner: string, agent: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return QueuesV1ApiFp(this.configuration).listQueueNames(owner, agent, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run
     * @param {string} owner Owner of the namespace
     * @param {string} agent Agent man managing the resource
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesV1Api
     */
    public listQueues(owner: string, agent: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return QueuesV1ApiFp(this.configuration).listQueues(owner, agent, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete run
     * @param {string} owner Owner of the namespace
     * @param {string} queue_agent Agent
     * @param {string} queue_uuid UUID
     * @param {V1Queue} body Queue body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesV1Api
     */
    public patchQueue(owner: string, queue_agent: string, queue_uuid: string, body: V1Queue, options?: any) {
        return QueuesV1ApiFp(this.configuration).patchQueue(owner, queue_agent, queue_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch run
     * @param {string} owner Owner of the namespace
     * @param {string} queue_agent Agent
     * @param {string} queue_uuid UUID
     * @param {V1Queue} body Queue body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesV1Api
     */
    public updateQueue(owner: string, queue_agent: string, queue_uuid: string, body: V1Queue, options?: any) {
        return QueuesV1ApiFp(this.configuration).updateQueue(owner, queue_agent, queue_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * RunProfilesV1Api - fetch parameter creator
 * @export
 */
export const RunProfilesV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1RunProfile} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunProfile(owner: string, body: V1RunProfile, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createRunProfile.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createRunProfile.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/run_profiles`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1RunProfile" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRunProfile(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteRunProfile.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteRunProfile.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/run_profiles/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunProfile(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRunProfile.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRunProfile.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/run_profiles/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRunProfileNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listRunProfileNames.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/run_profiles/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRunProfiles(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listRunProfiles.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/run_profiles`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} run_profile_uuid UUID
         * @param {V1RunProfile} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRunProfile(owner: string, run_profile_uuid: string, body: V1RunProfile, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchRunProfile.');
            }
            // verify required parameter 'run_profile_uuid' is not null or undefined
            if (run_profile_uuid === null || run_profile_uuid === undefined) {
                throw new RequiredError('run_profile_uuid','Required parameter run_profile_uuid was null or undefined when calling patchRunProfile.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchRunProfile.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/run_profiles/{run_profile.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"run_profile.uuid"}}`, encodeURIComponent(String(run_profile_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1RunProfile" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} run_profile_uuid UUID
         * @param {V1RunProfile} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRunProfile(owner: string, run_profile_uuid: string, body: V1RunProfile, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateRunProfile.');
            }
            // verify required parameter 'run_profile_uuid' is not null or undefined
            if (run_profile_uuid === null || run_profile_uuid === undefined) {
                throw new RequiredError('run_profile_uuid','Required parameter run_profile_uuid was null or undefined when calling updateRunProfile.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateRunProfile.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/run_profiles/{run_profile.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"run_profile.uuid"}}`, encodeURIComponent(String(run_profile_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1RunProfile" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RunProfilesV1Api - functional programming interface
 * @export
 */
export const RunProfilesV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1RunProfile} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunProfile(owner: string, body: V1RunProfile, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1RunProfile> {
            const localVarFetchArgs = RunProfilesV1ApiFetchParamCreator(configuration).createRunProfile(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRunProfile(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunProfilesV1ApiFetchParamCreator(configuration).deleteRunProfile(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunProfile(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1RunProfile> {
            const localVarFetchArgs = RunProfilesV1ApiFetchParamCreator(configuration).getRunProfile(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRunProfileNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListRunProfilesResponse> {
            const localVarFetchArgs = RunProfilesV1ApiFetchParamCreator(configuration).listRunProfileNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRunProfiles(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListRunProfilesResponse> {
            const localVarFetchArgs = RunProfilesV1ApiFetchParamCreator(configuration).listRunProfiles(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} run_profile_uuid UUID
         * @param {V1RunProfile} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRunProfile(owner: string, run_profile_uuid: string, body: V1RunProfile, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1RunProfile> {
            const localVarFetchArgs = RunProfilesV1ApiFetchParamCreator(configuration).patchRunProfile(owner, run_profile_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} run_profile_uuid UUID
         * @param {V1RunProfile} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRunProfile(owner: string, run_profile_uuid: string, body: V1RunProfile, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1RunProfile> {
            const localVarFetchArgs = RunProfilesV1ApiFetchParamCreator(configuration).updateRunProfile(owner, run_profile_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RunProfilesV1Api - factory interface
 * @export
 */
export const RunProfilesV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1RunProfile} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunProfile(owner: string, body: V1RunProfile, options?: any) {
            return RunProfilesV1ApiFp(configuration).createRunProfile(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRunProfile(owner: string, uuid: string, options?: any) {
            return RunProfilesV1ApiFp(configuration).deleteRunProfile(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunProfile(owner: string, uuid: string, options?: any) {
            return RunProfilesV1ApiFp(configuration).getRunProfile(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRunProfileNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return RunProfilesV1ApiFp(configuration).listRunProfileNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRunProfiles(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return RunProfilesV1ApiFp(configuration).listRunProfiles(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} run_profile_uuid UUID
         * @param {V1RunProfile} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRunProfile(owner: string, run_profile_uuid: string, body: V1RunProfile, options?: any) {
            return RunProfilesV1ApiFp(configuration).patchRunProfile(owner, run_profile_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} run_profile_uuid UUID
         * @param {V1RunProfile} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRunProfile(owner: string, run_profile_uuid: string, body: V1RunProfile, options?: any) {
            return RunProfilesV1ApiFp(configuration).updateRunProfile(owner, run_profile_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * RunProfilesV1Api - object-oriented interface
 * @export
 * @class RunProfilesV1Api
 * @extends {BaseAPI}
 */
export class RunProfilesV1Api extends BaseAPI {
    /**
     * 
     * @summary List runs
     * @param {string} owner Owner of the namespace
     * @param {V1RunProfile} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunProfilesV1Api
     */
    public createRunProfile(owner: string, body: V1RunProfile, options?: any) {
        return RunProfilesV1ApiFp(this.configuration).createRunProfile(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch run
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunProfilesV1Api
     */
    public deleteRunProfile(owner: string, uuid: string, options?: any) {
        return RunProfilesV1ApiFp(this.configuration).deleteRunProfile(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunProfilesV1Api
     */
    public getRunProfile(owner: string, uuid: string, options?: any) {
        return RunProfilesV1ApiFp(this.configuration).getRunProfile(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunProfilesV1Api
     */
    public listRunProfileNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return RunProfilesV1ApiFp(this.configuration).listRunProfileNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List archived runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunProfilesV1Api
     */
    public listRunProfiles(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return RunProfilesV1ApiFp(this.configuration).listRunProfiles(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update run
     * @param {string} owner Owner of the namespace
     * @param {string} run_profile_uuid UUID
     * @param {V1RunProfile} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunProfilesV1Api
     */
    public patchRunProfile(owner: string, run_profile_uuid: string, body: V1RunProfile, options?: any) {
        return RunProfilesV1ApiFp(this.configuration).patchRunProfile(owner, run_profile_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run
     * @param {string} owner Owner of the namespace
     * @param {string} run_profile_uuid UUID
     * @param {V1RunProfile} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunProfilesV1Api
     */
    public updateRunProfile(owner: string, run_profile_uuid: string, body: V1RunProfile, options?: any) {
        return RunProfilesV1ApiFp(this.configuration).updateRunProfile(owner, run_profile_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * RunsV1Api - fetch parameter creator
 * @export
 */
export const RunsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Archive run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling archiveRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling archiveRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling archiveRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/archive`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Bookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling bookmarkRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling bookmarkRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling bookmarkRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/bookmark`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restart run with copy
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options: any = {}): FetchArgs {
            // verify required parameter 'entity_owner' is not null or undefined
            if (entity_owner === null || entity_owner === undefined) {
                throw new RequiredError('entity_owner','Required parameter entity_owner was null or undefined when calling copyRun.');
            }
            // verify required parameter 'entity_project' is not null or undefined
            if (entity_project === null || entity_project === undefined) {
                throw new RequiredError('entity_project','Required parameter entity_project was null or undefined when calling copyRun.');
            }
            // verify required parameter 'entity_uuid' is not null or undefined
            if (entity_uuid === null || entity_uuid === undefined) {
                throw new RequiredError('entity_uuid','Required parameter entity_uuid was null or undefined when calling copyRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling copyRun.');
            }
            const localVarPath = `/api/v1/{entity.owner}/{entity.project}/runs/{entity.uuid}/copy`
                .replace(`{${"entity.owner"}}`, encodeURIComponent(String(entity_owner)))
                .replace(`{${"entity.project"}}`, encodeURIComponent(String(entity_project)))
                .replace(`{${"entity.uuid"}}`, encodeURIComponent(String(entity_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Run" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRun(owner: string, project: string, body: V1Run, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling createRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Run" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run code ref
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1CodeRef} body Code ref object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunCodeRef(entity_owner: string, entity_project: string, entity_uuid: string, body: V1CodeRef, options: any = {}): FetchArgs {
            // verify required parameter 'entity_owner' is not null or undefined
            if (entity_owner === null || entity_owner === undefined) {
                throw new RequiredError('entity_owner','Required parameter entity_owner was null or undefined when calling createRunCodeRef.');
            }
            // verify required parameter 'entity_project' is not null or undefined
            if (entity_project === null || entity_project === undefined) {
                throw new RequiredError('entity_project','Required parameter entity_project was null or undefined when calling createRunCodeRef.');
            }
            // verify required parameter 'entity_uuid' is not null or undefined
            if (entity_uuid === null || entity_uuid === undefined) {
                throw new RequiredError('entity_uuid','Required parameter entity_uuid was null or undefined when calling createRunCodeRef.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createRunCodeRef.');
            }
            const localVarPath = `/api/v1/{entity.owner}/{entity.project}/runs/{entity.uuid}/coderefs`
                .replace(`{${"entity.owner"}}`, encodeURIComponent(String(entity_owner)))
                .replace(`{${"entity.project"}}`, encodeURIComponent(String(entity_project)))
                .replace(`{${"entity.uuid"}}`, encodeURIComponent(String(entity_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1CodeRef" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1EntityStatusBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunStatus(owner: string, project: string, uuid: string, body: V1EntityStatusBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createRunStatus.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling createRunStatus.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling createRunStatus.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createRunStatus.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/statuses`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1EntityStatusBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling deleteRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRuns(owner: string, project: string, body: V1Uuids, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteRuns.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling deleteRuns.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling deleteRuns.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/delete`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Uuids" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run artifacts list
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {string} [path] Artifact filepath.
         * @param {number} [step] Artifact logging step.
         * @param {string} [kind] Artifact kind.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunArtifactsTree(owner: string, project: string, uuid: string, path?: string, step?: number, kind?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRunArtifactsTree.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getRunArtifactsTree.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRunArtifactsTree.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/artifacts/tree`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (step !== undefined) {
                localVarQueryParameter['step'] = step;
            }

            if (kind !== undefined) {
                localVarQueryParameter['kind'] = kind;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run logs get file
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {string} [path] Artifact filepath.
         * @param {number} [step] Artifact logging step.
         * @param {string} [type] Artifact type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunLogsFile(owner: string, project: string, uuid: string, path?: string, step?: number, type?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRunLogsFile.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getRunLogsFile.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRunLogsFile.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/logs/file`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (step !== undefined) {
                localVarQueryParameter['step'] = step;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run logs list
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {string} [path] Artifact filepath.
         * @param {number} [step] Artifact logging step.
         * @param {string} [kind] Artifact kind.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunLogsTree(owner: string, project: string, uuid: string, path?: string, step?: number, kind?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRunLogsTree.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getRunLogsTree.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRunLogsTree.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/logs/tree`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (step !== undefined) {
                localVarQueryParameter['step'] = step;
            }

            if (kind !== undefined) {
                localVarQueryParameter['kind'] = kind;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Run settings
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunSettings(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRunSettings.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getRunSettings.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRunSettings.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/settings`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunStatuses(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRunStatuses.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getRunStatuses.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRunStatuses.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/statuses`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Impersonate run token
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        impersonateToken(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling impersonateToken.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling impersonateToken.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling impersonateToken.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/impersonate`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invalidate run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1ProjectEntityResourceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateRun(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling invalidateRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling invalidateRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling invalidateRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling invalidateRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/invalidate`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ProjectEntityResourceRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invalidate runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateRuns(owner: string, project: string, body: V1Uuids, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling invalidateRuns.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling invalidateRuns.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling invalidateRuns.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/invalidate`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Uuids" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling listArchivedRuns.');
            }
            const localVarPath = `/api/v1/archives/{user}/runs`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling listBookmarkedRuns.');
            }
            const localVarPath = `/api/v1/bookmarks/{user}/runs`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuns(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listRuns.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling listRuns.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} run_uuid UUID
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRun(owner: string, project: string, run_uuid: string, body: V1Run, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling patchRun.');
            }
            // verify required parameter 'run_uuid' is not null or undefined
            if (run_uuid === null || run_uuid === undefined) {
                throw new RequiredError('run_uuid','Required parameter run_uuid was null or undefined when calling patchRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{run.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"run.uuid"}}`, encodeURIComponent(String(run_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Run" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restart run
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options: any = {}): FetchArgs {
            // verify required parameter 'entity_owner' is not null or undefined
            if (entity_owner === null || entity_owner === undefined) {
                throw new RequiredError('entity_owner','Required parameter entity_owner was null or undefined when calling restartRun.');
            }
            // verify required parameter 'entity_project' is not null or undefined
            if (entity_project === null || entity_project === undefined) {
                throw new RequiredError('entity_project','Required parameter entity_project was null or undefined when calling restartRun.');
            }
            // verify required parameter 'entity_uuid' is not null or undefined
            if (entity_uuid === null || entity_uuid === undefined) {
                throw new RequiredError('entity_uuid','Required parameter entity_uuid was null or undefined when calling restartRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling restartRun.');
            }
            const localVarPath = `/api/v1/{entity.owner}/{entity.project}/runs/{entity.uuid}/restart`
                .replace(`{${"entity.owner"}}`, encodeURIComponent(String(entity_owner)))
                .replace(`{${"entity.project"}}`, encodeURIComponent(String(entity_project)))
                .replace(`{${"entity.uuid"}}`, encodeURIComponent(String(entity_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Run" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling restoreRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling restoreRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling restoreRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/restore`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resume run
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options: any = {}): FetchArgs {
            // verify required parameter 'entity_owner' is not null or undefined
            if (entity_owner === null || entity_owner === undefined) {
                throw new RequiredError('entity_owner','Required parameter entity_owner was null or undefined when calling resumeRun.');
            }
            // verify required parameter 'entity_project' is not null or undefined
            if (entity_project === null || entity_project === undefined) {
                throw new RequiredError('entity_project','Required parameter entity_project was null or undefined when calling resumeRun.');
            }
            // verify required parameter 'entity_uuid' is not null or undefined
            if (entity_uuid === null || entity_uuid === undefined) {
                throw new RequiredError('entity_uuid','Required parameter entity_uuid was null or undefined when calling resumeRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling resumeRun.');
            }
            const localVarPath = `/api/v1/{entity.owner}/{entity.project}/runs/{entity.uuid}/resume`
                .replace(`{${"entity.owner"}}`, encodeURIComponent(String(entity_owner)))
                .replace(`{${"entity.project"}}`, encodeURIComponent(String(entity_project)))
                .replace(`{${"entity.uuid"}}`, encodeURIComponent(String(entity_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Run" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1ProjectEntityResourceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRunTensorboard(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling startRunTensorboard.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling startRunTensorboard.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling startRunTensorboard.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling startRunTensorboard.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/tensorboard/start`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ProjectEntityResourceRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling stopRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling stopRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling stopRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/stop`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRunTensorboard(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling stopRunTensorboard.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling stopRunTensorboard.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling stopRunTensorboard.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/tensorboard/stop`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRuns(owner: string, project: string, body: V1Uuids, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling stopRuns.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling stopRuns.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling stopRuns.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/stop`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Uuids" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unbookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbookmarkRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling unbookmarkRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling unbookmarkRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling unbookmarkRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/unbookmark`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} run_uuid UUID
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRun(owner: string, project: string, run_uuid: string, body: V1Run, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling updateRun.');
            }
            // verify required parameter 'run_uuid' is not null or undefined
            if (run_uuid === null || run_uuid === undefined) {
                throw new RequiredError('run_uuid','Required parameter run_uuid was null or undefined when calling updateRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{run.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"run.uuid"}}`, encodeURIComponent(String(run_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Run" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload an artifact file to a store via run access
         * @param {string} owner Owner of the namespace
         * @param {string} project Project having access to the store
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRunArtifact(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling uploadRunArtifact.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling uploadRunArtifact.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling uploadRunArtifact.');
            }
            // verify required parameter 'uploadfile' is not null or undefined
            if (uploadfile === null || uploadfile === undefined) {
                throw new RequiredError('uploadfile','Required parameter uploadfile was null or undefined when calling uploadRunArtifact.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/artifacts/upload`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (overwrite !== undefined) {
                localVarQueryParameter['overwrite'] = overwrite;
            }

            if (uploadfile !== undefined) {
                localVarFormParams.set('uploadfile', uploadfile as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload a logs file to a store via run access
         * @param {string} owner Owner of the namespace
         * @param {string} project Project having access to the store
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRunLogs(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling uploadRunLogs.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling uploadRunLogs.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling uploadRunLogs.');
            }
            // verify required parameter 'uploadfile' is not null or undefined
            if (uploadfile === null || uploadfile === undefined) {
                throw new RequiredError('uploadfile','Required parameter uploadfile was null or undefined when calling uploadRunLogs.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/logs/upload`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (overwrite !== undefined) {
                localVarQueryParameter['overwrite'] = overwrite;
            }

            if (uploadfile !== undefined) {
                localVarFormParams.set('uploadfile', uploadfile as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RunsV1Api - functional programming interface
 * @export
 */
export const RunsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Archive run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).archiveRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Bookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).bookmarkRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Restart run with copy
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).copyRun(entity_owner, entity_project, entity_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRun(owner: string, project: string, body: V1Run, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).createRun(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run code ref
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1CodeRef} body Code ref object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunCodeRef(entity_owner: string, entity_project: string, entity_uuid: string, body: V1CodeRef, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).createRunCodeRef(entity_owner, entity_project, entity_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1EntityStatusBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunStatus(owner: string, project: string, uuid: string, body: V1EntityStatusBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Status> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).createRunStatus(owner, project, uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).deleteRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRuns(owner: string, project: string, body: V1Uuids, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).deleteRuns(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).getRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run artifacts list
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {string} [path] Artifact filepath.
         * @param {number} [step] Artifact logging step.
         * @param {string} [kind] Artifact kind.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunArtifactsTree(owner: string, project: string, uuid: string, path?: string, step?: number, kind?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ArtifactTreeResponse> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).getRunArtifactsTree(owner, project, uuid, path, step, kind, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run logs get file
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {string} [path] Artifact filepath.
         * @param {number} [step] Artifact logging step.
         * @param {string} [type] Artifact type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunLogsFile(owner: string, project: string, uuid: string, path?: string, step?: number, type?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).getRunLogsFile(owner, project, uuid, path, step, type, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run logs list
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {string} [path] Artifact filepath.
         * @param {number} [step] Artifact logging step.
         * @param {string} [kind] Artifact kind.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunLogsTree(owner: string, project: string, uuid: string, path?: string, step?: number, kind?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ArtifactTreeResponse> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).getRunLogsTree(owner, project, uuid, path, step, kind, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get Run settings
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunSettings(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1RunSettings> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).getRunSettings(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunStatuses(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Status> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).getRunStatuses(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Impersonate run token
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        impersonateToken(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Auth> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).impersonateToken(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Invalidate run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1ProjectEntityResourceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateRun(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).invalidateRun(owner, project, uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Invalidate runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateRuns(owner: string, project: string, body: V1Uuids, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).invalidateRuns(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListRunsResponse> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).listArchivedRuns(user, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListRunsResponse> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).listBookmarkedRuns(user, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuns(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListRunsResponse> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).listRuns(owner, project, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} run_uuid UUID
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRun(owner: string, project: string, run_uuid: string, body: V1Run, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).patchRun(owner, project, run_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Restart run
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).restartRun(entity_owner, entity_project, entity_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Restore run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).restoreRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Resume run
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).resumeRun(entity_owner, entity_project, entity_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Start run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1ProjectEntityResourceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRunTensorboard(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).startRunTensorboard(owner, project, uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).stopRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stop run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRunTensorboard(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).stopRunTensorboard(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stop runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRuns(owner: string, project: string, body: V1Uuids, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).stopRuns(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Unbookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbookmarkRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).unbookmarkRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} run_uuid UUID
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRun(owner: string, project: string, run_uuid: string, body: V1Run, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).updateRun(owner, project, run_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Upload an artifact file to a store via run access
         * @param {string} owner Owner of the namespace
         * @param {string} project Project having access to the store
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRunArtifact(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).uploadRunArtifact(owner, project, uuid, uploadfile, path, overwrite, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Upload a logs file to a store via run access
         * @param {string} owner Owner of the namespace
         * @param {string} project Project having access to the store
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRunLogs(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).uploadRunLogs(owner, project, uuid, uploadfile, path, overwrite, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RunsV1Api - factory interface
 * @export
 */
export const RunsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Archive run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveRun(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).archiveRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Bookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkRun(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).bookmarkRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Restart run with copy
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any) {
            return RunsV1ApiFp(configuration).copyRun(entity_owner, entity_project, entity_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRun(owner: string, project: string, body: V1Run, options?: any) {
            return RunsV1ApiFp(configuration).createRun(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run code ref
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1CodeRef} body Code ref object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunCodeRef(entity_owner: string, entity_project: string, entity_uuid: string, body: V1CodeRef, options?: any) {
            return RunsV1ApiFp(configuration).createRunCodeRef(entity_owner, entity_project, entity_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1EntityStatusBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunStatus(owner: string, project: string, uuid: string, body: V1EntityStatusBodyRequest, options?: any) {
            return RunsV1ApiFp(configuration).createRunStatus(owner, project, uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRun(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).deleteRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRuns(owner: string, project: string, body: V1Uuids, options?: any) {
            return RunsV1ApiFp(configuration).deleteRuns(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRun(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).getRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run artifacts list
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {string} [path] Artifact filepath.
         * @param {number} [step] Artifact logging step.
         * @param {string} [kind] Artifact kind.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunArtifactsTree(owner: string, project: string, uuid: string, path?: string, step?: number, kind?: string, options?: any) {
            return RunsV1ApiFp(configuration).getRunArtifactsTree(owner, project, uuid, path, step, kind, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run logs get file
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {string} [path] Artifact filepath.
         * @param {number} [step] Artifact logging step.
         * @param {string} [type] Artifact type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunLogsFile(owner: string, project: string, uuid: string, path?: string, step?: number, type?: string, options?: any) {
            return RunsV1ApiFp(configuration).getRunLogsFile(owner, project, uuid, path, step, type, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run logs list
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {string} [path] Artifact filepath.
         * @param {number} [step] Artifact logging step.
         * @param {string} [kind] Artifact kind.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunLogsTree(owner: string, project: string, uuid: string, path?: string, step?: number, kind?: string, options?: any) {
            return RunsV1ApiFp(configuration).getRunLogsTree(owner, project, uuid, path, step, kind, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get Run settings
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunSettings(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).getRunSettings(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunStatuses(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).getRunStatuses(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Impersonate run token
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        impersonateToken(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).impersonateToken(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Invalidate run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1ProjectEntityResourceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateRun(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options?: any) {
            return RunsV1ApiFp(configuration).invalidateRun(owner, project, uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Invalidate runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateRuns(owner: string, project: string, body: V1Uuids, options?: any) {
            return RunsV1ApiFp(configuration).invalidateRuns(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return RunsV1ApiFp(configuration).listArchivedRuns(user, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return RunsV1ApiFp(configuration).listBookmarkedRuns(user, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuns(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return RunsV1ApiFp(configuration).listRuns(owner, project, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} run_uuid UUID
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRun(owner: string, project: string, run_uuid: string, body: V1Run, options?: any) {
            return RunsV1ApiFp(configuration).patchRun(owner, project, run_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Restart run
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any) {
            return RunsV1ApiFp(configuration).restartRun(entity_owner, entity_project, entity_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Restore run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreRun(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).restoreRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Resume run
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any) {
            return RunsV1ApiFp(configuration).resumeRun(entity_owner, entity_project, entity_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Start run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1ProjectEntityResourceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRunTensorboard(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options?: any) {
            return RunsV1ApiFp(configuration).startRunTensorboard(owner, project, uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRun(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).stopRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stop run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRunTensorboard(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).stopRunTensorboard(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stop runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRuns(owner: string, project: string, body: V1Uuids, options?: any) {
            return RunsV1ApiFp(configuration).stopRuns(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Unbookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbookmarkRun(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).unbookmarkRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} run_uuid UUID
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRun(owner: string, project: string, run_uuid: string, body: V1Run, options?: any) {
            return RunsV1ApiFp(configuration).updateRun(owner, project, run_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Upload an artifact file to a store via run access
         * @param {string} owner Owner of the namespace
         * @param {string} project Project having access to the store
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRunArtifact(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any) {
            return RunsV1ApiFp(configuration).uploadRunArtifact(owner, project, uuid, uploadfile, path, overwrite, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Upload a logs file to a store via run access
         * @param {string} owner Owner of the namespace
         * @param {string} project Project having access to the store
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRunLogs(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any) {
            return RunsV1ApiFp(configuration).uploadRunLogs(owner, project, uuid, uploadfile, path, overwrite, options)(fetch, basePath);
        },
    };
};

/**
 * RunsV1Api - object-oriented interface
 * @export
 * @class RunsV1Api
 * @extends {BaseAPI}
 */
export class RunsV1Api extends BaseAPI {
    /**
     * 
     * @summary Archive run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public archiveRun(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).archiveRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Bookmark run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public bookmarkRun(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).bookmarkRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Restart run with copy
     * @param {string} entity_owner Owner of the namespace
     * @param {string} entity_project Project where the experiement will be assigned
     * @param {string} entity_uuid Unique integer identifier of the entity
     * @param {V1Run} body Run object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public copyRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any) {
        return RunsV1ApiFp(this.configuration).copyRun(entity_owner, entity_project, entity_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {V1Run} body Run object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public createRun(owner: string, project: string, body: V1Run, options?: any) {
        return RunsV1ApiFp(this.configuration).createRun(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run code ref
     * @param {string} entity_owner Owner of the namespace
     * @param {string} entity_project Project where the experiement will be assigned
     * @param {string} entity_uuid Unique integer identifier of the entity
     * @param {V1CodeRef} body Code ref object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public createRunCodeRef(entity_owner: string, entity_project: string, entity_uuid: string, body: V1CodeRef, options?: any) {
        return RunsV1ApiFp(this.configuration).createRunCodeRef(entity_owner, entity_project, entity_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run status
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {V1EntityStatusBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public createRunStatus(owner: string, project: string, uuid: string, body: V1EntityStatusBodyRequest, options?: any) {
        return RunsV1ApiFp(this.configuration).createRunStatus(owner, project, uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public deleteRun(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).deleteRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {V1Uuids} body Uuids of the entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public deleteRuns(owner: string, project: string, body: V1Uuids, options?: any) {
        return RunsV1ApiFp(this.configuration).deleteRuns(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public getRun(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).getRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run artifacts list
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {string} [path] Artifact filepath.
     * @param {number} [step] Artifact logging step.
     * @param {string} [kind] Artifact kind.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public getRunArtifactsTree(owner: string, project: string, uuid: string, path?: string, step?: number, kind?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).getRunArtifactsTree(owner, project, uuid, path, step, kind, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run logs get file
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {string} [path] Artifact filepath.
     * @param {number} [step] Artifact logging step.
     * @param {string} [type] Artifact type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public getRunLogsFile(owner: string, project: string, uuid: string, path?: string, step?: number, type?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).getRunLogsFile(owner, project, uuid, path, step, type, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run logs list
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {string} [path] Artifact filepath.
     * @param {number} [step] Artifact logging step.
     * @param {string} [kind] Artifact kind.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public getRunLogsTree(owner: string, project: string, uuid: string, path?: string, step?: number, kind?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).getRunLogsTree(owner, project, uuid, path, step, kind, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get Run settings
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public getRunSettings(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).getRunSettings(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run status
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public getRunStatuses(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).getRunStatuses(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Impersonate run token
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public impersonateToken(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).impersonateToken(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Invalidate run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {V1ProjectEntityResourceRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public invalidateRun(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options?: any) {
        return RunsV1ApiFp(this.configuration).invalidateRun(owner, project, uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Invalidate runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {V1Uuids} body Uuids of the entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public invalidateRuns(owner: string, project: string, body: V1Uuids, options?: any) {
        return RunsV1ApiFp(this.configuration).invalidateRuns(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List archived runs for user
     * @param {string} user User
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public listArchivedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).listArchivedRuns(user, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked runs for user
     * @param {string} user User
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public listBookmarkedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).listBookmarkedRuns(user, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public listRuns(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).listRuns(owner, project, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} run_uuid UUID
     * @param {V1Run} body Run object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public patchRun(owner: string, project: string, run_uuid: string, body: V1Run, options?: any) {
        return RunsV1ApiFp(this.configuration).patchRun(owner, project, run_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Restart run
     * @param {string} entity_owner Owner of the namespace
     * @param {string} entity_project Project where the experiement will be assigned
     * @param {string} entity_uuid Unique integer identifier of the entity
     * @param {V1Run} body Run object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public restartRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any) {
        return RunsV1ApiFp(this.configuration).restartRun(entity_owner, entity_project, entity_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Restore run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public restoreRun(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).restoreRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Resume run
     * @param {string} entity_owner Owner of the namespace
     * @param {string} entity_project Project where the experiement will be assigned
     * @param {string} entity_uuid Unique integer identifier of the entity
     * @param {V1Run} body Run object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public resumeRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any) {
        return RunsV1ApiFp(this.configuration).resumeRun(entity_owner, entity_project, entity_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Start run tensorboard
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {V1ProjectEntityResourceRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public startRunTensorboard(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options?: any) {
        return RunsV1ApiFp(this.configuration).startRunTensorboard(owner, project, uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stop run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public stopRun(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).stopRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stop run tensorboard
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public stopRunTensorboard(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).stopRunTensorboard(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stop runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {V1Uuids} body Uuids of the entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public stopRuns(owner: string, project: string, body: V1Uuids, options?: any) {
        return RunsV1ApiFp(this.configuration).stopRuns(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Unbookmark run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public unbookmarkRun(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).unbookmarkRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} run_uuid UUID
     * @param {V1Run} body Run object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public updateRun(owner: string, project: string, run_uuid: string, body: V1Run, options?: any) {
        return RunsV1ApiFp(this.configuration).updateRun(owner, project, run_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Upload an artifact file to a store via run access
     * @param {string} owner Owner of the namespace
     * @param {string} project Project having access to the store
     * @param {string} uuid Unique integer identifier of the entity
     * @param {any} uploadfile The file to upload.
     * @param {string} [path] File path query params.
     * @param {boolean} [overwrite] File path query params.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public uploadRunArtifact(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any) {
        return RunsV1ApiFp(this.configuration).uploadRunArtifact(owner, project, uuid, uploadfile, path, overwrite, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Upload a logs file to a store via run access
     * @param {string} owner Owner of the namespace
     * @param {string} project Project having access to the store
     * @param {string} uuid Unique integer identifier of the entity
     * @param {any} uploadfile The file to upload.
     * @param {string} [path] File path query params.
     * @param {boolean} [overwrite] File path query params.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public uploadRunLogs(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any) {
        return RunsV1ApiFp(this.configuration).uploadRunLogs(owner, project, uuid, uploadfile, path, overwrite, options)(this.fetch, this.basePath);
    }

}

/**
 * SchemasV1Api - fetch parameter creator
 * @export
 */
export const SchemasV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        noOp(options: any = {}): FetchArgs {
            const localVarPath = `/schemas`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchemasV1Api - functional programming interface
 * @export
 */
export const SchemasV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        noOp(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Schemas> {
            const localVarFetchArgs = SchemasV1ApiFetchParamCreator(configuration).noOp(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SchemasV1Api - factory interface
 * @export
 */
export const SchemasV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        noOp(options?: any) {
            return SchemasV1ApiFp(configuration).noOp(options)(fetch, basePath);
        },
    };
};

/**
 * SchemasV1Api - object-oriented interface
 * @export
 * @class SchemasV1Api
 * @extends {BaseAPI}
 */
export class SchemasV1Api extends BaseAPI {
    /**
     * 
     * @summary List bookmarked runs for user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasV1Api
     */
    public noOp(options?: any) {
        return SchemasV1ApiFp(this.configuration).noOp(options)(this.fetch, this.basePath);
    }

}

/**
 * SearchesV1Api - fetch parameter creator
 * @export
 */
export const SearchesV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSearch(owner: string, body: V1Search, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createSearch.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createSearch.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/searches`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Search" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSearch(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteSearch.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteSearch.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/searches/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearch(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getSearch.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getSearch.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/searches/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSearchNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listSearchNames.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/searches/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSearches(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listSearches.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/searches`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} search_uuid UUID
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSearch(owner: string, search_uuid: string, body: V1Search, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchSearch.');
            }
            // verify required parameter 'search_uuid' is not null or undefined
            if (search_uuid === null || search_uuid === undefined) {
                throw new RequiredError('search_uuid','Required parameter search_uuid was null or undefined when calling patchSearch.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchSearch.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/searches/{search.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"search.uuid"}}`, encodeURIComponent(String(search_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Search" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} search_uuid UUID
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSearch(owner: string, search_uuid: string, body: V1Search, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateSearch.');
            }
            // verify required parameter 'search_uuid' is not null or undefined
            if (search_uuid === null || search_uuid === undefined) {
                throw new RequiredError('search_uuid','Required parameter search_uuid was null or undefined when calling updateSearch.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateSearch.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/searches/{search.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"search.uuid"}}`, encodeURIComponent(String(search_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Search" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchesV1Api - functional programming interface
 * @export
 */
export const SearchesV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSearch(owner: string, body: V1Search, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Search> {
            const localVarFetchArgs = SearchesV1ApiFetchParamCreator(configuration).createSearch(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSearch(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SearchesV1ApiFetchParamCreator(configuration).deleteSearch(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearch(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Search> {
            const localVarFetchArgs = SearchesV1ApiFetchParamCreator(configuration).getSearch(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSearchNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListSearchesResponse> {
            const localVarFetchArgs = SearchesV1ApiFetchParamCreator(configuration).listSearchNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSearches(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListSearchesResponse> {
            const localVarFetchArgs = SearchesV1ApiFetchParamCreator(configuration).listSearches(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} search_uuid UUID
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSearch(owner: string, search_uuid: string, body: V1Search, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Search> {
            const localVarFetchArgs = SearchesV1ApiFetchParamCreator(configuration).patchSearch(owner, search_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} search_uuid UUID
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSearch(owner: string, search_uuid: string, body: V1Search, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Search> {
            const localVarFetchArgs = SearchesV1ApiFetchParamCreator(configuration).updateSearch(owner, search_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SearchesV1Api - factory interface
 * @export
 */
export const SearchesV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSearch(owner: string, body: V1Search, options?: any) {
            return SearchesV1ApiFp(configuration).createSearch(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSearch(owner: string, uuid: string, options?: any) {
            return SearchesV1ApiFp(configuration).deleteSearch(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearch(owner: string, uuid: string, options?: any) {
            return SearchesV1ApiFp(configuration).getSearch(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSearchNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return SearchesV1ApiFp(configuration).listSearchNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSearches(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return SearchesV1ApiFp(configuration).listSearches(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} search_uuid UUID
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSearch(owner: string, search_uuid: string, body: V1Search, options?: any) {
            return SearchesV1ApiFp(configuration).patchSearch(owner, search_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} search_uuid UUID
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSearch(owner: string, search_uuid: string, body: V1Search, options?: any) {
            return SearchesV1ApiFp(configuration).updateSearch(owner, search_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * SearchesV1Api - object-oriented interface
 * @export
 * @class SearchesV1Api
 * @extends {BaseAPI}
 */
export class SearchesV1Api extends BaseAPI {
    /**
     * 
     * @summary List runs
     * @param {string} owner Owner of the namespace
     * @param {V1Search} body Search body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchesV1Api
     */
    public createSearch(owner: string, body: V1Search, options?: any) {
        return SearchesV1ApiFp(this.configuration).createSearch(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch run
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchesV1Api
     */
    public deleteSearch(owner: string, uuid: string, options?: any) {
        return SearchesV1ApiFp(this.configuration).deleteSearch(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchesV1Api
     */
    public getSearch(owner: string, uuid: string, options?: any) {
        return SearchesV1ApiFp(this.configuration).getSearch(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchesV1Api
     */
    public listSearchNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return SearchesV1ApiFp(this.configuration).listSearchNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List archived runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchesV1Api
     */
    public listSearches(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return SearchesV1ApiFp(this.configuration).listSearches(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update run
     * @param {string} owner Owner of the namespace
     * @param {string} search_uuid UUID
     * @param {V1Search} body Search body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchesV1Api
     */
    public patchSearch(owner: string, search_uuid: string, body: V1Search, options?: any) {
        return SearchesV1ApiFp(this.configuration).patchSearch(owner, search_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run
     * @param {string} owner Owner of the namespace
     * @param {string} search_uuid UUID
     * @param {V1Search} body Search body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchesV1Api
     */
    public updateSearch(owner: string, search_uuid: string, body: V1Search, options?: any) {
        return SearchesV1ApiFp(this.configuration).updateSearch(owner, search_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * TeamsV1Api - fetch parameter creator
 * @export
 */
export const TeamsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1Team} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam(owner: string, body: V1Team, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createTeam.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createTeam.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Team" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {string} team Team
         * @param {V1TeamMember} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeamMember(owner: string, team: string, body: V1TeamMember, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createTeamMember.');
            }
            // verify required parameter 'team' is not null or undefined
            if (team === null || team === undefined) {
                throw new RequiredError('team','Required parameter team was null or undefined when calling createTeamMember.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createTeamMember.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams/{team}/members`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1TeamMember" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam(owner: string, team: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteTeam.');
            }
            // verify required parameter 'team' is not null or undefined
            if (team === null || team === undefined) {
                throw new RequiredError('team','Required parameter team was null or undefined when calling deleteTeam.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams/{team}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invalidate runs
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {string} user Member under team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeamMember(owner: string, team: string, user: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteTeamMember.');
            }
            // verify required parameter 'team' is not null or undefined
            if (team === null || team === undefined) {
                throw new RequiredError('team','Required parameter team was null or undefined when calling deleteTeamMember.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling deleteTeamMember.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams/{team}/members/{user}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam(owner: string, team: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getTeam.');
            }
            // verify required parameter 'team' is not null or undefined
            if (team === null || team === undefined) {
                throw new RequiredError('team','Required parameter team was null or undefined when calling getTeam.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams/{team}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {string} user Member under team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMember(owner: string, team: string, user: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getTeamMember.');
            }
            // verify required parameter 'team' is not null or undefined
            if (team === null || team === undefined) {
                throw new RequiredError('team','Required parameter team was null or undefined when calling getTeamMember.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling getTeamMember.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams/{team}/members/{user}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamMembers(owner: string, team: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listTeamMembers.');
            }
            // verify required parameter 'team' is not null or undefined
            if (team === null || team === undefined) {
                throw new RequiredError('team','Required parameter team was null or undefined when calling listTeamMembers.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams/{team}/members`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listTeamNames.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeams(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listTeams.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} team_name Name
         * @param {V1Team} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTeam(owner: string, team_name: string, body: V1Team, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchTeam.');
            }
            // verify required parameter 'team_name' is not null or undefined
            if (team_name === null || team_name === undefined) {
                throw new RequiredError('team_name','Required parameter team_name was null or undefined when calling patchTeam.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchTeam.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams/{team.name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"team.name"}}`, encodeURIComponent(String(team_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Team" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invalidate run
         * @param {string} owner Owner of the namespace
         * @param {string} team Team
         * @param {string} member_user User
         * @param {V1TeamMember} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTeamMember(owner: string, team: string, member_user: string, body: V1TeamMember, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchTeamMember.');
            }
            // verify required parameter 'team' is not null or undefined
            if (team === null || team === undefined) {
                throw new RequiredError('team','Required parameter team was null or undefined when calling patchTeamMember.');
            }
            // verify required parameter 'member_user' is not null or undefined
            if (member_user === null || member_user === undefined) {
                throw new RequiredError('member_user','Required parameter member_user was null or undefined when calling patchTeamMember.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchTeamMember.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams/{team}/members/{member.user}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)))
                .replace(`{${"member.user"}}`, encodeURIComponent(String(member_user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1TeamMember" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} team_name Name
         * @param {V1Team} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam(owner: string, team_name: string, body: V1Team, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateTeam.');
            }
            // verify required parameter 'team_name' is not null or undefined
            if (team_name === null || team_name === undefined) {
                throw new RequiredError('team_name','Required parameter team_name was null or undefined when calling updateTeam.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateTeam.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams/{team.name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"team.name"}}`, encodeURIComponent(String(team_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Team" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop runs
         * @param {string} owner Owner of the namespace
         * @param {string} team Team
         * @param {string} member_user User
         * @param {V1TeamMember} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeamMember(owner: string, team: string, member_user: string, body: V1TeamMember, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateTeamMember.');
            }
            // verify required parameter 'team' is not null or undefined
            if (team === null || team === undefined) {
                throw new RequiredError('team','Required parameter team was null or undefined when calling updateTeamMember.');
            }
            // verify required parameter 'member_user' is not null or undefined
            if (member_user === null || member_user === undefined) {
                throw new RequiredError('member_user','Required parameter member_user was null or undefined when calling updateTeamMember.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateTeamMember.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams/{team}/members/{member.user}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)))
                .replace(`{${"member.user"}}`, encodeURIComponent(String(member_user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1TeamMember" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamsV1Api - functional programming interface
 * @export
 */
export const TeamsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1Team} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam(owner: string, body: V1Team, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Team> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).createTeam(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {string} team Team
         * @param {V1TeamMember} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeamMember(owner: string, team: string, body: V1TeamMember, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1TeamMember> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).createTeamMember(owner, team, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam(owner: string, team: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).deleteTeam(owner, team, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Invalidate runs
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {string} user Member under team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeamMember(owner: string, team: string, user: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).deleteTeamMember(owner, team, user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam(owner: string, team: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Team> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).getTeam(owner, team, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {string} user Member under team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMember(owner: string, team: string, user: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1TeamMember> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).getTeamMember(owner, team, user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamMembers(owner: string, team: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListTeamMembersResponse> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).listTeamMembers(owner, team, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListTeamsResponse> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).listTeamNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeams(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListTeamsResponse> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).listTeams(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} team_name Name
         * @param {V1Team} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTeam(owner: string, team_name: string, body: V1Team, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Team> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).patchTeam(owner, team_name, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Invalidate run
         * @param {string} owner Owner of the namespace
         * @param {string} team Team
         * @param {string} member_user User
         * @param {V1TeamMember} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTeamMember(owner: string, team: string, member_user: string, body: V1TeamMember, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1TeamMember> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).patchTeamMember(owner, team, member_user, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} team_name Name
         * @param {V1Team} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam(owner: string, team_name: string, body: V1Team, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Team> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).updateTeam(owner, team_name, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stop runs
         * @param {string} owner Owner of the namespace
         * @param {string} team Team
         * @param {string} member_user User
         * @param {V1TeamMember} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeamMember(owner: string, team: string, member_user: string, body: V1TeamMember, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1TeamMember> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).updateTeamMember(owner, team, member_user, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TeamsV1Api - factory interface
 * @export
 */
export const TeamsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1Team} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam(owner: string, body: V1Team, options?: any) {
            return TeamsV1ApiFp(configuration).createTeam(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {string} team Team
         * @param {V1TeamMember} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeamMember(owner: string, team: string, body: V1TeamMember, options?: any) {
            return TeamsV1ApiFp(configuration).createTeamMember(owner, team, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam(owner: string, team: string, options?: any) {
            return TeamsV1ApiFp(configuration).deleteTeam(owner, team, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Invalidate runs
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {string} user Member under team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeamMember(owner: string, team: string, user: string, options?: any) {
            return TeamsV1ApiFp(configuration).deleteTeamMember(owner, team, user, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam(owner: string, team: string, options?: any) {
            return TeamsV1ApiFp(configuration).getTeam(owner, team, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {string} user Member under team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMember(owner: string, team: string, user: string, options?: any) {
            return TeamsV1ApiFp(configuration).getTeamMember(owner, team, user, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamMembers(owner: string, team: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return TeamsV1ApiFp(configuration).listTeamMembers(owner, team, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return TeamsV1ApiFp(configuration).listTeamNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeams(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return TeamsV1ApiFp(configuration).listTeams(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} team_name Name
         * @param {V1Team} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTeam(owner: string, team_name: string, body: V1Team, options?: any) {
            return TeamsV1ApiFp(configuration).patchTeam(owner, team_name, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Invalidate run
         * @param {string} owner Owner of the namespace
         * @param {string} team Team
         * @param {string} member_user User
         * @param {V1TeamMember} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTeamMember(owner: string, team: string, member_user: string, body: V1TeamMember, options?: any) {
            return TeamsV1ApiFp(configuration).patchTeamMember(owner, team, member_user, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} team_name Name
         * @param {V1Team} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam(owner: string, team_name: string, body: V1Team, options?: any) {
            return TeamsV1ApiFp(configuration).updateTeam(owner, team_name, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stop runs
         * @param {string} owner Owner of the namespace
         * @param {string} team Team
         * @param {string} member_user User
         * @param {V1TeamMember} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeamMember(owner: string, team: string, member_user: string, body: V1TeamMember, options?: any) {
            return TeamsV1ApiFp(configuration).updateTeamMember(owner, team, member_user, body, options)(fetch, basePath);
        },
    };
};

/**
 * TeamsV1Api - object-oriented interface
 * @export
 * @class TeamsV1Api
 * @extends {BaseAPI}
 */
export class TeamsV1Api extends BaseAPI {
    /**
     * 
     * @summary List runs
     * @param {string} owner Owner of the namespace
     * @param {V1Team} body Team body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public createTeam(owner: string, body: V1Team, options?: any) {
        return TeamsV1ApiFp(this.configuration).createTeam(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete runs
     * @param {string} owner Owner of the namespace
     * @param {string} team Team
     * @param {V1TeamMember} body Team body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public createTeamMember(owner: string, team: string, body: V1TeamMember, options?: any) {
        return TeamsV1ApiFp(this.configuration).createTeamMember(owner, team, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch run
     * @param {string} owner Owner of the namespace
     * @param {string} team Team under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public deleteTeam(owner: string, team: string, options?: any) {
        return TeamsV1ApiFp(this.configuration).deleteTeam(owner, team, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Invalidate runs
     * @param {string} owner Owner of the namespace
     * @param {string} team Team under namesapce
     * @param {string} user Member under team
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public deleteTeamMember(owner: string, team: string, user: string, options?: any) {
        return TeamsV1ApiFp(this.configuration).deleteTeamMember(owner, team, user, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run
     * @param {string} owner Owner of the namespace
     * @param {string} team Team under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public getTeam(owner: string, team: string, options?: any) {
        return TeamsV1ApiFp(this.configuration).getTeam(owner, team, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stop run
     * @param {string} owner Owner of the namespace
     * @param {string} team Team under namesapce
     * @param {string} user Member under team
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public getTeamMember(owner: string, team: string, user: string, options?: any) {
        return TeamsV1ApiFp(this.configuration).getTeamMember(owner, team, user, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete run
     * @param {string} owner Owner of the namespace
     * @param {string} team Team under namesapce
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public listTeamMembers(owner: string, team: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return TeamsV1ApiFp(this.configuration).listTeamMembers(owner, team, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public listTeamNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return TeamsV1ApiFp(this.configuration).listTeamNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List archived runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public listTeams(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return TeamsV1ApiFp(this.configuration).listTeams(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update run
     * @param {string} owner Owner of the namespace
     * @param {string} team_name Name
     * @param {V1Team} body Team body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public patchTeam(owner: string, team_name: string, body: V1Team, options?: any) {
        return TeamsV1ApiFp(this.configuration).patchTeam(owner, team_name, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Invalidate run
     * @param {string} owner Owner of the namespace
     * @param {string} team Team
     * @param {string} member_user User
     * @param {V1TeamMember} body Team body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public patchTeamMember(owner: string, team: string, member_user: string, body: V1TeamMember, options?: any) {
        return TeamsV1ApiFp(this.configuration).patchTeamMember(owner, team, member_user, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run
     * @param {string} owner Owner of the namespace
     * @param {string} team_name Name
     * @param {V1Team} body Team body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public updateTeam(owner: string, team_name: string, body: V1Team, options?: any) {
        return TeamsV1ApiFp(this.configuration).updateTeam(owner, team_name, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stop runs
     * @param {string} owner Owner of the namespace
     * @param {string} team Team
     * @param {string} member_user User
     * @param {V1TeamMember} body Team body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public updateTeamMember(owner: string, team: string, member_user: string, body: V1TeamMember, options?: any) {
        return TeamsV1ApiFp(this.configuration).updateTeamMember(owner, team, member_user, body, options)(this.fetch, this.basePath);
    }

}

/**
 * UsersV1Api - fetch parameter creator
 * @export
 */
export const UsersV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersV1Api - functional programming interface
 * @export
 */
export const UsersV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1User> {
            const localVarFetchArgs = UsersV1ApiFetchParamCreator(configuration).getUser(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UsersV1Api - factory interface
 * @export
 */
export const UsersV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options?: any) {
            return UsersV1ApiFp(configuration).getUser(options)(fetch, basePath);
        },
    };
};

/**
 * UsersV1Api - object-oriented interface
 * @export
 * @class UsersV1Api
 * @extends {BaseAPI}
 */
export class UsersV1Api extends BaseAPI {
    /**
     * 
     * @summary List bookmarked runs for user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersV1Api
     */
    public getUser(options?: any) {
        return UsersV1ApiFp(this.configuration).getUser(options)(this.fetch, this.basePath);
    }

}

/**
 * VersionsV1Api - fetch parameter creator
 * @export
 */
export const VersionsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List archived runs for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogHandler(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/log_handler`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersions(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/version`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VersionsV1Api - functional programming interface
 * @export
 */
export const VersionsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List archived runs for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogHandler(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1LogHandler> {
            const localVarFetchArgs = VersionsV1ApiFetchParamCreator(configuration).getLogHandler(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersions(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Versions> {
            const localVarFetchArgs = VersionsV1ApiFetchParamCreator(configuration).getVersions(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * VersionsV1Api - factory interface
 * @export
 */
export const VersionsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List archived runs for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogHandler(options?: any) {
            return VersionsV1ApiFp(configuration).getLogHandler(options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersions(options?: any) {
            return VersionsV1ApiFp(configuration).getVersions(options)(fetch, basePath);
        },
    };
};

/**
 * VersionsV1Api - object-oriented interface
 * @export
 * @class VersionsV1Api
 * @extends {BaseAPI}
 */
export class VersionsV1Api extends BaseAPI {
    /**
     * 
     * @summary List archived runs for user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsV1Api
     */
    public getLogHandler(options?: any) {
        return VersionsV1ApiFp(this.configuration).getLogHandler(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked runs for user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsV1Api
     */
    public getVersions(options?: any) {
        return VersionsV1ApiFp(this.configuration).getVersions(options)(this.fetch, this.basePath);
    }

}

