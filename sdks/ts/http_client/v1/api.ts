// Copyright 2019 Polyaxon, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Polyaxon SDKs and REST API specification.
 * Polyaxon SDKs and REST API specification.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: contact@polyaxon.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface V1ArtifactTreeResponse
 */
export interface V1ArtifactTreeResponse {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1ArtifactTreeResponse
     */
    files?: { [key: string]: string; };
    /**
     * 
     * @type {Array<string>}
     * @memberof V1ArtifactTreeResponse
     */
    dirs?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof V1ArtifactTreeResponse
     */
    is_done?: boolean;
}

/**
 * 
 * @export
 * @interface V1ArtifactsStore
 */
export interface V1ArtifactsStore {
    /**
     * 
     * @type {string}
     * @memberof V1ArtifactsStore
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ArtifactsStore
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ArtifactsStore
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ArtifactsStore
     */
    readme?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1ArtifactsStore
     */
    tags?: Array<string>;
    /**
     * 
     * @type {Date}
     * @memberof V1ArtifactsStore
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1ArtifactsStore
     */
    updated_at?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof V1ArtifactsStore
     */
    frozen?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1ArtifactsStore
     */
    disabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1ArtifactsStore
     */
    deleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1ArtifactsStore
     */
    k8s_secret?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ArtifactsStore
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ArtifactsStore
     */
    mount_path?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ArtifactsStore
     */
    host_path?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ArtifactsStore
     */
    volume_claim?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ArtifactsStore
     */
    bucket?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1ArtifactsStore
     */
    read_only?: boolean;
}

/**
 * 
 * @export
 * @interface V1Auth
 */
export interface V1Auth {
    /**
     * 
     * @type {string}
     * @memberof V1Auth
     */
    token?: string;
}

/**
 * 
 * @export
 * @interface V1CodeRef
 */
export interface V1CodeRef {
    /**
     * 
     * @type {string}
     * @memberof V1CodeRef
     */
    commit?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CodeRef
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface V1CredsBodyRequest
 */
export interface V1CredsBodyRequest {
    /**
     * 
     * @type {string}
     * @memberof V1CredsBodyRequest
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CredsBodyRequest
     */
    password?: string;
}

/**
 * 
 * @export
 * @interface V1EntityStatusBodyRequest
 */
export interface V1EntityStatusBodyRequest {
    /**
     * 
     * @type {string}
     * @memberof V1EntityStatusBodyRequest
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EntityStatusBodyRequest
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EntityStatusBodyRequest
     */
    uuid?: string;
    /**
     * 
     * @type {V1StatusCondition}
     * @memberof V1EntityStatusBodyRequest
     */
    condition?: V1StatusCondition;
}

/**
 * 
 * @export
 * @interface V1HostAccess
 */
export interface V1HostAccess {
    /**
     * 
     * @type {string}
     * @memberof V1HostAccess
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1HostAccess
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1HostAccess
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof V1HostAccess
     */
    readme?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1HostAccess
     */
    tags?: Array<string>;
    /**
     * 
     * @type {Date}
     * @memberof V1HostAccess
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1HostAccess
     */
    updated_at?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof V1HostAccess
     */
    frozen?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1HostAccess
     */
    disabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1HostAccess
     */
    insecure?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1HostAccess
     */
    deleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1HostAccess
     */
    k8s_secret?: string;
    /**
     * 
     * @type {string}
     * @memberof V1HostAccess
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface V1K8sResource
 */
export interface V1K8sResource {
    /**
     * 
     * @type {string}
     * @memberof V1K8sResource
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1K8sResource
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1K8sResource
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof V1K8sResource
     */
    readme?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1K8sResource
     */
    tags?: Array<string>;
    /**
     * 
     * @type {Date}
     * @memberof V1K8sResource
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1K8sResource
     */
    updated_at?: Date;
    /**
     * 
     * @type {string}
     * @memberof V1K8sResource
     */
    k8s_ref?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1K8sResource
     */
    frozen?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1K8sResource
     */
    disabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1K8sResource
     */
    deleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1K8sResource
     */
    mount_path?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1K8sResource
     */
    items?: Array<string>;
}

/**
 * 
 * @export
 * @interface V1ListArtifactsStoresResponse
 */
export interface V1ListArtifactsStoresResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListArtifactsStoresResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1ArtifactsStore>}
     * @memberof V1ListArtifactsStoresResponse
     */
    results?: Array<V1ArtifactsStore>;
    /**
     * 
     * @type {string}
     * @memberof V1ListArtifactsStoresResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListArtifactsStoresResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListHostAccessesResponse
 */
export interface V1ListHostAccessesResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListHostAccessesResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1HostAccess>}
     * @memberof V1ListHostAccessesResponse
     */
    results?: Array<V1HostAccess>;
    /**
     * 
     * @type {string}
     * @memberof V1ListHostAccessesResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListHostAccessesResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListK8sResourcesResponse
 */
export interface V1ListK8sResourcesResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListK8sResourcesResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1K8sResource>}
     * @memberof V1ListK8sResourcesResponse
     */
    results?: Array<V1K8sResource>;
    /**
     * 
     * @type {string}
     * @memberof V1ListK8sResourcesResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListK8sResourcesResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListProjectsResponse
 */
export interface V1ListProjectsResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListProjectsResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1Project>}
     * @memberof V1ListProjectsResponse
     */
    results?: Array<V1Project>;
    /**
     * 
     * @type {string}
     * @memberof V1ListProjectsResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListProjectsResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListRunsResponse
 */
export interface V1ListRunsResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListRunsResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1Run>}
     * @memberof V1ListRunsResponse
     */
    results?: Array<V1Run>;
    /**
     * 
     * @type {string}
     * @memberof V1ListRunsResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListRunsResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListSearchesResponse
 */
export interface V1ListSearchesResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListSearchesResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1Search>}
     * @memberof V1ListSearchesResponse
     */
    results?: Array<V1Search>;
    /**
     * 
     * @type {string}
     * @memberof V1ListSearchesResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListSearchesResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1LogHandler
 */
export interface V1LogHandler {
    /**
     * 
     * @type {string}
     * @memberof V1LogHandler
     */
    dsn?: string;
    /**
     * 
     * @type {string}
     * @memberof V1LogHandler
     */
    environment?: string;
}

/**
 * 
 * @export
 * @interface V1Project
 */
export interface V1Project {
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Project
     */
    tags?: Array<string>;
    /**
     * 
     * @type {Date}
     * @memberof V1Project
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Project
     */
    updated_at?: Date;
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    is_public?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1Project
     */
    deleted?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1Project
     */
    bookmarked?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    readme?: string;
}

/**
 * 
 * @export
 * @interface V1ProjectEntityResourceRequest
 */
export interface V1ProjectEntityResourceRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ProjectEntityResourceRequest
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ProjectEntityResourceRequest
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ProjectEntityResourceRequest
     */
    uuid?: string;
}

/**
 * 
 * @export
 * @interface V1Run
 */
export interface V1Run {
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Run
     */
    tags?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof V1Run
     */
    deleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    project?: string;
    /**
     * 
     * @type {Date}
     * @memberof V1Run
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Run
     */
    updated_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Run
     */
    started_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Run
     */
    finished_at?: Date;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    is_managed?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    status?: string;
    /**
     * 
     * @type {V1RunMetaInfo}
     * @memberof V1Run
     */
    meta_info?: V1RunMetaInfo;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    readme?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1Run
     */
    bookmarked?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1Run
     */
    inputs?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1Run
     */
    outputs?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1Run
     */
    run_env?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof V1Run
     */
    is_resume?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1Run
     */
    is_clone?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    cloning_strategy?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    pipeline?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    original?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    pipeline_name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    original_name?: string;
}

/**
 * 
 * @export
 * @interface V1RunMetaInfo
 */
export interface V1RunMetaInfo {
    /**
     * 
     * @type {boolean}
     * @memberof V1RunMetaInfo
     */
    service?: boolean;
    /**
     * 
     * @type {number}
     * @memberof V1RunMetaInfo
     */
    concurrency?: number;
    /**
     * 
     * @type {string}
     * @memberof V1RunMetaInfo
     */
    workflow_kind?: string;
}

/**
 * 
 * @export
 * @interface V1Search
 */
export interface V1Search {
    /**
     * 
     * @type {string}
     * @memberof V1Search
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Search
     */
    name?: string;
    /**
     * 
     * @type {V1SearchDefinition}
     * @memberof V1Search
     */
    definition?: V1SearchDefinition;
}

/**
 * 
 * @export
 * @interface V1SearchDefinition
 */
export interface V1SearchDefinition {
    /**
     * 
     * @type {string}
     * @memberof V1SearchDefinition
     */
    query?: string;
    /**
     * 
     * @type {string}
     * @memberof V1SearchDefinition
     */
    sort?: string;
    /**
     * 
     * @type {string}
     * @memberof V1SearchDefinition
     */
    groupby?: string;
    /**
     * 
     * @type {string}
     * @memberof V1SearchDefinition
     */
    columns?: string;
}

/**
 * 
 * @export
 * @interface V1Status
 */
export interface V1Status {
    /**
     * 
     * @type {string}
     * @memberof V1Status
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Status
     */
    status?: string;
    /**
     * 
     * @type {Array<V1StatusCondition>}
     * @memberof V1Status
     */
    status_conditions?: Array<V1StatusCondition>;
}

/**
 * 
 * @export
 * @interface V1StatusCondition
 */
export interface V1StatusCondition {
    /**
     * 
     * @type {string}
     * @memberof V1StatusCondition
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof V1StatusCondition
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof V1StatusCondition
     */
    reason?: string;
    /**
     * 
     * @type {string}
     * @memberof V1StatusCondition
     */
    message?: string;
    /**
     * 
     * @type {Date}
     * @memberof V1StatusCondition
     */
    last_update_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1StatusCondition
     */
    last_transition_time?: Date;
}

/**
 * 
 * @export
 * @interface V1User
 */
export interface V1User {
    /**
     * 
     * @type {string}
     * @memberof V1User
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof V1User
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof V1User
     */
    role?: string;
}

/**
 * 
 * @export
 * @interface V1Uuids
 */
export interface V1Uuids {
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Uuids
     */
    uuids?: Array<string>;
}

/**
 * 
 * @export
 * @interface V1Version
 */
export interface V1Version {
    /**
     * 
     * @type {string}
     * @memberof V1Version
     */
    min_version?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Version
     */
    latest_version?: string;
}

/**
 * 
 * @export
 * @interface V1Versions
 */
export interface V1Versions {
    /**
     * 
     * @type {string}
     * @memberof V1Versions
     */
    platform_version?: string;
    /**
     * 
     * @type {V1Version}
     * @memberof V1Versions
     */
    cli?: V1Version;
    /**
     * 
     * @type {V1Version}
     * @memberof V1Versions
     */
    platform?: V1Version;
    /**
     * 
     * @type {V1Version}
     * @memberof V1Versions
     */
    agent?: V1Version;
}


/**
 * ArtifactsStoresV1Api - fetch parameter creator
 * @export
 */
export const ArtifactsStoresV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1ArtifactsStore} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifactsStore(owner: string, body: V1ArtifactsStore, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createArtifactsStore.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createArtifactsStore.');
            }
            const localVarPath = `/api/v1/{owner}/artifacts_stores`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ArtifactsStore" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifactsStore(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteArtifactsStore.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteArtifactsStore.');
            }
            const localVarPath = `/api/v1/{owner}/artifacts_stores/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactsStore(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getArtifactsStore.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getArtifactsStore.');
            }
            const localVarPath = `/api/v1/{owner}/artifacts_stores/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifactsStoreNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listArtifactsStoreNames.');
            }
            const localVarPath = `/api/v1/{owner}/artifacts_stores/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifactsStores(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listArtifactsStores.');
            }
            const localVarPath = `/api/v1/{owner}/artifacts_stores`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} artifact_store_uuid UUID
         * @param {V1ArtifactsStore} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchArtifactsStore(owner: string, artifact_store_uuid: string, body: V1ArtifactsStore, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchArtifactsStore.');
            }
            // verify required parameter 'artifact_store_uuid' is not null or undefined
            if (artifact_store_uuid === null || artifact_store_uuid === undefined) {
                throw new RequiredError('artifact_store_uuid','Required parameter artifact_store_uuid was null or undefined when calling patchArtifactsStore.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchArtifactsStore.');
            }
            const localVarPath = `/api/v1/{owner}/artifacts_stores/{artifact_store.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"artifact_store.uuid"}}`, encodeURIComponent(String(artifact_store_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ArtifactsStore" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} artifact_store_uuid UUID
         * @param {V1ArtifactsStore} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtifactsStore(owner: string, artifact_store_uuid: string, body: V1ArtifactsStore, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateArtifactsStore.');
            }
            // verify required parameter 'artifact_store_uuid' is not null or undefined
            if (artifact_store_uuid === null || artifact_store_uuid === undefined) {
                throw new RequiredError('artifact_store_uuid','Required parameter artifact_store_uuid was null or undefined when calling updateArtifactsStore.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateArtifactsStore.');
            }
            const localVarPath = `/api/v1/{owner}/artifacts_stores/{artifact_store.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"artifact_store.uuid"}}`, encodeURIComponent(String(artifact_store_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ArtifactsStore" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload artifact to a store
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadArtifact(owner: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling uploadArtifact.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling uploadArtifact.');
            }
            // verify required parameter 'uploadfile' is not null or undefined
            if (uploadfile === null || uploadfile === undefined) {
                throw new RequiredError('uploadfile','Required parameter uploadfile was null or undefined when calling uploadArtifact.');
            }
            const localVarPath = `/api/v1/catalogs/{owner}/artifacts_stores/{uuid}/upload`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (overwrite !== undefined) {
                localVarQueryParameter['overwrite'] = overwrite;
            }

            if (uploadfile !== undefined) {
                localVarFormParams.set('uploadfile', uploadfile as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtifactsStoresV1Api - functional programming interface
 * @export
 */
export const ArtifactsStoresV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1ArtifactsStore} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifactsStore(owner: string, body: V1ArtifactsStore, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ArtifactsStore> {
            const localVarFetchArgs = ArtifactsStoresV1ApiFetchParamCreator(configuration).createArtifactsStore(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifactsStore(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ArtifactsStoresV1ApiFetchParamCreator(configuration).deleteArtifactsStore(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactsStore(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ArtifactsStore> {
            const localVarFetchArgs = ArtifactsStoresV1ApiFetchParamCreator(configuration).getArtifactsStore(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifactsStoreNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListArtifactsStoresResponse> {
            const localVarFetchArgs = ArtifactsStoresV1ApiFetchParamCreator(configuration).listArtifactsStoreNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifactsStores(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListArtifactsStoresResponse> {
            const localVarFetchArgs = ArtifactsStoresV1ApiFetchParamCreator(configuration).listArtifactsStores(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} artifact_store_uuid UUID
         * @param {V1ArtifactsStore} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchArtifactsStore(owner: string, artifact_store_uuid: string, body: V1ArtifactsStore, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ArtifactsStore> {
            const localVarFetchArgs = ArtifactsStoresV1ApiFetchParamCreator(configuration).patchArtifactsStore(owner, artifact_store_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} artifact_store_uuid UUID
         * @param {V1ArtifactsStore} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtifactsStore(owner: string, artifact_store_uuid: string, body: V1ArtifactsStore, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ArtifactsStore> {
            const localVarFetchArgs = ArtifactsStoresV1ApiFetchParamCreator(configuration).updateArtifactsStore(owner, artifact_store_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Upload artifact to a store
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadArtifact(owner: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ArtifactsStoresV1ApiFetchParamCreator(configuration).uploadArtifact(owner, uuid, uploadfile, path, overwrite, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ArtifactsStoresV1Api - factory interface
 * @export
 */
export const ArtifactsStoresV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1ArtifactsStore} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifactsStore(owner: string, body: V1ArtifactsStore, options?: any) {
            return ArtifactsStoresV1ApiFp(configuration).createArtifactsStore(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifactsStore(owner: string, uuid: string, options?: any) {
            return ArtifactsStoresV1ApiFp(configuration).deleteArtifactsStore(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactsStore(owner: string, uuid: string, options?: any) {
            return ArtifactsStoresV1ApiFp(configuration).getArtifactsStore(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifactsStoreNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ArtifactsStoresV1ApiFp(configuration).listArtifactsStoreNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifactsStores(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ArtifactsStoresV1ApiFp(configuration).listArtifactsStores(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} artifact_store_uuid UUID
         * @param {V1ArtifactsStore} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchArtifactsStore(owner: string, artifact_store_uuid: string, body: V1ArtifactsStore, options?: any) {
            return ArtifactsStoresV1ApiFp(configuration).patchArtifactsStore(owner, artifact_store_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} artifact_store_uuid UUID
         * @param {V1ArtifactsStore} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtifactsStore(owner: string, artifact_store_uuid: string, body: V1ArtifactsStore, options?: any) {
            return ArtifactsStoresV1ApiFp(configuration).updateArtifactsStore(owner, artifact_store_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Upload artifact to a store
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadArtifact(owner: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any) {
            return ArtifactsStoresV1ApiFp(configuration).uploadArtifact(owner, uuid, uploadfile, path, overwrite, options)(fetch, basePath);
        },
    };
};

/**
 * ArtifactsStoresV1Api - object-oriented interface
 * @export
 * @class ArtifactsStoresV1Api
 * @extends {BaseAPI}
 */
export class ArtifactsStoresV1Api extends BaseAPI {
    /**
     * 
     * @summary List runs
     * @param {string} owner Owner of the namespace
     * @param {V1ArtifactsStore} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsStoresV1Api
     */
    public createArtifactsStore(owner: string, body: V1ArtifactsStore, options?: any) {
        return ArtifactsStoresV1ApiFp(this.configuration).createArtifactsStore(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch run
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsStoresV1Api
     */
    public deleteArtifactsStore(owner: string, uuid: string, options?: any) {
        return ArtifactsStoresV1ApiFp(this.configuration).deleteArtifactsStore(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsStoresV1Api
     */
    public getArtifactsStore(owner: string, uuid: string, options?: any) {
        return ArtifactsStoresV1ApiFp(this.configuration).getArtifactsStore(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsStoresV1Api
     */
    public listArtifactsStoreNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ArtifactsStoresV1ApiFp(this.configuration).listArtifactsStoreNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List archived runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsStoresV1Api
     */
    public listArtifactsStores(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ArtifactsStoresV1ApiFp(this.configuration).listArtifactsStores(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update run
     * @param {string} owner Owner of the namespace
     * @param {string} artifact_store_uuid UUID
     * @param {V1ArtifactsStore} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsStoresV1Api
     */
    public patchArtifactsStore(owner: string, artifact_store_uuid: string, body: V1ArtifactsStore, options?: any) {
        return ArtifactsStoresV1ApiFp(this.configuration).patchArtifactsStore(owner, artifact_store_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run
     * @param {string} owner Owner of the namespace
     * @param {string} artifact_store_uuid UUID
     * @param {V1ArtifactsStore} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsStoresV1Api
     */
    public updateArtifactsStore(owner: string, artifact_store_uuid: string, body: V1ArtifactsStore, options?: any) {
        return ArtifactsStoresV1ApiFp(this.configuration).updateArtifactsStore(owner, artifact_store_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Upload artifact to a store
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Unique integer identifier of the entity
     * @param {any} uploadfile The file to upload.
     * @param {string} [path] File path query params.
     * @param {boolean} [overwrite] File path query params.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsStoresV1Api
     */
    public uploadArtifact(owner: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any) {
        return ArtifactsStoresV1ApiFp(this.configuration).uploadArtifact(owner, uuid, uploadfile, path, overwrite, options)(this.fetch, this.basePath);
    }

}

/**
 * AuthV1Api - fetch parameter creator
 * @export
 */
export const AuthV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {V1CredsBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body: V1CredsBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling login.');
            }
            const localVarPath = `/api/v1/users/token`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1CredsBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthV1Api - functional programming interface
 * @export
 */
export const AuthV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {V1CredsBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body: V1CredsBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Auth> {
            const localVarFetchArgs = AuthV1ApiFetchParamCreator(configuration).login(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuthV1Api - factory interface
 * @export
 */
export const AuthV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {V1CredsBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body: V1CredsBodyRequest, options?: any) {
            return AuthV1ApiFp(configuration).login(body, options)(fetch, basePath);
        },
    };
};

/**
 * AuthV1Api - object-oriented interface
 * @export
 * @class AuthV1Api
 * @extends {BaseAPI}
 */
export class AuthV1Api extends BaseAPI {
    /**
     * 
     * @summary List bookmarked runs for user
     * @param {V1CredsBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthV1Api
     */
    public login(body: V1CredsBodyRequest, options?: any) {
        return AuthV1ApiFp(this.configuration).login(body, options)(this.fetch, this.basePath);
    }

}

/**
 * GitAccessesV1Api - fetch parameter creator
 * @export
 */
export const GitAccessesV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1HostAccess} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGitAccess(owner: string, body: V1HostAccess, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createGitAccess.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createGitAccess.');
            }
            const localVarPath = `/api/v1/{owner}/git_accesses`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1HostAccess" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGitAccess(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteGitAccess.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteGitAccess.');
            }
            const localVarPath = `/api/v1/{owner}/git_accesses/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGitAccess(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getGitAccess.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getGitAccess.');
            }
            const localVarPath = `/api/v1/{owner}/git_accesses/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGitAccessNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listGitAccessNames.');
            }
            const localVarPath = `/api/v1/{owner}/git_accesses/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGitAccesses(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listGitAccesses.');
            }
            const localVarPath = `/api/v1/{owner}/git_accesses`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} host_access_uuid UUID
         * @param {V1HostAccess} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchGitAccess(owner: string, host_access_uuid: string, body: V1HostAccess, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchGitAccess.');
            }
            // verify required parameter 'host_access_uuid' is not null or undefined
            if (host_access_uuid === null || host_access_uuid === undefined) {
                throw new RequiredError('host_access_uuid','Required parameter host_access_uuid was null or undefined when calling patchGitAccess.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchGitAccess.');
            }
            const localVarPath = `/api/v1/{owner}/git_accesses/{host_access.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"host_access.uuid"}}`, encodeURIComponent(String(host_access_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1HostAccess" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} host_access_uuid UUID
         * @param {V1HostAccess} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGitAccess(owner: string, host_access_uuid: string, body: V1HostAccess, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateGitAccess.');
            }
            // verify required parameter 'host_access_uuid' is not null or undefined
            if (host_access_uuid === null || host_access_uuid === undefined) {
                throw new RequiredError('host_access_uuid','Required parameter host_access_uuid was null or undefined when calling updateGitAccess.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateGitAccess.');
            }
            const localVarPath = `/api/v1/{owner}/git_accesses/{host_access.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"host_access.uuid"}}`, encodeURIComponent(String(host_access_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1HostAccess" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GitAccessesV1Api - functional programming interface
 * @export
 */
export const GitAccessesV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1HostAccess} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGitAccess(owner: string, body: V1HostAccess, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1HostAccess> {
            const localVarFetchArgs = GitAccessesV1ApiFetchParamCreator(configuration).createGitAccess(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGitAccess(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = GitAccessesV1ApiFetchParamCreator(configuration).deleteGitAccess(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGitAccess(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1HostAccess> {
            const localVarFetchArgs = GitAccessesV1ApiFetchParamCreator(configuration).getGitAccess(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGitAccessNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListHostAccessesResponse> {
            const localVarFetchArgs = GitAccessesV1ApiFetchParamCreator(configuration).listGitAccessNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGitAccesses(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListHostAccessesResponse> {
            const localVarFetchArgs = GitAccessesV1ApiFetchParamCreator(configuration).listGitAccesses(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} host_access_uuid UUID
         * @param {V1HostAccess} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchGitAccess(owner: string, host_access_uuid: string, body: V1HostAccess, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1HostAccess> {
            const localVarFetchArgs = GitAccessesV1ApiFetchParamCreator(configuration).patchGitAccess(owner, host_access_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} host_access_uuid UUID
         * @param {V1HostAccess} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGitAccess(owner: string, host_access_uuid: string, body: V1HostAccess, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1HostAccess> {
            const localVarFetchArgs = GitAccessesV1ApiFetchParamCreator(configuration).updateGitAccess(owner, host_access_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GitAccessesV1Api - factory interface
 * @export
 */
export const GitAccessesV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1HostAccess} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGitAccess(owner: string, body: V1HostAccess, options?: any) {
            return GitAccessesV1ApiFp(configuration).createGitAccess(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGitAccess(owner: string, uuid: string, options?: any) {
            return GitAccessesV1ApiFp(configuration).deleteGitAccess(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGitAccess(owner: string, uuid: string, options?: any) {
            return GitAccessesV1ApiFp(configuration).getGitAccess(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGitAccessNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return GitAccessesV1ApiFp(configuration).listGitAccessNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGitAccesses(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return GitAccessesV1ApiFp(configuration).listGitAccesses(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} host_access_uuid UUID
         * @param {V1HostAccess} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchGitAccess(owner: string, host_access_uuid: string, body: V1HostAccess, options?: any) {
            return GitAccessesV1ApiFp(configuration).patchGitAccess(owner, host_access_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} host_access_uuid UUID
         * @param {V1HostAccess} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGitAccess(owner: string, host_access_uuid: string, body: V1HostAccess, options?: any) {
            return GitAccessesV1ApiFp(configuration).updateGitAccess(owner, host_access_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * GitAccessesV1Api - object-oriented interface
 * @export
 * @class GitAccessesV1Api
 * @extends {BaseAPI}
 */
export class GitAccessesV1Api extends BaseAPI {
    /**
     * 
     * @summary List runs
     * @param {string} owner Owner of the namespace
     * @param {V1HostAccess} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GitAccessesV1Api
     */
    public createGitAccess(owner: string, body: V1HostAccess, options?: any) {
        return GitAccessesV1ApiFp(this.configuration).createGitAccess(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch run
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GitAccessesV1Api
     */
    public deleteGitAccess(owner: string, uuid: string, options?: any) {
        return GitAccessesV1ApiFp(this.configuration).deleteGitAccess(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GitAccessesV1Api
     */
    public getGitAccess(owner: string, uuid: string, options?: any) {
        return GitAccessesV1ApiFp(this.configuration).getGitAccess(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GitAccessesV1Api
     */
    public listGitAccessNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return GitAccessesV1ApiFp(this.configuration).listGitAccessNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List archived runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GitAccessesV1Api
     */
    public listGitAccesses(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return GitAccessesV1ApiFp(this.configuration).listGitAccesses(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update run
     * @param {string} owner Owner of the namespace
     * @param {string} host_access_uuid UUID
     * @param {V1HostAccess} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GitAccessesV1Api
     */
    public patchGitAccess(owner: string, host_access_uuid: string, body: V1HostAccess, options?: any) {
        return GitAccessesV1ApiFp(this.configuration).patchGitAccess(owner, host_access_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run
     * @param {string} owner Owner of the namespace
     * @param {string} host_access_uuid UUID
     * @param {V1HostAccess} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GitAccessesV1Api
     */
    public updateGitAccess(owner: string, host_access_uuid: string, body: V1HostAccess, options?: any) {
        return GitAccessesV1ApiFp(this.configuration).updateGitAccess(owner, host_access_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * K8sConfigMapsV1Api - fetch parameter creator
 * @export
 */
export const K8sConfigMapsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1K8sResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createK8sConfigMaps(owner: string, body: V1K8sResource, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createK8sConfigMaps.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createK8sConfigMaps.');
            }
            const localVarPath = `/api/v1/{owner}/k8s_config_maps`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1K8sResource" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteK8sConfigMap(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteK8sConfigMap.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteK8sConfigMap.');
            }
            const localVarPath = `/api/v1/{owner}/k8s_config_maps/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getK8sConfigMap(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getK8sConfigMap.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getK8sConfigMap.');
            }
            const localVarPath = `/api/v1/{owner}/k8s_config_maps/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8sConfigMapNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listK8sConfigMapNames.');
            }
            const localVarPath = `/api/v1/{owner}/k8s_config_maps/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8sConfigMaps(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listK8sConfigMaps.');
            }
            const localVarPath = `/api/v1/{owner}/k8s_config_maps`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} k8s_resource_uuid UUID
         * @param {V1K8sResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchK8sConfigMap(owner: string, k8s_resource_uuid: string, body: V1K8sResource, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchK8sConfigMap.');
            }
            // verify required parameter 'k8s_resource_uuid' is not null or undefined
            if (k8s_resource_uuid === null || k8s_resource_uuid === undefined) {
                throw new RequiredError('k8s_resource_uuid','Required parameter k8s_resource_uuid was null or undefined when calling patchK8sConfigMap.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchK8sConfigMap.');
            }
            const localVarPath = `/api/v1/{owner}/k8s_config_maps/{k8s_resource.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"k8s_resource.uuid"}}`, encodeURIComponent(String(k8s_resource_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1K8sResource" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} k8s_resource_uuid UUID
         * @param {V1K8sResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateK8sConfigMap(owner: string, k8s_resource_uuid: string, body: V1K8sResource, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateK8sConfigMap.');
            }
            // verify required parameter 'k8s_resource_uuid' is not null or undefined
            if (k8s_resource_uuid === null || k8s_resource_uuid === undefined) {
                throw new RequiredError('k8s_resource_uuid','Required parameter k8s_resource_uuid was null or undefined when calling updateK8sConfigMap.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateK8sConfigMap.');
            }
            const localVarPath = `/api/v1/{owner}/k8s_config_maps/{k8s_resource.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"k8s_resource.uuid"}}`, encodeURIComponent(String(k8s_resource_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1K8sResource" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * K8sConfigMapsV1Api - functional programming interface
 * @export
 */
export const K8sConfigMapsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1K8sResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createK8sConfigMaps(owner: string, body: V1K8sResource, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1K8sResource> {
            const localVarFetchArgs = K8sConfigMapsV1ApiFetchParamCreator(configuration).createK8sConfigMaps(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteK8sConfigMap(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = K8sConfigMapsV1ApiFetchParamCreator(configuration).deleteK8sConfigMap(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getK8sConfigMap(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1K8sResource> {
            const localVarFetchArgs = K8sConfigMapsV1ApiFetchParamCreator(configuration).getK8sConfigMap(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8sConfigMapNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListK8sResourcesResponse> {
            const localVarFetchArgs = K8sConfigMapsV1ApiFetchParamCreator(configuration).listK8sConfigMapNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8sConfigMaps(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListK8sResourcesResponse> {
            const localVarFetchArgs = K8sConfigMapsV1ApiFetchParamCreator(configuration).listK8sConfigMaps(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} k8s_resource_uuid UUID
         * @param {V1K8sResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchK8sConfigMap(owner: string, k8s_resource_uuid: string, body: V1K8sResource, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1K8sResource> {
            const localVarFetchArgs = K8sConfigMapsV1ApiFetchParamCreator(configuration).patchK8sConfigMap(owner, k8s_resource_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} k8s_resource_uuid UUID
         * @param {V1K8sResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateK8sConfigMap(owner: string, k8s_resource_uuid: string, body: V1K8sResource, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1K8sResource> {
            const localVarFetchArgs = K8sConfigMapsV1ApiFetchParamCreator(configuration).updateK8sConfigMap(owner, k8s_resource_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * K8sConfigMapsV1Api - factory interface
 * @export
 */
export const K8sConfigMapsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1K8sResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createK8sConfigMaps(owner: string, body: V1K8sResource, options?: any) {
            return K8sConfigMapsV1ApiFp(configuration).createK8sConfigMaps(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteK8sConfigMap(owner: string, uuid: string, options?: any) {
            return K8sConfigMapsV1ApiFp(configuration).deleteK8sConfigMap(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getK8sConfigMap(owner: string, uuid: string, options?: any) {
            return K8sConfigMapsV1ApiFp(configuration).getK8sConfigMap(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8sConfigMapNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return K8sConfigMapsV1ApiFp(configuration).listK8sConfigMapNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8sConfigMaps(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return K8sConfigMapsV1ApiFp(configuration).listK8sConfigMaps(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} k8s_resource_uuid UUID
         * @param {V1K8sResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchK8sConfigMap(owner: string, k8s_resource_uuid: string, body: V1K8sResource, options?: any) {
            return K8sConfigMapsV1ApiFp(configuration).patchK8sConfigMap(owner, k8s_resource_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} k8s_resource_uuid UUID
         * @param {V1K8sResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateK8sConfigMap(owner: string, k8s_resource_uuid: string, body: V1K8sResource, options?: any) {
            return K8sConfigMapsV1ApiFp(configuration).updateK8sConfigMap(owner, k8s_resource_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * K8sConfigMapsV1Api - object-oriented interface
 * @export
 * @class K8sConfigMapsV1Api
 * @extends {BaseAPI}
 */
export class K8sConfigMapsV1Api extends BaseAPI {
    /**
     * 
     * @summary List runs
     * @param {string} owner Owner of the namespace
     * @param {V1K8sResource} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof K8sConfigMapsV1Api
     */
    public createK8sConfigMaps(owner: string, body: V1K8sResource, options?: any) {
        return K8sConfigMapsV1ApiFp(this.configuration).createK8sConfigMaps(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch run
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof K8sConfigMapsV1Api
     */
    public deleteK8sConfigMap(owner: string, uuid: string, options?: any) {
        return K8sConfigMapsV1ApiFp(this.configuration).deleteK8sConfigMap(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof K8sConfigMapsV1Api
     */
    public getK8sConfigMap(owner: string, uuid: string, options?: any) {
        return K8sConfigMapsV1ApiFp(this.configuration).getK8sConfigMap(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof K8sConfigMapsV1Api
     */
    public listK8sConfigMapNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return K8sConfigMapsV1ApiFp(this.configuration).listK8sConfigMapNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List archived runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof K8sConfigMapsV1Api
     */
    public listK8sConfigMaps(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return K8sConfigMapsV1ApiFp(this.configuration).listK8sConfigMaps(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update run
     * @param {string} owner Owner of the namespace
     * @param {string} k8s_resource_uuid UUID
     * @param {V1K8sResource} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof K8sConfigMapsV1Api
     */
    public patchK8sConfigMap(owner: string, k8s_resource_uuid: string, body: V1K8sResource, options?: any) {
        return K8sConfigMapsV1ApiFp(this.configuration).patchK8sConfigMap(owner, k8s_resource_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run
     * @param {string} owner Owner of the namespace
     * @param {string} k8s_resource_uuid UUID
     * @param {V1K8sResource} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof K8sConfigMapsV1Api
     */
    public updateK8sConfigMap(owner: string, k8s_resource_uuid: string, body: V1K8sResource, options?: any) {
        return K8sConfigMapsV1ApiFp(this.configuration).updateK8sConfigMap(owner, k8s_resource_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * K8sSecretsV1Api - fetch parameter creator
 * @export
 */
export const K8sSecretsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1K8sResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createK8sSecrets(owner: string, body: V1K8sResource, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createK8sSecrets.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createK8sSecrets.');
            }
            const localVarPath = `/api/v1/{owner}/k8s_secrets`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1K8sResource" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteK8sSecret(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteK8sSecret.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteK8sSecret.');
            }
            const localVarPath = `/api/v1/{owner}/k8s_secrets/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getK8sSecret(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getK8sSecret.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getK8sSecret.');
            }
            const localVarPath = `/api/v1/{owner}/k8s_secrets/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8sSecretNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listK8sSecretNames.');
            }
            const localVarPath = `/api/v1/{owner}/k8s_secrets/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8sSecrets(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listK8sSecrets.');
            }
            const localVarPath = `/api/v1/{owner}/k8s_secrets`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} k8s_resource_uuid UUID
         * @param {V1K8sResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchK8sSecret(owner: string, k8s_resource_uuid: string, body: V1K8sResource, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchK8sSecret.');
            }
            // verify required parameter 'k8s_resource_uuid' is not null or undefined
            if (k8s_resource_uuid === null || k8s_resource_uuid === undefined) {
                throw new RequiredError('k8s_resource_uuid','Required parameter k8s_resource_uuid was null or undefined when calling patchK8sSecret.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchK8sSecret.');
            }
            const localVarPath = `/api/v1/{owner}/k8s_secrets/{k8s_resource.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"k8s_resource.uuid"}}`, encodeURIComponent(String(k8s_resource_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1K8sResource" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} k8s_resource_uuid UUID
         * @param {V1K8sResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateK8sSecret(owner: string, k8s_resource_uuid: string, body: V1K8sResource, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateK8sSecret.');
            }
            // verify required parameter 'k8s_resource_uuid' is not null or undefined
            if (k8s_resource_uuid === null || k8s_resource_uuid === undefined) {
                throw new RequiredError('k8s_resource_uuid','Required parameter k8s_resource_uuid was null or undefined when calling updateK8sSecret.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateK8sSecret.');
            }
            const localVarPath = `/api/v1/{owner}/k8s_secrets/{k8s_resource.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"k8s_resource.uuid"}}`, encodeURIComponent(String(k8s_resource_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1K8sResource" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * K8sSecretsV1Api - functional programming interface
 * @export
 */
export const K8sSecretsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1K8sResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createK8sSecrets(owner: string, body: V1K8sResource, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1K8sResource> {
            const localVarFetchArgs = K8sSecretsV1ApiFetchParamCreator(configuration).createK8sSecrets(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteK8sSecret(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = K8sSecretsV1ApiFetchParamCreator(configuration).deleteK8sSecret(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getK8sSecret(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1K8sResource> {
            const localVarFetchArgs = K8sSecretsV1ApiFetchParamCreator(configuration).getK8sSecret(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8sSecretNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListK8sResourcesResponse> {
            const localVarFetchArgs = K8sSecretsV1ApiFetchParamCreator(configuration).listK8sSecretNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8sSecrets(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListK8sResourcesResponse> {
            const localVarFetchArgs = K8sSecretsV1ApiFetchParamCreator(configuration).listK8sSecrets(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} k8s_resource_uuid UUID
         * @param {V1K8sResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchK8sSecret(owner: string, k8s_resource_uuid: string, body: V1K8sResource, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1K8sResource> {
            const localVarFetchArgs = K8sSecretsV1ApiFetchParamCreator(configuration).patchK8sSecret(owner, k8s_resource_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} k8s_resource_uuid UUID
         * @param {V1K8sResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateK8sSecret(owner: string, k8s_resource_uuid: string, body: V1K8sResource, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1K8sResource> {
            const localVarFetchArgs = K8sSecretsV1ApiFetchParamCreator(configuration).updateK8sSecret(owner, k8s_resource_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * K8sSecretsV1Api - factory interface
 * @export
 */
export const K8sSecretsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1K8sResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createK8sSecrets(owner: string, body: V1K8sResource, options?: any) {
            return K8sSecretsV1ApiFp(configuration).createK8sSecrets(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteK8sSecret(owner: string, uuid: string, options?: any) {
            return K8sSecretsV1ApiFp(configuration).deleteK8sSecret(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getK8sSecret(owner: string, uuid: string, options?: any) {
            return K8sSecretsV1ApiFp(configuration).getK8sSecret(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8sSecretNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return K8sSecretsV1ApiFp(configuration).listK8sSecretNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8sSecrets(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return K8sSecretsV1ApiFp(configuration).listK8sSecrets(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} k8s_resource_uuid UUID
         * @param {V1K8sResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchK8sSecret(owner: string, k8s_resource_uuid: string, body: V1K8sResource, options?: any) {
            return K8sSecretsV1ApiFp(configuration).patchK8sSecret(owner, k8s_resource_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} k8s_resource_uuid UUID
         * @param {V1K8sResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateK8sSecret(owner: string, k8s_resource_uuid: string, body: V1K8sResource, options?: any) {
            return K8sSecretsV1ApiFp(configuration).updateK8sSecret(owner, k8s_resource_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * K8sSecretsV1Api - object-oriented interface
 * @export
 * @class K8sSecretsV1Api
 * @extends {BaseAPI}
 */
export class K8sSecretsV1Api extends BaseAPI {
    /**
     * 
     * @summary List runs
     * @param {string} owner Owner of the namespace
     * @param {V1K8sResource} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof K8sSecretsV1Api
     */
    public createK8sSecrets(owner: string, body: V1K8sResource, options?: any) {
        return K8sSecretsV1ApiFp(this.configuration).createK8sSecrets(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch run
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof K8sSecretsV1Api
     */
    public deleteK8sSecret(owner: string, uuid: string, options?: any) {
        return K8sSecretsV1ApiFp(this.configuration).deleteK8sSecret(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof K8sSecretsV1Api
     */
    public getK8sSecret(owner: string, uuid: string, options?: any) {
        return K8sSecretsV1ApiFp(this.configuration).getK8sSecret(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof K8sSecretsV1Api
     */
    public listK8sSecretNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return K8sSecretsV1ApiFp(this.configuration).listK8sSecretNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List archived runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof K8sSecretsV1Api
     */
    public listK8sSecrets(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return K8sSecretsV1ApiFp(this.configuration).listK8sSecrets(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update run
     * @param {string} owner Owner of the namespace
     * @param {string} k8s_resource_uuid UUID
     * @param {V1K8sResource} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof K8sSecretsV1Api
     */
    public patchK8sSecret(owner: string, k8s_resource_uuid: string, body: V1K8sResource, options?: any) {
        return K8sSecretsV1ApiFp(this.configuration).patchK8sSecret(owner, k8s_resource_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run
     * @param {string} owner Owner of the namespace
     * @param {string} k8s_resource_uuid UUID
     * @param {V1K8sResource} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof K8sSecretsV1Api
     */
    public updateK8sSecret(owner: string, k8s_resource_uuid: string, body: V1K8sResource, options?: any) {
        return K8sSecretsV1ApiFp(this.configuration).updateK8sSecret(owner, k8s_resource_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * ProjectsV1Api - fetch parameter creator
 * @export
 */
export const ProjectsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveProject(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling archiveProject.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling archiveProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/archive`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invalidate run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkProject(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling bookmarkProject.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling bookmarkProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/bookmark`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(owner: string, body: V1Project, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createProject.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createProject.');
            }
            const localVarPath = `/api/v1/{owner}/projects/create`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Project" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteProject.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling deleteProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restart run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableProjectCI(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling disableProjectCI.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling disableProjectCI.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/ci`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restart run with copy
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableProjectCI(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling enableProjectCI.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling enableProjectCI.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/ci`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getProject.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling listArchivedProjects.');
            }
            const localVarPath = `/api/v1/archives/{user}/projects`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling listBookmarkedProjects.');
            }
            const localVarPath = `/api/v1/bookmarks/{user}/projects`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listProjectNames.');
            }
            const localVarPath = `/api/v1/{owner}/projects/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listProjects.');
            }
            const localVarPath = `/api/v1/{owner}/projects/list`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} project_name Required name
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProject(owner: string, project_name: string, body: V1Project, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchProject.');
            }
            // verify required parameter 'project_name' is not null or undefined
            if (project_name === null || project_name === undefined) {
                throw new RequiredError('project_name','Required parameter project_name was null or undefined when calling patchProject.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project.name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project.name"}}`, encodeURIComponent(String(project_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Project" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreProject(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling restoreProject.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling restoreProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/restore`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invalidate runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbookmarkProject(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling unbookmarkProject.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling unbookmarkProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/unbookmark`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} project_name Required name
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject(owner: string, project_name: string, body: V1Project, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateProject.');
            }
            // verify required parameter 'project_name' is not null or undefined
            if (project_name === null || project_name === undefined) {
                throw new RequiredError('project_name','Required parameter project_name was null or undefined when calling updateProject.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project.name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project.name"}}`, encodeURIComponent(String(project_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Project" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload artifact to a store via project access
         * @param {string} owner Owner of the namespace
         * @param {string} project Project having access to the store
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProjectArtifact(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling uploadProjectArtifact.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling uploadProjectArtifact.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling uploadProjectArtifact.');
            }
            // verify required parameter 'uploadfile' is not null or undefined
            if (uploadfile === null || uploadfile === undefined) {
                throw new RequiredError('uploadfile','Required parameter uploadfile was null or undefined when calling uploadProjectArtifact.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/artifacts_stores/{uuid}/upload`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (overwrite !== undefined) {
                localVarQueryParameter['overwrite'] = overwrite;
            }

            if (uploadfile !== undefined) {
                localVarFormParams.set('uploadfile', uploadfile as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsV1Api - functional programming interface
 * @export
 */
export const ProjectsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveProject(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).archiveProject(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Invalidate run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkProject(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).bookmarkProject(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(owner: string, body: V1Project, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Project> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).createProject(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).deleteProject(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Restart run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableProjectCI(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).disableProjectCI(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Restart run with copy
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableProjectCI(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).enableProjectCI(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Project> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).getProject(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListProjectsResponse> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).listArchivedProjects(user, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListProjectsResponse> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).listBookmarkedProjects(user, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListProjectsResponse> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).listProjectNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListProjectsResponse> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).listProjects(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} project_name Required name
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProject(owner: string, project_name: string, body: V1Project, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Project> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).patchProject(owner, project_name, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stop runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreProject(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).restoreProject(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Invalidate runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbookmarkProject(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).unbookmarkProject(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} project_name Required name
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject(owner: string, project_name: string, body: V1Project, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Project> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).updateProject(owner, project_name, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Upload artifact to a store via project access
         * @param {string} owner Owner of the namespace
         * @param {string} project Project having access to the store
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProjectArtifact(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).uploadProjectArtifact(owner, project, uuid, uploadfile, path, overwrite, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProjectsV1Api - factory interface
 * @export
 */
export const ProjectsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveProject(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).archiveProject(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Invalidate run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkProject(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).bookmarkProject(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(owner: string, body: V1Project, options?: any) {
            return ProjectsV1ApiFp(configuration).createProject(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).deleteProject(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Restart run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableProjectCI(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).disableProjectCI(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Restart run with copy
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableProjectCI(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).enableProjectCI(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).getProject(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ProjectsV1ApiFp(configuration).listArchivedProjects(user, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ProjectsV1ApiFp(configuration).listBookmarkedProjects(user, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ProjectsV1ApiFp(configuration).listProjectNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ProjectsV1ApiFp(configuration).listProjects(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} project_name Required name
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProject(owner: string, project_name: string, body: V1Project, options?: any) {
            return ProjectsV1ApiFp(configuration).patchProject(owner, project_name, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stop runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreProject(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).restoreProject(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Invalidate runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbookmarkProject(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).unbookmarkProject(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} project_name Required name
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject(owner: string, project_name: string, body: V1Project, options?: any) {
            return ProjectsV1ApiFp(configuration).updateProject(owner, project_name, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Upload artifact to a store via project access
         * @param {string} owner Owner of the namespace
         * @param {string} project Project having access to the store
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProjectArtifact(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any) {
            return ProjectsV1ApiFp(configuration).uploadProjectArtifact(owner, project, uuid, uploadfile, path, overwrite, options)(fetch, basePath);
        },
    };
};

/**
 * ProjectsV1Api - object-oriented interface
 * @export
 * @class ProjectsV1Api
 * @extends {BaseAPI}
 */
export class ProjectsV1Api extends BaseAPI {
    /**
     * 
     * @summary Stop run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public archiveProject(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).archiveProject(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Invalidate run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public bookmarkProject(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).bookmarkProject(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List archived runs for user
     * @param {string} owner Owner of the namespace
     * @param {V1Project} body Project body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public createProject(owner: string, body: V1Project, options?: any) {
        return ProjectsV1ApiFp(this.configuration).createProject(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public deleteProject(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).deleteProject(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Restart run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public disableProjectCI(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).disableProjectCI(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Restart run with copy
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public enableProjectCI(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).enableProjectCI(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public getProject(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).getProject(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run
     * @param {string} user User
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public listArchivedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).listArchivedProjects(user, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run
     * @param {string} user User
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public listBookmarkedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).listBookmarkedProjects(user, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List runs
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public listProjectNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).listProjectNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public listProjects(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).listProjects(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete run
     * @param {string} owner Owner of the namespace
     * @param {string} project_name Required name
     * @param {V1Project} body Project body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public patchProject(owner: string, project_name: string, body: V1Project, options?: any) {
        return ProjectsV1ApiFp(this.configuration).patchProject(owner, project_name, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stop runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public restoreProject(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).restoreProject(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Invalidate runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public unbookmarkProject(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).unbookmarkProject(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch run
     * @param {string} owner Owner of the namespace
     * @param {string} project_name Required name
     * @param {V1Project} body Project body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public updateProject(owner: string, project_name: string, body: V1Project, options?: any) {
        return ProjectsV1ApiFp(this.configuration).updateProject(owner, project_name, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Upload artifact to a store via project access
     * @param {string} owner Owner of the namespace
     * @param {string} project Project having access to the store
     * @param {string} uuid Unique integer identifier of the entity
     * @param {any} uploadfile The file to upload.
     * @param {string} [path] File path query params.
     * @param {boolean} [overwrite] File path query params.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public uploadProjectArtifact(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any) {
        return ProjectsV1ApiFp(this.configuration).uploadProjectArtifact(owner, project, uuid, uploadfile, path, overwrite, options)(this.fetch, this.basePath);
    }

}

/**
 * RegistryAccessesV1Api - fetch parameter creator
 * @export
 */
export const RegistryAccessesV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1HostAccess} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRegistryAccess(owner: string, body: V1HostAccess, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createRegistryAccess.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createRegistryAccess.');
            }
            const localVarPath = `/api/v1/{owner}/registry_accesses`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1HostAccess" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRegistryAccess(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteRegistryAccess.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteRegistryAccess.');
            }
            const localVarPath = `/api/v1/{owner}/registry_accesses/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistryAccess(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRegistryAccess.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRegistryAccess.');
            }
            const localVarPath = `/api/v1/{owner}/registry_accesses/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRegistryAccessNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listRegistryAccessNames.');
            }
            const localVarPath = `/api/v1/{owner}/registry_accesses/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRegistryAccesses(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listRegistryAccesses.');
            }
            const localVarPath = `/api/v1/{owner}/registry_accesses`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} host_access_uuid UUID
         * @param {V1HostAccess} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRegistryAccess(owner: string, host_access_uuid: string, body: V1HostAccess, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchRegistryAccess.');
            }
            // verify required parameter 'host_access_uuid' is not null or undefined
            if (host_access_uuid === null || host_access_uuid === undefined) {
                throw new RequiredError('host_access_uuid','Required parameter host_access_uuid was null or undefined when calling patchRegistryAccess.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchRegistryAccess.');
            }
            const localVarPath = `/api/v1/{owner}/registry_accesses/{host_access.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"host_access.uuid"}}`, encodeURIComponent(String(host_access_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1HostAccess" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} host_access_uuid UUID
         * @param {V1HostAccess} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRegistryAccess(owner: string, host_access_uuid: string, body: V1HostAccess, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateRegistryAccess.');
            }
            // verify required parameter 'host_access_uuid' is not null or undefined
            if (host_access_uuid === null || host_access_uuid === undefined) {
                throw new RequiredError('host_access_uuid','Required parameter host_access_uuid was null or undefined when calling updateRegistryAccess.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateRegistryAccess.');
            }
            const localVarPath = `/api/v1/{owner}/registry_accesses/{host_access.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"host_access.uuid"}}`, encodeURIComponent(String(host_access_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1HostAccess" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegistryAccessesV1Api - functional programming interface
 * @export
 */
export const RegistryAccessesV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1HostAccess} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRegistryAccess(owner: string, body: V1HostAccess, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1HostAccess> {
            const localVarFetchArgs = RegistryAccessesV1ApiFetchParamCreator(configuration).createRegistryAccess(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRegistryAccess(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RegistryAccessesV1ApiFetchParamCreator(configuration).deleteRegistryAccess(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistryAccess(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1HostAccess> {
            const localVarFetchArgs = RegistryAccessesV1ApiFetchParamCreator(configuration).getRegistryAccess(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRegistryAccessNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListHostAccessesResponse> {
            const localVarFetchArgs = RegistryAccessesV1ApiFetchParamCreator(configuration).listRegistryAccessNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRegistryAccesses(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListHostAccessesResponse> {
            const localVarFetchArgs = RegistryAccessesV1ApiFetchParamCreator(configuration).listRegistryAccesses(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} host_access_uuid UUID
         * @param {V1HostAccess} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRegistryAccess(owner: string, host_access_uuid: string, body: V1HostAccess, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1HostAccess> {
            const localVarFetchArgs = RegistryAccessesV1ApiFetchParamCreator(configuration).patchRegistryAccess(owner, host_access_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} host_access_uuid UUID
         * @param {V1HostAccess} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRegistryAccess(owner: string, host_access_uuid: string, body: V1HostAccess, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1HostAccess> {
            const localVarFetchArgs = RegistryAccessesV1ApiFetchParamCreator(configuration).updateRegistryAccess(owner, host_access_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RegistryAccessesV1Api - factory interface
 * @export
 */
export const RegistryAccessesV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1HostAccess} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRegistryAccess(owner: string, body: V1HostAccess, options?: any) {
            return RegistryAccessesV1ApiFp(configuration).createRegistryAccess(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRegistryAccess(owner: string, uuid: string, options?: any) {
            return RegistryAccessesV1ApiFp(configuration).deleteRegistryAccess(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistryAccess(owner: string, uuid: string, options?: any) {
            return RegistryAccessesV1ApiFp(configuration).getRegistryAccess(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRegistryAccessNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return RegistryAccessesV1ApiFp(configuration).listRegistryAccessNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRegistryAccesses(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return RegistryAccessesV1ApiFp(configuration).listRegistryAccesses(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} host_access_uuid UUID
         * @param {V1HostAccess} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRegistryAccess(owner: string, host_access_uuid: string, body: V1HostAccess, options?: any) {
            return RegistryAccessesV1ApiFp(configuration).patchRegistryAccess(owner, host_access_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} host_access_uuid UUID
         * @param {V1HostAccess} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRegistryAccess(owner: string, host_access_uuid: string, body: V1HostAccess, options?: any) {
            return RegistryAccessesV1ApiFp(configuration).updateRegistryAccess(owner, host_access_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * RegistryAccessesV1Api - object-oriented interface
 * @export
 * @class RegistryAccessesV1Api
 * @extends {BaseAPI}
 */
export class RegistryAccessesV1Api extends BaseAPI {
    /**
     * 
     * @summary List runs
     * @param {string} owner Owner of the namespace
     * @param {V1HostAccess} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryAccessesV1Api
     */
    public createRegistryAccess(owner: string, body: V1HostAccess, options?: any) {
        return RegistryAccessesV1ApiFp(this.configuration).createRegistryAccess(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch run
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryAccessesV1Api
     */
    public deleteRegistryAccess(owner: string, uuid: string, options?: any) {
        return RegistryAccessesV1ApiFp(this.configuration).deleteRegistryAccess(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryAccessesV1Api
     */
    public getRegistryAccess(owner: string, uuid: string, options?: any) {
        return RegistryAccessesV1ApiFp(this.configuration).getRegistryAccess(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryAccessesV1Api
     */
    public listRegistryAccessNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return RegistryAccessesV1ApiFp(this.configuration).listRegistryAccessNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List archived runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryAccessesV1Api
     */
    public listRegistryAccesses(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return RegistryAccessesV1ApiFp(this.configuration).listRegistryAccesses(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update run
     * @param {string} owner Owner of the namespace
     * @param {string} host_access_uuid UUID
     * @param {V1HostAccess} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryAccessesV1Api
     */
    public patchRegistryAccess(owner: string, host_access_uuid: string, body: V1HostAccess, options?: any) {
        return RegistryAccessesV1ApiFp(this.configuration).patchRegistryAccess(owner, host_access_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run
     * @param {string} owner Owner of the namespace
     * @param {string} host_access_uuid UUID
     * @param {V1HostAccess} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryAccessesV1Api
     */
    public updateRegistryAccess(owner: string, host_access_uuid: string, body: V1HostAccess, options?: any) {
        return RegistryAccessesV1ApiFp(this.configuration).updateRegistryAccess(owner, host_access_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * RunsV1Api - fetch parameter creator
 * @export
 */
export const RunsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Archive run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling archiveRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling archiveRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling archiveRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/archive`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Bookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling bookmarkRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling bookmarkRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling bookmarkRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/bookmark`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restart run with copy
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options: any = {}): FetchArgs {
            // verify required parameter 'entity_owner' is not null or undefined
            if (entity_owner === null || entity_owner === undefined) {
                throw new RequiredError('entity_owner','Required parameter entity_owner was null or undefined when calling copyRun.');
            }
            // verify required parameter 'entity_project' is not null or undefined
            if (entity_project === null || entity_project === undefined) {
                throw new RequiredError('entity_project','Required parameter entity_project was null or undefined when calling copyRun.');
            }
            // verify required parameter 'entity_uuid' is not null or undefined
            if (entity_uuid === null || entity_uuid === undefined) {
                throw new RequiredError('entity_uuid','Required parameter entity_uuid was null or undefined when calling copyRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling copyRun.');
            }
            const localVarPath = `/api/v1/{entity.owner}/{entity.project}/runs/{entity.uuid}/copy`
                .replace(`{${"entity.owner"}}`, encodeURIComponent(String(entity_owner)))
                .replace(`{${"entity.project"}}`, encodeURIComponent(String(entity_project)))
                .replace(`{${"entity.uuid"}}`, encodeURIComponent(String(entity_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Run" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRun(owner: string, project: string, body: V1Run, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling createRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Run" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run code ref
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1CodeRef} body Code ref object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunCodeRef(entity_owner: string, entity_project: string, entity_uuid: string, body: V1CodeRef, options: any = {}): FetchArgs {
            // verify required parameter 'entity_owner' is not null or undefined
            if (entity_owner === null || entity_owner === undefined) {
                throw new RequiredError('entity_owner','Required parameter entity_owner was null or undefined when calling createRunCodeRef.');
            }
            // verify required parameter 'entity_project' is not null or undefined
            if (entity_project === null || entity_project === undefined) {
                throw new RequiredError('entity_project','Required parameter entity_project was null or undefined when calling createRunCodeRef.');
            }
            // verify required parameter 'entity_uuid' is not null or undefined
            if (entity_uuid === null || entity_uuid === undefined) {
                throw new RequiredError('entity_uuid','Required parameter entity_uuid was null or undefined when calling createRunCodeRef.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createRunCodeRef.');
            }
            const localVarPath = `/api/v1/{entity.owner}/{entity.project}/runs/{entity.uuid}/coderefs`
                .replace(`{${"entity.owner"}}`, encodeURIComponent(String(entity_owner)))
                .replace(`{${"entity.project"}}`, encodeURIComponent(String(entity_project)))
                .replace(`{${"entity.uuid"}}`, encodeURIComponent(String(entity_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1CodeRef" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1EntityStatusBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunStatus(owner: string, project: string, uuid: string, body: V1EntityStatusBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createRunStatus.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling createRunStatus.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling createRunStatus.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createRunStatus.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/statuses`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1EntityStatusBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling deleteRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRuns(owner: string, project: string, body: V1Uuids, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteRuns.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling deleteRuns.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling deleteRuns.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/delete`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Uuids" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run artifacts list
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {string} [path] Artifact filepath.
         * @param {number} [step] Artifact logging step.
         * @param {string} [type] Artifact type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunArtifactsTree(owner: string, project: string, uuid: string, path?: string, step?: number, type?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRunArtifactsTree.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getRunArtifactsTree.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRunArtifactsTree.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/artifacts/tree`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (step !== undefined) {
                localVarQueryParameter['step'] = step;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run logs get file
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {string} [path] Artifact filepath.
         * @param {number} [step] Artifact logging step.
         * @param {string} [type] Artifact type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunLogsFile(owner: string, project: string, uuid: string, path?: string, step?: number, type?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRunLogsFile.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getRunLogsFile.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRunLogsFile.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/logs/file`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (step !== undefined) {
                localVarQueryParameter['step'] = step;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run logs list
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {string} [path] Artifact filepath.
         * @param {number} [step] Artifact logging step.
         * @param {string} [type] Artifact type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunLogsTree(owner: string, project: string, uuid: string, path?: string, step?: number, type?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRunLogsTree.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getRunLogsTree.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRunLogsTree.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/logs/tree`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (step !== undefined) {
                localVarQueryParameter['step'] = step;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunStatuses(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRunStatuses.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getRunStatuses.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRunStatuses.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/statuses`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Impersonate run token
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        impersonateToken(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling impersonateToken.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling impersonateToken.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling impersonateToken.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/impersonate`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invalidate run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1ProjectEntityResourceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateRun(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling invalidateRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling invalidateRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling invalidateRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling invalidateRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/invalidate`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ProjectEntityResourceRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invalidate runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateRuns(owner: string, project: string, body: V1Uuids, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling invalidateRuns.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling invalidateRuns.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling invalidateRuns.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/invalidate`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Uuids" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling listArchivedRuns.');
            }
            const localVarPath = `/api/v1/archives/{user}/runs`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling listBookmarkedRuns.');
            }
            const localVarPath = `/api/v1/bookmarks/{user}/runs`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuns(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listRuns.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling listRuns.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} run_uuid UUID
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRun(owner: string, project: string, run_uuid: string, body: V1Run, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling patchRun.');
            }
            // verify required parameter 'run_uuid' is not null or undefined
            if (run_uuid === null || run_uuid === undefined) {
                throw new RequiredError('run_uuid','Required parameter run_uuid was null or undefined when calling patchRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{run.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"run.uuid"}}`, encodeURIComponent(String(run_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Run" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restart run
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options: any = {}): FetchArgs {
            // verify required parameter 'entity_owner' is not null or undefined
            if (entity_owner === null || entity_owner === undefined) {
                throw new RequiredError('entity_owner','Required parameter entity_owner was null or undefined when calling restartRun.');
            }
            // verify required parameter 'entity_project' is not null or undefined
            if (entity_project === null || entity_project === undefined) {
                throw new RequiredError('entity_project','Required parameter entity_project was null or undefined when calling restartRun.');
            }
            // verify required parameter 'entity_uuid' is not null or undefined
            if (entity_uuid === null || entity_uuid === undefined) {
                throw new RequiredError('entity_uuid','Required parameter entity_uuid was null or undefined when calling restartRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling restartRun.');
            }
            const localVarPath = `/api/v1/{entity.owner}/{entity.project}/runs/{entity.uuid}/restart`
                .replace(`{${"entity.owner"}}`, encodeURIComponent(String(entity_owner)))
                .replace(`{${"entity.project"}}`, encodeURIComponent(String(entity_project)))
                .replace(`{${"entity.uuid"}}`, encodeURIComponent(String(entity_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Run" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling restoreRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling restoreRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling restoreRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/restore`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resume run
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options: any = {}): FetchArgs {
            // verify required parameter 'entity_owner' is not null or undefined
            if (entity_owner === null || entity_owner === undefined) {
                throw new RequiredError('entity_owner','Required parameter entity_owner was null or undefined when calling resumeRun.');
            }
            // verify required parameter 'entity_project' is not null or undefined
            if (entity_project === null || entity_project === undefined) {
                throw new RequiredError('entity_project','Required parameter entity_project was null or undefined when calling resumeRun.');
            }
            // verify required parameter 'entity_uuid' is not null or undefined
            if (entity_uuid === null || entity_uuid === undefined) {
                throw new RequiredError('entity_uuid','Required parameter entity_uuid was null or undefined when calling resumeRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling resumeRun.');
            }
            const localVarPath = `/api/v1/{entity.owner}/{entity.project}/runs/{entity.uuid}/resume`
                .replace(`{${"entity.owner"}}`, encodeURIComponent(String(entity_owner)))
                .replace(`{${"entity.project"}}`, encodeURIComponent(String(entity_project)))
                .replace(`{${"entity.uuid"}}`, encodeURIComponent(String(entity_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Run" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1ProjectEntityResourceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRunTensorboard(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling startRunTensorboard.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling startRunTensorboard.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling startRunTensorboard.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling startRunTensorboard.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/tensorboard/start`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ProjectEntityResourceRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling stopRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling stopRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling stopRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/stop`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRunTensorboard(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling stopRunTensorboard.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling stopRunTensorboard.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling stopRunTensorboard.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/tensorboard/stop`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRuns(owner: string, project: string, body: V1Uuids, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling stopRuns.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling stopRuns.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling stopRuns.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/stop`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Uuids" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unbookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbookmarkRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling unbookmarkRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling unbookmarkRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling unbookmarkRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/unbookmark`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} run_uuid UUID
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRun(owner: string, project: string, run_uuid: string, body: V1Run, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling updateRun.');
            }
            // verify required parameter 'run_uuid' is not null or undefined
            if (run_uuid === null || run_uuid === undefined) {
                throw new RequiredError('run_uuid','Required parameter run_uuid was null or undefined when calling updateRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{run.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"run.uuid"}}`, encodeURIComponent(String(run_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Run" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload an artifact file to a store via run access
         * @param {string} owner Owner of the namespace
         * @param {string} project Project having access to the store
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRunArtifact(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling uploadRunArtifact.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling uploadRunArtifact.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling uploadRunArtifact.');
            }
            // verify required parameter 'uploadfile' is not null or undefined
            if (uploadfile === null || uploadfile === undefined) {
                throw new RequiredError('uploadfile','Required parameter uploadfile was null or undefined when calling uploadRunArtifact.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/artifacts/upload`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (overwrite !== undefined) {
                localVarQueryParameter['overwrite'] = overwrite;
            }

            if (uploadfile !== undefined) {
                localVarFormParams.set('uploadfile', uploadfile as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload a logs file to a store via run access
         * @param {string} owner Owner of the namespace
         * @param {string} project Project having access to the store
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRunLogs(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling uploadRunLogs.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling uploadRunLogs.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling uploadRunLogs.');
            }
            // verify required parameter 'uploadfile' is not null or undefined
            if (uploadfile === null || uploadfile === undefined) {
                throw new RequiredError('uploadfile','Required parameter uploadfile was null or undefined when calling uploadRunLogs.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/logs/upload`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (overwrite !== undefined) {
                localVarQueryParameter['overwrite'] = overwrite;
            }

            if (uploadfile !== undefined) {
                localVarFormParams.set('uploadfile', uploadfile as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RunsV1Api - functional programming interface
 * @export
 */
export const RunsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Archive run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).archiveRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Bookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).bookmarkRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Restart run with copy
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).copyRun(entity_owner, entity_project, entity_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRun(owner: string, project: string, body: V1Run, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).createRun(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run code ref
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1CodeRef} body Code ref object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunCodeRef(entity_owner: string, entity_project: string, entity_uuid: string, body: V1CodeRef, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).createRunCodeRef(entity_owner, entity_project, entity_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1EntityStatusBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunStatus(owner: string, project: string, uuid: string, body: V1EntityStatusBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Status> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).createRunStatus(owner, project, uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).deleteRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRuns(owner: string, project: string, body: V1Uuids, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).deleteRuns(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).getRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run artifacts list
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {string} [path] Artifact filepath.
         * @param {number} [step] Artifact logging step.
         * @param {string} [type] Artifact type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunArtifactsTree(owner: string, project: string, uuid: string, path?: string, step?: number, type?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ArtifactTreeResponse> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).getRunArtifactsTree(owner, project, uuid, path, step, type, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run logs get file
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {string} [path] Artifact filepath.
         * @param {number} [step] Artifact logging step.
         * @param {string} [type] Artifact type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunLogsFile(owner: string, project: string, uuid: string, path?: string, step?: number, type?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).getRunLogsFile(owner, project, uuid, path, step, type, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run logs list
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {string} [path] Artifact filepath.
         * @param {number} [step] Artifact logging step.
         * @param {string} [type] Artifact type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunLogsTree(owner: string, project: string, uuid: string, path?: string, step?: number, type?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ArtifactTreeResponse> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).getRunLogsTree(owner, project, uuid, path, step, type, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunStatuses(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Status> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).getRunStatuses(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Impersonate run token
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        impersonateToken(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Auth> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).impersonateToken(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Invalidate run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1ProjectEntityResourceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateRun(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).invalidateRun(owner, project, uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Invalidate runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateRuns(owner: string, project: string, body: V1Uuids, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).invalidateRuns(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListRunsResponse> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).listArchivedRuns(user, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListRunsResponse> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).listBookmarkedRuns(user, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuns(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListRunsResponse> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).listRuns(owner, project, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} run_uuid UUID
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRun(owner: string, project: string, run_uuid: string, body: V1Run, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).patchRun(owner, project, run_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Restart run
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).restartRun(entity_owner, entity_project, entity_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Restore run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).restoreRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Resume run
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).resumeRun(entity_owner, entity_project, entity_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Start run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1ProjectEntityResourceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRunTensorboard(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).startRunTensorboard(owner, project, uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).stopRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stop run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRunTensorboard(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).stopRunTensorboard(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stop runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRuns(owner: string, project: string, body: V1Uuids, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).stopRuns(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Unbookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbookmarkRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).unbookmarkRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} run_uuid UUID
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRun(owner: string, project: string, run_uuid: string, body: V1Run, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).updateRun(owner, project, run_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Upload an artifact file to a store via run access
         * @param {string} owner Owner of the namespace
         * @param {string} project Project having access to the store
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRunArtifact(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).uploadRunArtifact(owner, project, uuid, uploadfile, path, overwrite, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Upload a logs file to a store via run access
         * @param {string} owner Owner of the namespace
         * @param {string} project Project having access to the store
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRunLogs(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).uploadRunLogs(owner, project, uuid, uploadfile, path, overwrite, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RunsV1Api - factory interface
 * @export
 */
export const RunsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Archive run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveRun(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).archiveRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Bookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkRun(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).bookmarkRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Restart run with copy
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any) {
            return RunsV1ApiFp(configuration).copyRun(entity_owner, entity_project, entity_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRun(owner: string, project: string, body: V1Run, options?: any) {
            return RunsV1ApiFp(configuration).createRun(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run code ref
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1CodeRef} body Code ref object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunCodeRef(entity_owner: string, entity_project: string, entity_uuid: string, body: V1CodeRef, options?: any) {
            return RunsV1ApiFp(configuration).createRunCodeRef(entity_owner, entity_project, entity_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1EntityStatusBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunStatus(owner: string, project: string, uuid: string, body: V1EntityStatusBodyRequest, options?: any) {
            return RunsV1ApiFp(configuration).createRunStatus(owner, project, uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRun(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).deleteRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRuns(owner: string, project: string, body: V1Uuids, options?: any) {
            return RunsV1ApiFp(configuration).deleteRuns(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRun(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).getRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run artifacts list
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {string} [path] Artifact filepath.
         * @param {number} [step] Artifact logging step.
         * @param {string} [type] Artifact type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunArtifactsTree(owner: string, project: string, uuid: string, path?: string, step?: number, type?: string, options?: any) {
            return RunsV1ApiFp(configuration).getRunArtifactsTree(owner, project, uuid, path, step, type, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run logs get file
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {string} [path] Artifact filepath.
         * @param {number} [step] Artifact logging step.
         * @param {string} [type] Artifact type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunLogsFile(owner: string, project: string, uuid: string, path?: string, step?: number, type?: string, options?: any) {
            return RunsV1ApiFp(configuration).getRunLogsFile(owner, project, uuid, path, step, type, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run logs list
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {string} [path] Artifact filepath.
         * @param {number} [step] Artifact logging step.
         * @param {string} [type] Artifact type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunLogsTree(owner: string, project: string, uuid: string, path?: string, step?: number, type?: string, options?: any) {
            return RunsV1ApiFp(configuration).getRunLogsTree(owner, project, uuid, path, step, type, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunStatuses(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).getRunStatuses(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Impersonate run token
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        impersonateToken(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).impersonateToken(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Invalidate run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1ProjectEntityResourceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateRun(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options?: any) {
            return RunsV1ApiFp(configuration).invalidateRun(owner, project, uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Invalidate runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateRuns(owner: string, project: string, body: V1Uuids, options?: any) {
            return RunsV1ApiFp(configuration).invalidateRuns(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return RunsV1ApiFp(configuration).listArchivedRuns(user, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return RunsV1ApiFp(configuration).listBookmarkedRuns(user, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuns(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return RunsV1ApiFp(configuration).listRuns(owner, project, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} run_uuid UUID
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRun(owner: string, project: string, run_uuid: string, body: V1Run, options?: any) {
            return RunsV1ApiFp(configuration).patchRun(owner, project, run_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Restart run
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any) {
            return RunsV1ApiFp(configuration).restartRun(entity_owner, entity_project, entity_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Restore run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreRun(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).restoreRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Resume run
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any) {
            return RunsV1ApiFp(configuration).resumeRun(entity_owner, entity_project, entity_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Start run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1ProjectEntityResourceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRunTensorboard(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options?: any) {
            return RunsV1ApiFp(configuration).startRunTensorboard(owner, project, uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRun(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).stopRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stop run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRunTensorboard(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).stopRunTensorboard(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stop runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRuns(owner: string, project: string, body: V1Uuids, options?: any) {
            return RunsV1ApiFp(configuration).stopRuns(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Unbookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbookmarkRun(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).unbookmarkRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} run_uuid UUID
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRun(owner: string, project: string, run_uuid: string, body: V1Run, options?: any) {
            return RunsV1ApiFp(configuration).updateRun(owner, project, run_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Upload an artifact file to a store via run access
         * @param {string} owner Owner of the namespace
         * @param {string} project Project having access to the store
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRunArtifact(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any) {
            return RunsV1ApiFp(configuration).uploadRunArtifact(owner, project, uuid, uploadfile, path, overwrite, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Upload a logs file to a store via run access
         * @param {string} owner Owner of the namespace
         * @param {string} project Project having access to the store
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRunLogs(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any) {
            return RunsV1ApiFp(configuration).uploadRunLogs(owner, project, uuid, uploadfile, path, overwrite, options)(fetch, basePath);
        },
    };
};

/**
 * RunsV1Api - object-oriented interface
 * @export
 * @class RunsV1Api
 * @extends {BaseAPI}
 */
export class RunsV1Api extends BaseAPI {
    /**
     * 
     * @summary Archive run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public archiveRun(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).archiveRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Bookmark run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public bookmarkRun(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).bookmarkRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Restart run with copy
     * @param {string} entity_owner Owner of the namespace
     * @param {string} entity_project Project where the experiement will be assigned
     * @param {string} entity_uuid Unique integer identifier of the entity
     * @param {V1Run} body Run object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public copyRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any) {
        return RunsV1ApiFp(this.configuration).copyRun(entity_owner, entity_project, entity_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {V1Run} body Run object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public createRun(owner: string, project: string, body: V1Run, options?: any) {
        return RunsV1ApiFp(this.configuration).createRun(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run code ref
     * @param {string} entity_owner Owner of the namespace
     * @param {string} entity_project Project where the experiement will be assigned
     * @param {string} entity_uuid Unique integer identifier of the entity
     * @param {V1CodeRef} body Code ref object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public createRunCodeRef(entity_owner: string, entity_project: string, entity_uuid: string, body: V1CodeRef, options?: any) {
        return RunsV1ApiFp(this.configuration).createRunCodeRef(entity_owner, entity_project, entity_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run status
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {V1EntityStatusBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public createRunStatus(owner: string, project: string, uuid: string, body: V1EntityStatusBodyRequest, options?: any) {
        return RunsV1ApiFp(this.configuration).createRunStatus(owner, project, uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public deleteRun(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).deleteRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {V1Uuids} body Uuids of the entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public deleteRuns(owner: string, project: string, body: V1Uuids, options?: any) {
        return RunsV1ApiFp(this.configuration).deleteRuns(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public getRun(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).getRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run artifacts list
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {string} [path] Artifact filepath.
     * @param {number} [step] Artifact logging step.
     * @param {string} [type] Artifact type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public getRunArtifactsTree(owner: string, project: string, uuid: string, path?: string, step?: number, type?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).getRunArtifactsTree(owner, project, uuid, path, step, type, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run logs get file
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {string} [path] Artifact filepath.
     * @param {number} [step] Artifact logging step.
     * @param {string} [type] Artifact type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public getRunLogsFile(owner: string, project: string, uuid: string, path?: string, step?: number, type?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).getRunLogsFile(owner, project, uuid, path, step, type, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run logs list
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {string} [path] Artifact filepath.
     * @param {number} [step] Artifact logging step.
     * @param {string} [type] Artifact type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public getRunLogsTree(owner: string, project: string, uuid: string, path?: string, step?: number, type?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).getRunLogsTree(owner, project, uuid, path, step, type, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run status
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public getRunStatuses(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).getRunStatuses(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Impersonate run token
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public impersonateToken(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).impersonateToken(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Invalidate run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {V1ProjectEntityResourceRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public invalidateRun(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options?: any) {
        return RunsV1ApiFp(this.configuration).invalidateRun(owner, project, uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Invalidate runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {V1Uuids} body Uuids of the entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public invalidateRuns(owner: string, project: string, body: V1Uuids, options?: any) {
        return RunsV1ApiFp(this.configuration).invalidateRuns(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List archived runs for user
     * @param {string} user User
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public listArchivedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).listArchivedRuns(user, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked runs for user
     * @param {string} user User
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public listBookmarkedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).listBookmarkedRuns(user, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public listRuns(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).listRuns(owner, project, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} run_uuid UUID
     * @param {V1Run} body Run object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public patchRun(owner: string, project: string, run_uuid: string, body: V1Run, options?: any) {
        return RunsV1ApiFp(this.configuration).patchRun(owner, project, run_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Restart run
     * @param {string} entity_owner Owner of the namespace
     * @param {string} entity_project Project where the experiement will be assigned
     * @param {string} entity_uuid Unique integer identifier of the entity
     * @param {V1Run} body Run object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public restartRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any) {
        return RunsV1ApiFp(this.configuration).restartRun(entity_owner, entity_project, entity_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Restore run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public restoreRun(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).restoreRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Resume run
     * @param {string} entity_owner Owner of the namespace
     * @param {string} entity_project Project where the experiement will be assigned
     * @param {string} entity_uuid Unique integer identifier of the entity
     * @param {V1Run} body Run object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public resumeRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any) {
        return RunsV1ApiFp(this.configuration).resumeRun(entity_owner, entity_project, entity_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Start run tensorboard
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {V1ProjectEntityResourceRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public startRunTensorboard(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options?: any) {
        return RunsV1ApiFp(this.configuration).startRunTensorboard(owner, project, uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stop run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public stopRun(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).stopRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stop run tensorboard
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public stopRunTensorboard(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).stopRunTensorboard(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stop runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {V1Uuids} body Uuids of the entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public stopRuns(owner: string, project: string, body: V1Uuids, options?: any) {
        return RunsV1ApiFp(this.configuration).stopRuns(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Unbookmark run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public unbookmarkRun(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).unbookmarkRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} run_uuid UUID
     * @param {V1Run} body Run object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public updateRun(owner: string, project: string, run_uuid: string, body: V1Run, options?: any) {
        return RunsV1ApiFp(this.configuration).updateRun(owner, project, run_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Upload an artifact file to a store via run access
     * @param {string} owner Owner of the namespace
     * @param {string} project Project having access to the store
     * @param {string} uuid Unique integer identifier of the entity
     * @param {any} uploadfile The file to upload.
     * @param {string} [path] File path query params.
     * @param {boolean} [overwrite] File path query params.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public uploadRunArtifact(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any) {
        return RunsV1ApiFp(this.configuration).uploadRunArtifact(owner, project, uuid, uploadfile, path, overwrite, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Upload a logs file to a store via run access
     * @param {string} owner Owner of the namespace
     * @param {string} project Project having access to the store
     * @param {string} uuid Unique integer identifier of the entity
     * @param {any} uploadfile The file to upload.
     * @param {string} [path] File path query params.
     * @param {boolean} [overwrite] File path query params.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public uploadRunLogs(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any) {
        return RunsV1ApiFp(this.configuration).uploadRunLogs(owner, project, uuid, uploadfile, path, overwrite, options)(this.fetch, this.basePath);
    }

}

/**
 * SearchV1Api - fetch parameter creator
 * @export
 */
export const SearchV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Search} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSearch(owner: string, project: string, body: V1Search, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createSearch.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling createSearch.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createSearch.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/searches`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Search" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSearch(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteSearch.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling deleteSearch.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteSearch.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/searches/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearch(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getSearch.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getSearch.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getSearch.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/searches/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSearches(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listSearches.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling listSearches.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/searches`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} search_uuid UUID
         * @param {V1Search} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSearch(owner: string, project: string, search_uuid: string, body: V1Search, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchSearch.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling patchSearch.');
            }
            // verify required parameter 'search_uuid' is not null or undefined
            if (search_uuid === null || search_uuid === undefined) {
                throw new RequiredError('search_uuid','Required parameter search_uuid was null or undefined when calling patchSearch.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchSearch.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/searches/{search.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"search.uuid"}}`, encodeURIComponent(String(search_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Search" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} search_uuid UUID
         * @param {V1Search} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSearch(owner: string, project: string, search_uuid: string, body: V1Search, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateSearch.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling updateSearch.');
            }
            // verify required parameter 'search_uuid' is not null or undefined
            if (search_uuid === null || search_uuid === undefined) {
                throw new RequiredError('search_uuid','Required parameter search_uuid was null or undefined when calling updateSearch.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateSearch.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/searches/{search.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"search.uuid"}}`, encodeURIComponent(String(search_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Search" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchV1Api - functional programming interface
 * @export
 */
export const SearchV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Search} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSearch(owner: string, project: string, body: V1Search, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Search> {
            const localVarFetchArgs = SearchV1ApiFetchParamCreator(configuration).createSearch(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSearch(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SearchV1ApiFetchParamCreator(configuration).deleteSearch(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearch(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Search> {
            const localVarFetchArgs = SearchV1ApiFetchParamCreator(configuration).getSearch(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSearches(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListSearchesResponse> {
            const localVarFetchArgs = SearchV1ApiFetchParamCreator(configuration).listSearches(owner, project, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} search_uuid UUID
         * @param {V1Search} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSearch(owner: string, project: string, search_uuid: string, body: V1Search, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Search> {
            const localVarFetchArgs = SearchV1ApiFetchParamCreator(configuration).patchSearch(owner, project, search_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} search_uuid UUID
         * @param {V1Search} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSearch(owner: string, project: string, search_uuid: string, body: V1Search, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Search> {
            const localVarFetchArgs = SearchV1ApiFetchParamCreator(configuration).updateSearch(owner, project, search_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SearchV1Api - factory interface
 * @export
 */
export const SearchV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Search} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSearch(owner: string, project: string, body: V1Search, options?: any) {
            return SearchV1ApiFp(configuration).createSearch(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSearch(owner: string, project: string, uuid: string, options?: any) {
            return SearchV1ApiFp(configuration).deleteSearch(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearch(owner: string, project: string, uuid: string, options?: any) {
            return SearchV1ApiFp(configuration).getSearch(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSearches(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return SearchV1ApiFp(configuration).listSearches(owner, project, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} search_uuid UUID
         * @param {V1Search} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSearch(owner: string, project: string, search_uuid: string, body: V1Search, options?: any) {
            return SearchV1ApiFp(configuration).patchSearch(owner, project, search_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} search_uuid UUID
         * @param {V1Search} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSearch(owner: string, project: string, search_uuid: string, body: V1Search, options?: any) {
            return SearchV1ApiFp(configuration).updateSearch(owner, project, search_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * SearchV1Api - object-oriented interface
 * @export
 * @class SearchV1Api
 * @extends {BaseAPI}
 */
export class SearchV1Api extends BaseAPI {
    /**
     * 
     * @summary List archived runs for user
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {V1Search} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchV1Api
     */
    public createSearch(owner: string, project: string, body: V1Search, options?: any) {
        return SearchV1ApiFp(this.configuration).createSearch(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchV1Api
     */
    public deleteSearch(owner: string, project: string, uuid: string, options?: any) {
        return SearchV1ApiFp(this.configuration).deleteSearch(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchV1Api
     */
    public getSearch(owner: string, project: string, uuid: string, options?: any) {
        return SearchV1ApiFp(this.configuration).getSearch(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked runs for user
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchV1Api
     */
    public listSearches(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return SearchV1ApiFp(this.configuration).listSearches(owner, project, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {string} search_uuid UUID
     * @param {V1Search} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchV1Api
     */
    public patchSearch(owner: string, project: string, search_uuid: string, body: V1Search, options?: any) {
        return SearchV1ApiFp(this.configuration).patchSearch(owner, project, search_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {string} search_uuid UUID
     * @param {V1Search} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchV1Api
     */
    public updateSearch(owner: string, project: string, search_uuid: string, body: V1Search, options?: any) {
        return SearchV1ApiFp(this.configuration).updateSearch(owner, project, search_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * UsersV1Api - fetch parameter creator
 * @export
 */
export const UsersV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersV1Api - functional programming interface
 * @export
 */
export const UsersV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1User> {
            const localVarFetchArgs = UsersV1ApiFetchParamCreator(configuration).getUser(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UsersV1Api - factory interface
 * @export
 */
export const UsersV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options?: any) {
            return UsersV1ApiFp(configuration).getUser(options)(fetch, basePath);
        },
    };
};

/**
 * UsersV1Api - object-oriented interface
 * @export
 * @class UsersV1Api
 * @extends {BaseAPI}
 */
export class UsersV1Api extends BaseAPI {
    /**
     * 
     * @summary List bookmarked runs for user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersV1Api
     */
    public getUser(options?: any) {
        return UsersV1ApiFp(this.configuration).getUser(options)(this.fetch, this.basePath);
    }

}

/**
 * VersionsV1Api - fetch parameter creator
 * @export
 */
export const VersionsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List archived runs for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogHandler(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/log_handler`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersions(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/version`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VersionsV1Api - functional programming interface
 * @export
 */
export const VersionsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List archived runs for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogHandler(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1LogHandler> {
            const localVarFetchArgs = VersionsV1ApiFetchParamCreator(configuration).getLogHandler(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersions(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Versions> {
            const localVarFetchArgs = VersionsV1ApiFetchParamCreator(configuration).getVersions(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * VersionsV1Api - factory interface
 * @export
 */
export const VersionsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List archived runs for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogHandler(options?: any) {
            return VersionsV1ApiFp(configuration).getLogHandler(options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersions(options?: any) {
            return VersionsV1ApiFp(configuration).getVersions(options)(fetch, basePath);
        },
    };
};

/**
 * VersionsV1Api - object-oriented interface
 * @export
 * @class VersionsV1Api
 * @extends {BaseAPI}
 */
export class VersionsV1Api extends BaseAPI {
    /**
     * 
     * @summary List archived runs for user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsV1Api
     */
    public getLogHandler(options?: any) {
        return VersionsV1ApiFp(this.configuration).getLogHandler(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked runs for user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsV1Api
     */
    public getVersions(options?: any) {
        return VersionsV1ApiFp(this.configuration).getVersions(options)(this.fetch, this.basePath);
    }

}

