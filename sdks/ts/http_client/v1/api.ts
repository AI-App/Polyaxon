// Copyright 2019 Polyaxon, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Polyaxon sdk
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.14.4
 * Contact: contact@polyaxon.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface V1ArtifactsStore
 */
export interface V1ArtifactsStore {
    /**
     * 
     * @type {string}
     * @memberof V1ArtifactsStore
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ArtifactsStore
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ArtifactsStore
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ArtifactsStore
     */
    readme?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1ArtifactsStore
     */
    tags?: Array<string>;
    /**
     * 
     * @type {Date}
     * @memberof V1ArtifactsStore
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1ArtifactsStore
     */
    updated_at?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof V1ArtifactsStore
     */
    frozen?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1ArtifactsStore
     */
    disabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1ArtifactsStore
     */
    k8s_secret?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ArtifactsStore
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ArtifactsStore
     */
    mount_path?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ArtifactsStore
     */
    host_path?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ArtifactsStore
     */
    volume_claim?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ArtifactsStore
     */
    bucket?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1ArtifactsStore
     */
    read_only?: boolean;
}

/**
 * 
 * @export
 * @interface V1Auth
 */
export interface V1Auth {
    /**
     * 
     * @type {string}
     * @memberof V1Auth
     */
    token?: string;
}

/**
 * 
 * @export
 * @interface V1CodeReference
 */
export interface V1CodeReference {
    /**
     * 
     * @type {string}
     * @memberof V1CodeReference
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CodeReference
     */
    commit?: string;
    /**
     * 
     * @type {Date}
     * @memberof V1CodeReference
     */
    updated_at?: Date;
    /**
     * 
     * @type {string}
     * @memberof V1CodeReference
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CodeReference
     */
    git_url?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1CodeReference
     */
    is_dirty?: boolean;
}

/**
 * 
 * @export
 * @interface V1CredsBodyRequest
 */
export interface V1CredsBodyRequest {
    /**
     * 
     * @type {string}
     * @memberof V1CredsBodyRequest
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CredsBodyRequest
     */
    password?: string;
}

/**
 * 
 * @export
 * @interface V1EntityStatusBodyRequest
 */
export interface V1EntityStatusBodyRequest {
    /**
     * 
     * @type {string}
     * @memberof V1EntityStatusBodyRequest
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EntityStatusBodyRequest
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EntityStatusBodyRequest
     */
    uuid?: string;
    /**
     * 
     * @type {V1StatusCondition}
     * @memberof V1EntityStatusBodyRequest
     */
    condition?: V1StatusCondition;
}

/**
 * 
 * @export
 * @interface V1HostAccess
 */
export interface V1HostAccess {
    /**
     * 
     * @type {string}
     * @memberof V1HostAccess
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1HostAccess
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1HostAccess
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof V1HostAccess
     */
    readme?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1HostAccess
     */
    tags?: Array<string>;
    /**
     * 
     * @type {Date}
     * @memberof V1HostAccess
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1HostAccess
     */
    updated_at?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof V1HostAccess
     */
    frozen?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1HostAccess
     */
    disabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1HostAccess
     */
    k8s_secret?: string;
    /**
     * 
     * @type {string}
     * @memberof V1HostAccess
     */
    host?: string;
}

/**
 * 
 * @export
 * @interface V1K8SResource
 */
export interface V1K8SResource {
    /**
     * 
     * @type {string}
     * @memberof V1K8SResource
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1K8SResource
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1K8SResource
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof V1K8SResource
     */
    readme?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1K8SResource
     */
    tags?: Array<string>;
    /**
     * 
     * @type {Date}
     * @memberof V1K8SResource
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1K8SResource
     */
    updated_at?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof V1K8SResource
     */
    frozen?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1K8SResource
     */
    disabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1K8SResource
     */
    mount_path?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1K8SResource
     */
    items?: Array<string>;
}

/**
 * 
 * @export
 * @interface V1ListArtifactsStoresResponse
 */
export interface V1ListArtifactsStoresResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListArtifactsStoresResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1ArtifactsStore>}
     * @memberof V1ListArtifactsStoresResponse
     */
    results?: Array<V1ArtifactsStore>;
    /**
     * 
     * @type {string}
     * @memberof V1ListArtifactsStoresResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListArtifactsStoresResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListCodeRefsResponse
 */
export interface V1ListCodeRefsResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListCodeRefsResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1CodeReference>}
     * @memberof V1ListCodeRefsResponse
     */
    results?: Array<V1CodeReference>;
    /**
     * 
     * @type {string}
     * @memberof V1ListCodeRefsResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListCodeRefsResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListHostAccessesResponse
 */
export interface V1ListHostAccessesResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListHostAccessesResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1HostAccess>}
     * @memberof V1ListHostAccessesResponse
     */
    results?: Array<V1HostAccess>;
    /**
     * 
     * @type {string}
     * @memberof V1ListHostAccessesResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListHostAccessesResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListK8SResourcesResponse
 */
export interface V1ListK8SResourcesResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListK8SResourcesResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1K8SResource>}
     * @memberof V1ListK8SResourcesResponse
     */
    results?: Array<V1K8SResource>;
    /**
     * 
     * @type {string}
     * @memberof V1ListK8SResourcesResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListK8SResourcesResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListProjectsResponse
 */
export interface V1ListProjectsResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListProjectsResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1Project>}
     * @memberof V1ListProjectsResponse
     */
    results?: Array<V1Project>;
    /**
     * 
     * @type {string}
     * @memberof V1ListProjectsResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListProjectsResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListRunsResponse
 */
export interface V1ListRunsResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListRunsResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1Run>}
     * @memberof V1ListRunsResponse
     */
    results?: Array<V1Run>;
    /**
     * 
     * @type {string}
     * @memberof V1ListRunsResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListRunsResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListSearchesResponse
 */
export interface V1ListSearchesResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListSearchesResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1Search>}
     * @memberof V1ListSearchesResponse
     */
    results?: Array<V1Search>;
    /**
     * 
     * @type {string}
     * @memberof V1ListSearchesResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListSearchesResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1LogHandler
 */
export interface V1LogHandler {
    /**
     * 
     * @type {string}
     * @memberof V1LogHandler
     */
    dsn?: string;
    /**
     * 
     * @type {string}
     * @memberof V1LogHandler
     */
    environment?: string;
}

/**
 * 
 * @export
 * @interface V1Project
 */
export interface V1Project {
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    description?: string;
    /**
     * 
     * @type {Date}
     * @memberof V1Project
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Project
     */
    updated_at?: Date;
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    is_public?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1Project
     */
    bookmarked?: boolean;
}

/**
 * 
 * @export
 * @interface V1ProjectEntityResourceRequest
 */
export interface V1ProjectEntityResourceRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ProjectEntityResourceRequest
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ProjectEntityResourceRequest
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ProjectEntityResourceRequest
     */
    uuid?: string;
}

/**
 * 
 * @export
 * @interface V1Run
 */
export interface V1Run {
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Run
     */
    tags?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof V1Run
     */
    deleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    project?: string;
    /**
     * 
     * @type {Date}
     * @memberof V1Run
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Run
     */
    updated_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Run
     */
    started_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Run
     */
    finished_at?: Date;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    is_managed?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    readme?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1Run
     */
    bookmarked?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1Run
     */
    inputs?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1Run
     */
    outputs?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1Run
     */
    run_env?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof V1Run
     */
    is_resume?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1Run
     */
    is_clone?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    cloning_strategy?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    pipeline?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    original?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    pipeline_name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    original_name?: string;
}

/**
 * 
 * @export
 * @interface V1Search
 */
export interface V1Search {
    /**
     * 
     * @type {string}
     * @memberof V1Search
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Search
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Search
     */
    query?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Search
     */
    meta?: string;
}

/**
 * 
 * @export
 * @interface V1Status
 */
export interface V1Status {
    /**
     * 
     * @type {string}
     * @memberof V1Status
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Status
     */
    status?: string;
    /**
     * 
     * @type {Array<V1StatusCondition>}
     * @memberof V1Status
     */
    status_conditions?: Array<V1StatusCondition>;
}

/**
 * 
 * @export
 * @interface V1StatusCondition
 */
export interface V1StatusCondition {
    /**
     * 
     * @type {string}
     * @memberof V1StatusCondition
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof V1StatusCondition
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof V1StatusCondition
     */
    reason?: string;
    /**
     * 
     * @type {string}
     * @memberof V1StatusCondition
     */
    message?: string;
    /**
     * 
     * @type {Date}
     * @memberof V1StatusCondition
     */
    last_update_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1StatusCondition
     */
    last_transition_time?: Date;
}

/**
 * 
 * @export
 * @interface V1User
 */
export interface V1User {
    /**
     * 
     * @type {string}
     * @memberof V1User
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof V1User
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof V1User
     */
    role?: string;
}

/**
 * 
 * @export
 * @interface V1Uuids
 */
export interface V1Uuids {
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Uuids
     */
    uuids?: Array<string>;
}

/**
 * 
 * @export
 * @interface V1Version
 */
export interface V1Version {
    /**
     * 
     * @type {string}
     * @memberof V1Version
     */
    min_version?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Version
     */
    latest_version?: string;
}

/**
 * 
 * @export
 * @interface V1Versions
 */
export interface V1Versions {
    /**
     * 
     * @type {string}
     * @memberof V1Versions
     */
    current_version?: string;
    /**
     * 
     * @type {V1Version}
     * @memberof V1Versions
     */
    cli?: V1Version;
    /**
     * 
     * @type {V1Version}
     * @memberof V1Versions
     */
    platform?: V1Version;
    /**
     * 
     * @type {V1Version}
     * @memberof V1Versions
     */
    agent?: V1Version;
}


/**
 * ArtifactsStoresV1Api - fetch parameter creator
 * @export
 */
export const ArtifactsStoresV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1ArtifactsStore} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifactsStore(owner: string, body: V1ArtifactsStore, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createArtifactsStore.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createArtifactsStore.');
            }
            const localVarPath = `/api/v1/{owner}/artifacts_stores`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ArtifactsStore" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifactsStore(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteArtifactsStore.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteArtifactsStore.');
            }
            const localVarPath = `/api/v1/{owner}/artifacts_stores/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactsStore(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getArtifactsStore.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getArtifactsStore.');
            }
            const localVarPath = `/api/v1/{owner}/artifacts_stores/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifactsStoreNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listArtifactsStoreNames.');
            }
            const localVarPath = `/api/v1/{owner}/artifacts_stores/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifactsStores(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listArtifactsStores.');
            }
            const localVarPath = `/api/v1/{owner}/artifacts_stores`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} artifact_store_uuid UUID
         * @param {V1ArtifactsStore} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchArtifactsStore(owner: string, artifact_store_uuid: string, body: V1ArtifactsStore, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchArtifactsStore.');
            }
            // verify required parameter 'artifact_store_uuid' is not null or undefined
            if (artifact_store_uuid === null || artifact_store_uuid === undefined) {
                throw new RequiredError('artifact_store_uuid','Required parameter artifact_store_uuid was null or undefined when calling patchArtifactsStore.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchArtifactsStore.');
            }
            const localVarPath = `/api/v1/{owner}/artifacts_stores/{artifact_store.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"artifact_store.uuid"}}`, encodeURIComponent(String(artifact_store_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ArtifactsStore" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} artifact_store_uuid UUID
         * @param {V1ArtifactsStore} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtifactsStore(owner: string, artifact_store_uuid: string, body: V1ArtifactsStore, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateArtifactsStore.');
            }
            // verify required parameter 'artifact_store_uuid' is not null or undefined
            if (artifact_store_uuid === null || artifact_store_uuid === undefined) {
                throw new RequiredError('artifact_store_uuid','Required parameter artifact_store_uuid was null or undefined when calling updateArtifactsStore.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateArtifactsStore.');
            }
            const localVarPath = `/api/v1/{owner}/artifacts_stores/{artifact_store.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"artifact_store.uuid"}}`, encodeURIComponent(String(artifact_store_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ArtifactsStore" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtifactsStoresV1Api - functional programming interface
 * @export
 */
export const ArtifactsStoresV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1ArtifactsStore} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifactsStore(owner: string, body: V1ArtifactsStore, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ArtifactsStore> {
            const localVarFetchArgs = ArtifactsStoresV1ApiFetchParamCreator(configuration).createArtifactsStore(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifactsStore(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ArtifactsStoresV1ApiFetchParamCreator(configuration).deleteArtifactsStore(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactsStore(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ArtifactsStore> {
            const localVarFetchArgs = ArtifactsStoresV1ApiFetchParamCreator(configuration).getArtifactsStore(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifactsStoreNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListArtifactsStoresResponse> {
            const localVarFetchArgs = ArtifactsStoresV1ApiFetchParamCreator(configuration).listArtifactsStoreNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifactsStores(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListArtifactsStoresResponse> {
            const localVarFetchArgs = ArtifactsStoresV1ApiFetchParamCreator(configuration).listArtifactsStores(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} artifact_store_uuid UUID
         * @param {V1ArtifactsStore} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchArtifactsStore(owner: string, artifact_store_uuid: string, body: V1ArtifactsStore, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ArtifactsStore> {
            const localVarFetchArgs = ArtifactsStoresV1ApiFetchParamCreator(configuration).patchArtifactsStore(owner, artifact_store_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} artifact_store_uuid UUID
         * @param {V1ArtifactsStore} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtifactsStore(owner: string, artifact_store_uuid: string, body: V1ArtifactsStore, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ArtifactsStore> {
            const localVarFetchArgs = ArtifactsStoresV1ApiFetchParamCreator(configuration).updateArtifactsStore(owner, artifact_store_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ArtifactsStoresV1Api - factory interface
 * @export
 */
export const ArtifactsStoresV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1ArtifactsStore} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifactsStore(owner: string, body: V1ArtifactsStore, options?: any) {
            return ArtifactsStoresV1ApiFp(configuration).createArtifactsStore(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifactsStore(owner: string, uuid: string, options?: any) {
            return ArtifactsStoresV1ApiFp(configuration).deleteArtifactsStore(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactsStore(owner: string, uuid: string, options?: any) {
            return ArtifactsStoresV1ApiFp(configuration).getArtifactsStore(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifactsStoreNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ArtifactsStoresV1ApiFp(configuration).listArtifactsStoreNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifactsStores(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ArtifactsStoresV1ApiFp(configuration).listArtifactsStores(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} artifact_store_uuid UUID
         * @param {V1ArtifactsStore} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchArtifactsStore(owner: string, artifact_store_uuid: string, body: V1ArtifactsStore, options?: any) {
            return ArtifactsStoresV1ApiFp(configuration).patchArtifactsStore(owner, artifact_store_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} artifact_store_uuid UUID
         * @param {V1ArtifactsStore} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtifactsStore(owner: string, artifact_store_uuid: string, body: V1ArtifactsStore, options?: any) {
            return ArtifactsStoresV1ApiFp(configuration).updateArtifactsStore(owner, artifact_store_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * ArtifactsStoresV1Api - object-oriented interface
 * @export
 * @class ArtifactsStoresV1Api
 * @extends {BaseAPI}
 */
export class ArtifactsStoresV1Api extends BaseAPI {
    /**
     * 
     * @summary List runs
     * @param {string} owner Owner of the namespace
     * @param {V1ArtifactsStore} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsStoresV1Api
     */
    public createArtifactsStore(owner: string, body: V1ArtifactsStore, options?: any) {
        return ArtifactsStoresV1ApiFp(this.configuration).createArtifactsStore(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch run
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsStoresV1Api
     */
    public deleteArtifactsStore(owner: string, uuid: string, options?: any) {
        return ArtifactsStoresV1ApiFp(this.configuration).deleteArtifactsStore(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsStoresV1Api
     */
    public getArtifactsStore(owner: string, uuid: string, options?: any) {
        return ArtifactsStoresV1ApiFp(this.configuration).getArtifactsStore(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsStoresV1Api
     */
    public listArtifactsStoreNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ArtifactsStoresV1ApiFp(this.configuration).listArtifactsStoreNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List archived runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsStoresV1Api
     */
    public listArtifactsStores(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ArtifactsStoresV1ApiFp(this.configuration).listArtifactsStores(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update run
     * @param {string} owner Owner of the namespace
     * @param {string} artifact_store_uuid UUID
     * @param {V1ArtifactsStore} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsStoresV1Api
     */
    public patchArtifactsStore(owner: string, artifact_store_uuid: string, body: V1ArtifactsStore, options?: any) {
        return ArtifactsStoresV1ApiFp(this.configuration).patchArtifactsStore(owner, artifact_store_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run
     * @param {string} owner Owner of the namespace
     * @param {string} artifact_store_uuid UUID
     * @param {V1ArtifactsStore} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsStoresV1Api
     */
    public updateArtifactsStore(owner: string, artifact_store_uuid: string, body: V1ArtifactsStore, options?: any) {
        return ArtifactsStoresV1ApiFp(this.configuration).updateArtifactsStore(owner, artifact_store_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * AuthV1Api - fetch parameter creator
 * @export
 */
export const AuthV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {V1CredsBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body: V1CredsBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling login.');
            }
            const localVarPath = `/api/v1/users/token`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1CredsBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthV1Api - functional programming interface
 * @export
 */
export const AuthV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {V1CredsBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body: V1CredsBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Auth> {
            const localVarFetchArgs = AuthV1ApiFetchParamCreator(configuration).login(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuthV1Api - factory interface
 * @export
 */
export const AuthV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {V1CredsBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body: V1CredsBodyRequest, options?: any) {
            return AuthV1ApiFp(configuration).login(body, options)(fetch, basePath);
        },
    };
};

/**
 * AuthV1Api - object-oriented interface
 * @export
 * @class AuthV1Api
 * @extends {BaseAPI}
 */
export class AuthV1Api extends BaseAPI {
    /**
     * 
     * @summary List bookmarked runs for user
     * @param {V1CredsBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthV1Api
     */
    public login(body: V1CredsBodyRequest, options?: any) {
        return AuthV1ApiFp(this.configuration).login(body, options)(this.fetch, this.basePath);
    }

}

/**
 * GitAccessesV1Api - fetch parameter creator
 * @export
 */
export const GitAccessesV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1HostAccess} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGitAccess(owner: string, body: V1HostAccess, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createGitAccess.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createGitAccess.');
            }
            const localVarPath = `/api/v1/{owner}/git_accesses`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1HostAccess" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGitAccess(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteGitAccess.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteGitAccess.');
            }
            const localVarPath = `/api/v1/{owner}/git_accesses/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGitAccess(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getGitAccess.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getGitAccess.');
            }
            const localVarPath = `/api/v1/{owner}/git_accesses/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGitAccessNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listGitAccessNames.');
            }
            const localVarPath = `/api/v1/{owner}/git_accesses/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGitAccesses(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listGitAccesses.');
            }
            const localVarPath = `/api/v1/{owner}/git_accesses`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} host_access_uuid UUID
         * @param {V1HostAccess} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchGitAccess(owner: string, host_access_uuid: string, body: V1HostAccess, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchGitAccess.');
            }
            // verify required parameter 'host_access_uuid' is not null or undefined
            if (host_access_uuid === null || host_access_uuid === undefined) {
                throw new RequiredError('host_access_uuid','Required parameter host_access_uuid was null or undefined when calling patchGitAccess.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchGitAccess.');
            }
            const localVarPath = `/api/v1/{owner}/git_accesses/{host_access.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"host_access.uuid"}}`, encodeURIComponent(String(host_access_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1HostAccess" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} host_access_uuid UUID
         * @param {V1HostAccess} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGitAccess(owner: string, host_access_uuid: string, body: V1HostAccess, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateGitAccess.');
            }
            // verify required parameter 'host_access_uuid' is not null or undefined
            if (host_access_uuid === null || host_access_uuid === undefined) {
                throw new RequiredError('host_access_uuid','Required parameter host_access_uuid was null or undefined when calling updateGitAccess.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateGitAccess.');
            }
            const localVarPath = `/api/v1/{owner}/git_accesses/{host_access.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"host_access.uuid"}}`, encodeURIComponent(String(host_access_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1HostAccess" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GitAccessesV1Api - functional programming interface
 * @export
 */
export const GitAccessesV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1HostAccess} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGitAccess(owner: string, body: V1HostAccess, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1HostAccess> {
            const localVarFetchArgs = GitAccessesV1ApiFetchParamCreator(configuration).createGitAccess(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGitAccess(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = GitAccessesV1ApiFetchParamCreator(configuration).deleteGitAccess(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGitAccess(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1HostAccess> {
            const localVarFetchArgs = GitAccessesV1ApiFetchParamCreator(configuration).getGitAccess(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGitAccessNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListHostAccessesResponse> {
            const localVarFetchArgs = GitAccessesV1ApiFetchParamCreator(configuration).listGitAccessNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGitAccesses(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListHostAccessesResponse> {
            const localVarFetchArgs = GitAccessesV1ApiFetchParamCreator(configuration).listGitAccesses(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} host_access_uuid UUID
         * @param {V1HostAccess} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchGitAccess(owner: string, host_access_uuid: string, body: V1HostAccess, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1HostAccess> {
            const localVarFetchArgs = GitAccessesV1ApiFetchParamCreator(configuration).patchGitAccess(owner, host_access_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} host_access_uuid UUID
         * @param {V1HostAccess} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGitAccess(owner: string, host_access_uuid: string, body: V1HostAccess, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1HostAccess> {
            const localVarFetchArgs = GitAccessesV1ApiFetchParamCreator(configuration).updateGitAccess(owner, host_access_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GitAccessesV1Api - factory interface
 * @export
 */
export const GitAccessesV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1HostAccess} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGitAccess(owner: string, body: V1HostAccess, options?: any) {
            return GitAccessesV1ApiFp(configuration).createGitAccess(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGitAccess(owner: string, uuid: string, options?: any) {
            return GitAccessesV1ApiFp(configuration).deleteGitAccess(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGitAccess(owner: string, uuid: string, options?: any) {
            return GitAccessesV1ApiFp(configuration).getGitAccess(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGitAccessNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return GitAccessesV1ApiFp(configuration).listGitAccessNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGitAccesses(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return GitAccessesV1ApiFp(configuration).listGitAccesses(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} host_access_uuid UUID
         * @param {V1HostAccess} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchGitAccess(owner: string, host_access_uuid: string, body: V1HostAccess, options?: any) {
            return GitAccessesV1ApiFp(configuration).patchGitAccess(owner, host_access_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} host_access_uuid UUID
         * @param {V1HostAccess} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGitAccess(owner: string, host_access_uuid: string, body: V1HostAccess, options?: any) {
            return GitAccessesV1ApiFp(configuration).updateGitAccess(owner, host_access_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * GitAccessesV1Api - object-oriented interface
 * @export
 * @class GitAccessesV1Api
 * @extends {BaseAPI}
 */
export class GitAccessesV1Api extends BaseAPI {
    /**
     * 
     * @summary List runs
     * @param {string} owner Owner of the namespace
     * @param {V1HostAccess} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GitAccessesV1Api
     */
    public createGitAccess(owner: string, body: V1HostAccess, options?: any) {
        return GitAccessesV1ApiFp(this.configuration).createGitAccess(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch run
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GitAccessesV1Api
     */
    public deleteGitAccess(owner: string, uuid: string, options?: any) {
        return GitAccessesV1ApiFp(this.configuration).deleteGitAccess(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GitAccessesV1Api
     */
    public getGitAccess(owner: string, uuid: string, options?: any) {
        return GitAccessesV1ApiFp(this.configuration).getGitAccess(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GitAccessesV1Api
     */
    public listGitAccessNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return GitAccessesV1ApiFp(this.configuration).listGitAccessNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List archived runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GitAccessesV1Api
     */
    public listGitAccesses(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return GitAccessesV1ApiFp(this.configuration).listGitAccesses(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update run
     * @param {string} owner Owner of the namespace
     * @param {string} host_access_uuid UUID
     * @param {V1HostAccess} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GitAccessesV1Api
     */
    public patchGitAccess(owner: string, host_access_uuid: string, body: V1HostAccess, options?: any) {
        return GitAccessesV1ApiFp(this.configuration).patchGitAccess(owner, host_access_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run
     * @param {string} owner Owner of the namespace
     * @param {string} host_access_uuid UUID
     * @param {V1HostAccess} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GitAccessesV1Api
     */
    public updateGitAccess(owner: string, host_access_uuid: string, body: V1HostAccess, options?: any) {
        return GitAccessesV1ApiFp(this.configuration).updateGitAccess(owner, host_access_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * K8SConfigMapsV1Api - fetch parameter creator
 * @export
 */
export const K8SConfigMapsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1K8SResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createK8SConfigMaps(owner: string, body: V1K8SResource, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createK8SConfigMaps.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createK8SConfigMaps.');
            }
            const localVarPath = `/api/v1/{owner}/k8s_config_maps`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1K8SResource" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteK8SConfigMap(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteK8SConfigMap.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteK8SConfigMap.');
            }
            const localVarPath = `/api/v1/{owner}/k8s_config_maps/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getK8SConfigMap(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getK8SConfigMap.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getK8SConfigMap.');
            }
            const localVarPath = `/api/v1/{owner}/k8s_config_maps/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8SConfigMapNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listK8SConfigMapNames.');
            }
            const localVarPath = `/api/v1/{owner}/k8s_config_maps/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8SConfigMaps(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listK8SConfigMaps.');
            }
            const localVarPath = `/api/v1/{owner}/k8s_config_maps`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} k8s_resource_uuid UUID
         * @param {V1K8SResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchK8SConfigMap(owner: string, k8s_resource_uuid: string, body: V1K8SResource, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchK8SConfigMap.');
            }
            // verify required parameter 'k8s_resource_uuid' is not null or undefined
            if (k8s_resource_uuid === null || k8s_resource_uuid === undefined) {
                throw new RequiredError('k8s_resource_uuid','Required parameter k8s_resource_uuid was null or undefined when calling patchK8SConfigMap.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchK8SConfigMap.');
            }
            const localVarPath = `/api/v1/{owner}/k8s_config_maps/{k8s_resource.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"k8s_resource.uuid"}}`, encodeURIComponent(String(k8s_resource_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1K8SResource" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} k8s_resource_uuid UUID
         * @param {V1K8SResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateK8SConfigMap(owner: string, k8s_resource_uuid: string, body: V1K8SResource, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateK8SConfigMap.');
            }
            // verify required parameter 'k8s_resource_uuid' is not null or undefined
            if (k8s_resource_uuid === null || k8s_resource_uuid === undefined) {
                throw new RequiredError('k8s_resource_uuid','Required parameter k8s_resource_uuid was null or undefined when calling updateK8SConfigMap.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateK8SConfigMap.');
            }
            const localVarPath = `/api/v1/{owner}/k8s_config_maps/{k8s_resource.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"k8s_resource.uuid"}}`, encodeURIComponent(String(k8s_resource_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1K8SResource" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * K8SConfigMapsV1Api - functional programming interface
 * @export
 */
export const K8SConfigMapsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1K8SResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createK8SConfigMaps(owner: string, body: V1K8SResource, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1K8SResource> {
            const localVarFetchArgs = K8SConfigMapsV1ApiFetchParamCreator(configuration).createK8SConfigMaps(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteK8SConfigMap(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = K8SConfigMapsV1ApiFetchParamCreator(configuration).deleteK8SConfigMap(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getK8SConfigMap(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1K8SResource> {
            const localVarFetchArgs = K8SConfigMapsV1ApiFetchParamCreator(configuration).getK8SConfigMap(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8SConfigMapNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListK8SResourcesResponse> {
            const localVarFetchArgs = K8SConfigMapsV1ApiFetchParamCreator(configuration).listK8SConfigMapNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8SConfigMaps(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListK8SResourcesResponse> {
            const localVarFetchArgs = K8SConfigMapsV1ApiFetchParamCreator(configuration).listK8SConfigMaps(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} k8s_resource_uuid UUID
         * @param {V1K8SResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchK8SConfigMap(owner: string, k8s_resource_uuid: string, body: V1K8SResource, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1K8SResource> {
            const localVarFetchArgs = K8SConfigMapsV1ApiFetchParamCreator(configuration).patchK8SConfigMap(owner, k8s_resource_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} k8s_resource_uuid UUID
         * @param {V1K8SResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateK8SConfigMap(owner: string, k8s_resource_uuid: string, body: V1K8SResource, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1K8SResource> {
            const localVarFetchArgs = K8SConfigMapsV1ApiFetchParamCreator(configuration).updateK8SConfigMap(owner, k8s_resource_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * K8SConfigMapsV1Api - factory interface
 * @export
 */
export const K8SConfigMapsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1K8SResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createK8SConfigMaps(owner: string, body: V1K8SResource, options?: any) {
            return K8SConfigMapsV1ApiFp(configuration).createK8SConfigMaps(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteK8SConfigMap(owner: string, uuid: string, options?: any) {
            return K8SConfigMapsV1ApiFp(configuration).deleteK8SConfigMap(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getK8SConfigMap(owner: string, uuid: string, options?: any) {
            return K8SConfigMapsV1ApiFp(configuration).getK8SConfigMap(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8SConfigMapNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return K8SConfigMapsV1ApiFp(configuration).listK8SConfigMapNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8SConfigMaps(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return K8SConfigMapsV1ApiFp(configuration).listK8SConfigMaps(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} k8s_resource_uuid UUID
         * @param {V1K8SResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchK8SConfigMap(owner: string, k8s_resource_uuid: string, body: V1K8SResource, options?: any) {
            return K8SConfigMapsV1ApiFp(configuration).patchK8SConfigMap(owner, k8s_resource_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} k8s_resource_uuid UUID
         * @param {V1K8SResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateK8SConfigMap(owner: string, k8s_resource_uuid: string, body: V1K8SResource, options?: any) {
            return K8SConfigMapsV1ApiFp(configuration).updateK8SConfigMap(owner, k8s_resource_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * K8SConfigMapsV1Api - object-oriented interface
 * @export
 * @class K8SConfigMapsV1Api
 * @extends {BaseAPI}
 */
export class K8SConfigMapsV1Api extends BaseAPI {
    /**
     * 
     * @summary List runs
     * @param {string} owner Owner of the namespace
     * @param {V1K8SResource} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof K8SConfigMapsV1Api
     */
    public createK8SConfigMaps(owner: string, body: V1K8SResource, options?: any) {
        return K8SConfigMapsV1ApiFp(this.configuration).createK8SConfigMaps(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch run
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof K8SConfigMapsV1Api
     */
    public deleteK8SConfigMap(owner: string, uuid: string, options?: any) {
        return K8SConfigMapsV1ApiFp(this.configuration).deleteK8SConfigMap(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof K8SConfigMapsV1Api
     */
    public getK8SConfigMap(owner: string, uuid: string, options?: any) {
        return K8SConfigMapsV1ApiFp(this.configuration).getK8SConfigMap(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof K8SConfigMapsV1Api
     */
    public listK8SConfigMapNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return K8SConfigMapsV1ApiFp(this.configuration).listK8SConfigMapNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List archived runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof K8SConfigMapsV1Api
     */
    public listK8SConfigMaps(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return K8SConfigMapsV1ApiFp(this.configuration).listK8SConfigMaps(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update run
     * @param {string} owner Owner of the namespace
     * @param {string} k8s_resource_uuid UUID
     * @param {V1K8SResource} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof K8SConfigMapsV1Api
     */
    public patchK8SConfigMap(owner: string, k8s_resource_uuid: string, body: V1K8SResource, options?: any) {
        return K8SConfigMapsV1ApiFp(this.configuration).patchK8SConfigMap(owner, k8s_resource_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run
     * @param {string} owner Owner of the namespace
     * @param {string} k8s_resource_uuid UUID
     * @param {V1K8SResource} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof K8SConfigMapsV1Api
     */
    public updateK8SConfigMap(owner: string, k8s_resource_uuid: string, body: V1K8SResource, options?: any) {
        return K8SConfigMapsV1ApiFp(this.configuration).updateK8SConfigMap(owner, k8s_resource_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * K8SSecretsV1Api - fetch parameter creator
 * @export
 */
export const K8SSecretsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1K8SResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createK8SSecrets(owner: string, body: V1K8SResource, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createK8SSecrets.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createK8SSecrets.');
            }
            const localVarPath = `/api/v1/{owner}/k8s_secrets`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1K8SResource" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteK8SSecret(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteK8SSecret.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteK8SSecret.');
            }
            const localVarPath = `/api/v1/{owner}/k8s_secrets/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getK8SSecret(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getK8SSecret.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getK8SSecret.');
            }
            const localVarPath = `/api/v1/{owner}/k8s_secrets/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8SSecretNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listK8SSecretNames.');
            }
            const localVarPath = `/api/v1/{owner}/k8s_secrets/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8SSecrets(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listK8SSecrets.');
            }
            const localVarPath = `/api/v1/{owner}/k8s_secrets`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} k8s_resource_uuid UUID
         * @param {V1K8SResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchK8SSecret(owner: string, k8s_resource_uuid: string, body: V1K8SResource, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchK8SSecret.');
            }
            // verify required parameter 'k8s_resource_uuid' is not null or undefined
            if (k8s_resource_uuid === null || k8s_resource_uuid === undefined) {
                throw new RequiredError('k8s_resource_uuid','Required parameter k8s_resource_uuid was null or undefined when calling patchK8SSecret.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchK8SSecret.');
            }
            const localVarPath = `/api/v1/{owner}/k8s_secrets/{k8s_resource.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"k8s_resource.uuid"}}`, encodeURIComponent(String(k8s_resource_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1K8SResource" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} k8s_resource_uuid UUID
         * @param {V1K8SResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateK8SSecret(owner: string, k8s_resource_uuid: string, body: V1K8SResource, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateK8SSecret.');
            }
            // verify required parameter 'k8s_resource_uuid' is not null or undefined
            if (k8s_resource_uuid === null || k8s_resource_uuid === undefined) {
                throw new RequiredError('k8s_resource_uuid','Required parameter k8s_resource_uuid was null or undefined when calling updateK8SSecret.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateK8SSecret.');
            }
            const localVarPath = `/api/v1/{owner}/k8s_secrets/{k8s_resource.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"k8s_resource.uuid"}}`, encodeURIComponent(String(k8s_resource_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1K8SResource" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * K8SSecretsV1Api - functional programming interface
 * @export
 */
export const K8SSecretsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1K8SResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createK8SSecrets(owner: string, body: V1K8SResource, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1K8SResource> {
            const localVarFetchArgs = K8SSecretsV1ApiFetchParamCreator(configuration).createK8SSecrets(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteK8SSecret(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = K8SSecretsV1ApiFetchParamCreator(configuration).deleteK8SSecret(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getK8SSecret(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1K8SResource> {
            const localVarFetchArgs = K8SSecretsV1ApiFetchParamCreator(configuration).getK8SSecret(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8SSecretNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListK8SResourcesResponse> {
            const localVarFetchArgs = K8SSecretsV1ApiFetchParamCreator(configuration).listK8SSecretNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8SSecrets(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListK8SResourcesResponse> {
            const localVarFetchArgs = K8SSecretsV1ApiFetchParamCreator(configuration).listK8SSecrets(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} k8s_resource_uuid UUID
         * @param {V1K8SResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchK8SSecret(owner: string, k8s_resource_uuid: string, body: V1K8SResource, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1K8SResource> {
            const localVarFetchArgs = K8SSecretsV1ApiFetchParamCreator(configuration).patchK8SSecret(owner, k8s_resource_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} k8s_resource_uuid UUID
         * @param {V1K8SResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateK8SSecret(owner: string, k8s_resource_uuid: string, body: V1K8SResource, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1K8SResource> {
            const localVarFetchArgs = K8SSecretsV1ApiFetchParamCreator(configuration).updateK8SSecret(owner, k8s_resource_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * K8SSecretsV1Api - factory interface
 * @export
 */
export const K8SSecretsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1K8SResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createK8SSecrets(owner: string, body: V1K8SResource, options?: any) {
            return K8SSecretsV1ApiFp(configuration).createK8SSecrets(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteK8SSecret(owner: string, uuid: string, options?: any) {
            return K8SSecretsV1ApiFp(configuration).deleteK8SSecret(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getK8SSecret(owner: string, uuid: string, options?: any) {
            return K8SSecretsV1ApiFp(configuration).getK8SSecret(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8SSecretNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return K8SSecretsV1ApiFp(configuration).listK8SSecretNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8SSecrets(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return K8SSecretsV1ApiFp(configuration).listK8SSecrets(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} k8s_resource_uuid UUID
         * @param {V1K8SResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchK8SSecret(owner: string, k8s_resource_uuid: string, body: V1K8SResource, options?: any) {
            return K8SSecretsV1ApiFp(configuration).patchK8SSecret(owner, k8s_resource_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} k8s_resource_uuid UUID
         * @param {V1K8SResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateK8SSecret(owner: string, k8s_resource_uuid: string, body: V1K8SResource, options?: any) {
            return K8SSecretsV1ApiFp(configuration).updateK8SSecret(owner, k8s_resource_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * K8SSecretsV1Api - object-oriented interface
 * @export
 * @class K8SSecretsV1Api
 * @extends {BaseAPI}
 */
export class K8SSecretsV1Api extends BaseAPI {
    /**
     * 
     * @summary List runs
     * @param {string} owner Owner of the namespace
     * @param {V1K8SResource} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof K8SSecretsV1Api
     */
    public createK8SSecrets(owner: string, body: V1K8SResource, options?: any) {
        return K8SSecretsV1ApiFp(this.configuration).createK8SSecrets(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch run
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof K8SSecretsV1Api
     */
    public deleteK8SSecret(owner: string, uuid: string, options?: any) {
        return K8SSecretsV1ApiFp(this.configuration).deleteK8SSecret(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof K8SSecretsV1Api
     */
    public getK8SSecret(owner: string, uuid: string, options?: any) {
        return K8SSecretsV1ApiFp(this.configuration).getK8SSecret(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof K8SSecretsV1Api
     */
    public listK8SSecretNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return K8SSecretsV1ApiFp(this.configuration).listK8SSecretNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List archived runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof K8SSecretsV1Api
     */
    public listK8SSecrets(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return K8SSecretsV1ApiFp(this.configuration).listK8SSecrets(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update run
     * @param {string} owner Owner of the namespace
     * @param {string} k8s_resource_uuid UUID
     * @param {V1K8SResource} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof K8SSecretsV1Api
     */
    public patchK8SSecret(owner: string, k8s_resource_uuid: string, body: V1K8SResource, options?: any) {
        return K8SSecretsV1ApiFp(this.configuration).patchK8SSecret(owner, k8s_resource_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run
     * @param {string} owner Owner of the namespace
     * @param {string} k8s_resource_uuid UUID
     * @param {V1K8SResource} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof K8SSecretsV1Api
     */
    public updateK8SSecret(owner: string, k8s_resource_uuid: string, body: V1K8SResource, options?: any) {
        return K8SSecretsV1ApiFp(this.configuration).updateK8SSecret(owner, k8s_resource_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * ProjectsV1Api - fetch parameter creator
 * @export
 */
export const ProjectsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveProject(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling archiveProject.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling archiveProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/archive`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invalidate run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkProject(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling bookmarkProject.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling bookmarkProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/bookmark`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(owner: string, body: V1Project, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createProject.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createProject.');
            }
            const localVarPath = `/api/v1/{owner}/projects/create`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Project" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteProject.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling deleteProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restart run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableProjectCI(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling disableProjectCI.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling disableProjectCI.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/ci`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restart run with copy
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableProjectCI(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling enableProjectCI.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling enableProjectCI.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/ci`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getProject.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling listArchivedProjects.');
            }
            const localVarPath = `/api/v1/archives/{user}/projects`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List runs
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling listBookmarkedProjects.');
            }
            const localVarPath = `/api/v1/bookmarks/{user}/projects`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listProjectNames.');
            }
            const localVarPath = `/api/v1/{owner}/projects/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listProjects.');
            }
            const localVarPath = `/api/v1/{owner}/projects/list`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} project_name Required name
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProject(owner: string, project_name: string, body: V1Project, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchProject.');
            }
            // verify required parameter 'project_name' is not null or undefined
            if (project_name === null || project_name === undefined) {
                throw new RequiredError('project_name','Required parameter project_name was null or undefined when calling patchProject.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project.name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project.name"}}`, encodeURIComponent(String(project_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Project" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreExperiment(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling restoreExperiment.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling restoreExperiment.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/restore`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invalidate runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbookmarkProject(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling unbookmarkProject.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling unbookmarkProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/unbookmark`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} project_name Required name
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject(owner: string, project_name: string, body: V1Project, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateProject.');
            }
            // verify required parameter 'project_name' is not null or undefined
            if (project_name === null || project_name === undefined) {
                throw new RequiredError('project_name','Required parameter project_name was null or undefined when calling updateProject.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project.name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project.name"}}`, encodeURIComponent(String(project_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Project" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsV1Api - functional programming interface
 * @export
 */
export const ProjectsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveProject(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).archiveProject(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Invalidate run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkProject(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).bookmarkProject(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(owner: string, body: V1Project, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Project> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).createProject(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).deleteProject(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Restart run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableProjectCI(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).disableProjectCI(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Restart run with copy
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableProjectCI(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).enableProjectCI(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Project> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).getProject(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListProjectsResponse> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).listArchivedProjects(user, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List runs
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListProjectsResponse> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).listBookmarkedProjects(user, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListProjectsResponse> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).listProjectNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListProjectsResponse> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).listProjects(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} project_name Required name
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProject(owner: string, project_name: string, body: V1Project, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Project> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).patchProject(owner, project_name, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stop runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreExperiment(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).restoreExperiment(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Invalidate runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbookmarkProject(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).unbookmarkProject(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} project_name Required name
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject(owner: string, project_name: string, body: V1Project, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Project> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).updateProject(owner, project_name, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProjectsV1Api - factory interface
 * @export
 */
export const ProjectsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveProject(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).archiveProject(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Invalidate run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkProject(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).bookmarkProject(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(owner: string, body: V1Project, options?: any) {
            return ProjectsV1ApiFp(configuration).createProject(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).deleteProject(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Restart run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableProjectCI(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).disableProjectCI(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Restart run with copy
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableProjectCI(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).enableProjectCI(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).getProject(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ProjectsV1ApiFp(configuration).listArchivedProjects(user, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List runs
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ProjectsV1ApiFp(configuration).listBookmarkedProjects(user, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ProjectsV1ApiFp(configuration).listProjectNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ProjectsV1ApiFp(configuration).listProjects(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} project_name Required name
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProject(owner: string, project_name: string, body: V1Project, options?: any) {
            return ProjectsV1ApiFp(configuration).patchProject(owner, project_name, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stop runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreExperiment(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).restoreExperiment(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Invalidate runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbookmarkProject(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).unbookmarkProject(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} project_name Required name
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject(owner: string, project_name: string, body: V1Project, options?: any) {
            return ProjectsV1ApiFp(configuration).updateProject(owner, project_name, body, options)(fetch, basePath);
        },
    };
};

/**
 * ProjectsV1Api - object-oriented interface
 * @export
 * @class ProjectsV1Api
 * @extends {BaseAPI}
 */
export class ProjectsV1Api extends BaseAPI {
    /**
     * 
     * @summary Stop run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public archiveProject(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).archiveProject(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Invalidate run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public bookmarkProject(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).bookmarkProject(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run
     * @param {string} owner Owner of the namespace
     * @param {V1Project} body Project body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public createProject(owner: string, body: V1Project, options?: any) {
        return ProjectsV1ApiFp(this.configuration).createProject(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public deleteProject(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).deleteProject(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Restart run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public disableProjectCI(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).disableProjectCI(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Restart run with copy
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public enableProjectCI(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).enableProjectCI(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public getProject(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).getProject(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run
     * @param {string} user User
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public listArchivedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).listArchivedProjects(user, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List runs
     * @param {string} user User
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public listBookmarkedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).listBookmarkedProjects(user, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List archived runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public listProjectNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).listProjectNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public listProjects(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).listProjects(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete run
     * @param {string} owner Owner of the namespace
     * @param {string} project_name Required name
     * @param {V1Project} body Project body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public patchProject(owner: string, project_name: string, body: V1Project, options?: any) {
        return ProjectsV1ApiFp(this.configuration).patchProject(owner, project_name, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stop runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public restoreExperiment(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).restoreExperiment(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Invalidate runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public unbookmarkProject(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).unbookmarkProject(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch run
     * @param {string} owner Owner of the namespace
     * @param {string} project_name Required name
     * @param {V1Project} body Project body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public updateProject(owner: string, project_name: string, body: V1Project, options?: any) {
        return ProjectsV1ApiFp(this.configuration).updateProject(owner, project_name, body, options)(this.fetch, this.basePath);
    }

}

/**
 * RegsitryAccessesV1Api - fetch parameter creator
 * @export
 */
export const RegsitryAccessesV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1HostAccess} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRegsitryAccess(owner: string, body: V1HostAccess, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createRegsitryAccess.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createRegsitryAccess.');
            }
            const localVarPath = `/api/v1/{owner}/registry_accesses`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1HostAccess" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRegsitryAccess(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteRegsitryAccess.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteRegsitryAccess.');
            }
            const localVarPath = `/api/v1/{owner}/registry_accesses/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegsitryAccess(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRegsitryAccess.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRegsitryAccess.');
            }
            const localVarPath = `/api/v1/{owner}/registry_accesses/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRegsitryAccessNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listRegsitryAccessNames.');
            }
            const localVarPath = `/api/v1/{owner}/registry_accesses/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRegsitryAccesses(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listRegsitryAccesses.');
            }
            const localVarPath = `/api/v1/{owner}/registry_accesses`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} host_access_uuid UUID
         * @param {V1HostAccess} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRegsitryAccess(owner: string, host_access_uuid: string, body: V1HostAccess, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchRegsitryAccess.');
            }
            // verify required parameter 'host_access_uuid' is not null or undefined
            if (host_access_uuid === null || host_access_uuid === undefined) {
                throw new RequiredError('host_access_uuid','Required parameter host_access_uuid was null or undefined when calling patchRegsitryAccess.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchRegsitryAccess.');
            }
            const localVarPath = `/api/v1/{owner}/registry_accesses/{host_access.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"host_access.uuid"}}`, encodeURIComponent(String(host_access_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1HostAccess" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} host_access_uuid UUID
         * @param {V1HostAccess} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRegsitryAccess(owner: string, host_access_uuid: string, body: V1HostAccess, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateRegsitryAccess.');
            }
            // verify required parameter 'host_access_uuid' is not null or undefined
            if (host_access_uuid === null || host_access_uuid === undefined) {
                throw new RequiredError('host_access_uuid','Required parameter host_access_uuid was null or undefined when calling updateRegsitryAccess.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateRegsitryAccess.');
            }
            const localVarPath = `/api/v1/{owner}/registry_accesses/{host_access.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"host_access.uuid"}}`, encodeURIComponent(String(host_access_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1HostAccess" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegsitryAccessesV1Api - functional programming interface
 * @export
 */
export const RegsitryAccessesV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1HostAccess} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRegsitryAccess(owner: string, body: V1HostAccess, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1HostAccess> {
            const localVarFetchArgs = RegsitryAccessesV1ApiFetchParamCreator(configuration).createRegsitryAccess(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRegsitryAccess(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = RegsitryAccessesV1ApiFetchParamCreator(configuration).deleteRegsitryAccess(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegsitryAccess(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1HostAccess> {
            const localVarFetchArgs = RegsitryAccessesV1ApiFetchParamCreator(configuration).getRegsitryAccess(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRegsitryAccessNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListHostAccessesResponse> {
            const localVarFetchArgs = RegsitryAccessesV1ApiFetchParamCreator(configuration).listRegsitryAccessNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRegsitryAccesses(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListHostAccessesResponse> {
            const localVarFetchArgs = RegsitryAccessesV1ApiFetchParamCreator(configuration).listRegsitryAccesses(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} host_access_uuid UUID
         * @param {V1HostAccess} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRegsitryAccess(owner: string, host_access_uuid: string, body: V1HostAccess, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1HostAccess> {
            const localVarFetchArgs = RegsitryAccessesV1ApiFetchParamCreator(configuration).patchRegsitryAccess(owner, host_access_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} host_access_uuid UUID
         * @param {V1HostAccess} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRegsitryAccess(owner: string, host_access_uuid: string, body: V1HostAccess, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1HostAccess> {
            const localVarFetchArgs = RegsitryAccessesV1ApiFetchParamCreator(configuration).updateRegsitryAccess(owner, host_access_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RegsitryAccessesV1Api - factory interface
 * @export
 */
export const RegsitryAccessesV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {V1HostAccess} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRegsitryAccess(owner: string, body: V1HostAccess, options?: any) {
            return RegsitryAccessesV1ApiFp(configuration).createRegsitryAccess(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRegsitryAccess(owner: string, uuid: string, options?: any) {
            return RegsitryAccessesV1ApiFp(configuration).deleteRegsitryAccess(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegsitryAccess(owner: string, uuid: string, options?: any) {
            return RegsitryAccessesV1ApiFp(configuration).getRegsitryAccess(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRegsitryAccessNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return RegsitryAccessesV1ApiFp(configuration).listRegsitryAccessNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRegsitryAccesses(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return RegsitryAccessesV1ApiFp(configuration).listRegsitryAccesses(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} host_access_uuid UUID
         * @param {V1HostAccess} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRegsitryAccess(owner: string, host_access_uuid: string, body: V1HostAccess, options?: any) {
            return RegsitryAccessesV1ApiFp(configuration).patchRegsitryAccess(owner, host_access_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} host_access_uuid UUID
         * @param {V1HostAccess} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRegsitryAccess(owner: string, host_access_uuid: string, body: V1HostAccess, options?: any) {
            return RegsitryAccessesV1ApiFp(configuration).updateRegsitryAccess(owner, host_access_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * RegsitryAccessesV1Api - object-oriented interface
 * @export
 * @class RegsitryAccessesV1Api
 * @extends {BaseAPI}
 */
export class RegsitryAccessesV1Api extends BaseAPI {
    /**
     * 
     * @summary List runs
     * @param {string} owner Owner of the namespace
     * @param {V1HostAccess} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegsitryAccessesV1Api
     */
    public createRegsitryAccess(owner: string, body: V1HostAccess, options?: any) {
        return RegsitryAccessesV1ApiFp(this.configuration).createRegsitryAccess(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch run
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegsitryAccessesV1Api
     */
    public deleteRegsitryAccess(owner: string, uuid: string, options?: any) {
        return RegsitryAccessesV1ApiFp(this.configuration).deleteRegsitryAccess(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegsitryAccessesV1Api
     */
    public getRegsitryAccess(owner: string, uuid: string, options?: any) {
        return RegsitryAccessesV1ApiFp(this.configuration).getRegsitryAccess(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegsitryAccessesV1Api
     */
    public listRegsitryAccessNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return RegsitryAccessesV1ApiFp(this.configuration).listRegsitryAccessNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List archived runs for user
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegsitryAccessesV1Api
     */
    public listRegsitryAccesses(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return RegsitryAccessesV1ApiFp(this.configuration).listRegsitryAccesses(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update run
     * @param {string} owner Owner of the namespace
     * @param {string} host_access_uuid UUID
     * @param {V1HostAccess} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegsitryAccessesV1Api
     */
    public patchRegsitryAccess(owner: string, host_access_uuid: string, body: V1HostAccess, options?: any) {
        return RegsitryAccessesV1ApiFp(this.configuration).patchRegsitryAccess(owner, host_access_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run
     * @param {string} owner Owner of the namespace
     * @param {string} host_access_uuid UUID
     * @param {V1HostAccess} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegsitryAccessesV1Api
     */
    public updateRegsitryAccess(owner: string, host_access_uuid: string, body: V1HostAccess, options?: any) {
        return RegsitryAccessesV1ApiFp(this.configuration).updateRegsitryAccess(owner, host_access_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * RunsV1Api - fetch parameter creator
 * @export
 */
export const RunsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Archive run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling archiveRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling archiveRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling archiveRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/archive`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Bookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling bookmarkRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling bookmarkRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling bookmarkRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/bookmark`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restart run with copy
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options: any = {}): FetchArgs {
            // verify required parameter 'entity_owner' is not null or undefined
            if (entity_owner === null || entity_owner === undefined) {
                throw new RequiredError('entity_owner','Required parameter entity_owner was null or undefined when calling copyRun.');
            }
            // verify required parameter 'entity_project' is not null or undefined
            if (entity_project === null || entity_project === undefined) {
                throw new RequiredError('entity_project','Required parameter entity_project was null or undefined when calling copyRun.');
            }
            // verify required parameter 'entity_uuid' is not null or undefined
            if (entity_uuid === null || entity_uuid === undefined) {
                throw new RequiredError('entity_uuid','Required parameter entity_uuid was null or undefined when calling copyRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling copyRun.');
            }
            const localVarPath = `/api/v1/{entity.owner}/{entity.project}/runs/{entity.uuid}/copy`
                .replace(`{${"entity.owner"}}`, encodeURIComponent(String(entity_owner)))
                .replace(`{${"entity.project"}}`, encodeURIComponent(String(entity_project)))
                .replace(`{${"entity.uuid"}}`, encodeURIComponent(String(entity_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Run" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRun(owner: string, project: string, body: V1Run, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling createRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/create`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Run" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run code ref
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1CodeReference} body Code ref object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunCodeRef(entity_owner: string, entity_project: string, entity_uuid: string, body: V1CodeReference, options: any = {}): FetchArgs {
            // verify required parameter 'entity_owner' is not null or undefined
            if (entity_owner === null || entity_owner === undefined) {
                throw new RequiredError('entity_owner','Required parameter entity_owner was null or undefined when calling createRunCodeRef.');
            }
            // verify required parameter 'entity_project' is not null or undefined
            if (entity_project === null || entity_project === undefined) {
                throw new RequiredError('entity_project','Required parameter entity_project was null or undefined when calling createRunCodeRef.');
            }
            // verify required parameter 'entity_uuid' is not null or undefined
            if (entity_uuid === null || entity_uuid === undefined) {
                throw new RequiredError('entity_uuid','Required parameter entity_uuid was null or undefined when calling createRunCodeRef.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createRunCodeRef.');
            }
            const localVarPath = `/api/v1/{entity.owner}/{entity.project}/runs/{entity.uuid}/coderef`
                .replace(`{${"entity.owner"}}`, encodeURIComponent(String(entity_owner)))
                .replace(`{${"entity.project"}}`, encodeURIComponent(String(entity_project)))
                .replace(`{${"entity.uuid"}}`, encodeURIComponent(String(entity_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1CodeReference" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1EntityStatusBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunStatus(owner: string, project: string, uuid: string, body: V1EntityStatusBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createRunStatus.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling createRunStatus.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling createRunStatus.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createRunStatus.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/statuses`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1EntityStatusBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling deleteRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRuns(owner: string, project: string, body: V1Uuids, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteRuns.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling deleteRuns.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling deleteRuns.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/delete`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Uuids" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run code ref
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunCodeRefs(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRunCodeRefs.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getRunCodeRefs.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRunCodeRefs.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/coderef`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunStatuses(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRunStatuses.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getRunStatuses.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRunStatuses.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/statuses`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Impersonate run token
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        impersonateToken(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling impersonateToken.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling impersonateToken.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling impersonateToken.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/impersonate`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invalidate run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1ProjectEntityResourceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateRun(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling invalidateRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling invalidateRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling invalidateRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling invalidateRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/invalidate`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ProjectEntityResourceRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invalidate runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateRuns(owner: string, project: string, body: V1Uuids, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling invalidateRuns.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling invalidateRuns.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling invalidateRuns.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/invalidate`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Uuids" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling listArchivedRuns.');
            }
            const localVarPath = `/api/v1/archives/{user}/runs`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling listBookmarkedRuns.');
            }
            const localVarPath = `/api/v1/bookmarks/{user}/runs`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuns(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listRuns.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling listRuns.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/list`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} run_uuid UUID
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRun(owner: string, project: string, run_uuid: string, body: V1Run, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling patchRun.');
            }
            // verify required parameter 'run_uuid' is not null or undefined
            if (run_uuid === null || run_uuid === undefined) {
                throw new RequiredError('run_uuid','Required parameter run_uuid was null or undefined when calling patchRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{run.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"run.uuid"}}`, encodeURIComponent(String(run_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Run" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restart run
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options: any = {}): FetchArgs {
            // verify required parameter 'entity_owner' is not null or undefined
            if (entity_owner === null || entity_owner === undefined) {
                throw new RequiredError('entity_owner','Required parameter entity_owner was null or undefined when calling restartRun.');
            }
            // verify required parameter 'entity_project' is not null or undefined
            if (entity_project === null || entity_project === undefined) {
                throw new RequiredError('entity_project','Required parameter entity_project was null or undefined when calling restartRun.');
            }
            // verify required parameter 'entity_uuid' is not null or undefined
            if (entity_uuid === null || entity_uuid === undefined) {
                throw new RequiredError('entity_uuid','Required parameter entity_uuid was null or undefined when calling restartRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling restartRun.');
            }
            const localVarPath = `/api/v1/{entity.owner}/{entity.project}/runs/{entity.uuid}/restart`
                .replace(`{${"entity.owner"}}`, encodeURIComponent(String(entity_owner)))
                .replace(`{${"entity.project"}}`, encodeURIComponent(String(entity_project)))
                .replace(`{${"entity.uuid"}}`, encodeURIComponent(String(entity_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Run" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling restoreRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling restoreRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling restoreRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/restore`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resume run
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options: any = {}): FetchArgs {
            // verify required parameter 'entity_owner' is not null or undefined
            if (entity_owner === null || entity_owner === undefined) {
                throw new RequiredError('entity_owner','Required parameter entity_owner was null or undefined when calling resumeRun.');
            }
            // verify required parameter 'entity_project' is not null or undefined
            if (entity_project === null || entity_project === undefined) {
                throw new RequiredError('entity_project','Required parameter entity_project was null or undefined when calling resumeRun.');
            }
            // verify required parameter 'entity_uuid' is not null or undefined
            if (entity_uuid === null || entity_uuid === undefined) {
                throw new RequiredError('entity_uuid','Required parameter entity_uuid was null or undefined when calling resumeRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling resumeRun.');
            }
            const localVarPath = `/api/v1/{entity.owner}/{entity.project}/runs/{entity.uuid}/resume`
                .replace(`{${"entity.owner"}}`, encodeURIComponent(String(entity_owner)))
                .replace(`{${"entity.project"}}`, encodeURIComponent(String(entity_project)))
                .replace(`{${"entity.uuid"}}`, encodeURIComponent(String(entity_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Run" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1ProjectEntityResourceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRunTensorboard(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling startRunTensorboard.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling startRunTensorboard.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling startRunTensorboard.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling startRunTensorboard.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/tensorboard/start`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ProjectEntityResourceRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling stopRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling stopRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling stopRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/stop`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRunTensorboard(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling stopRunTensorboard.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling stopRunTensorboard.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling stopRunTensorboard.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/tensorboard/stop`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRuns(owner: string, project: string, body: V1Uuids, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling stopRuns.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling stopRuns.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling stopRuns.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/stop`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Uuids" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unbookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbookmarkRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling unbookmarkRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling unbookmarkRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling unbookmarkRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/unbookmark`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} run_uuid UUID
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRun(owner: string, project: string, run_uuid: string, body: V1Run, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling updateRun.');
            }
            // verify required parameter 'run_uuid' is not null or undefined
            if (run_uuid === null || run_uuid === undefined) {
                throw new RequiredError('run_uuid','Required parameter run_uuid was null or undefined when calling updateRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{run.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"run.uuid"}}`, encodeURIComponent(String(run_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Run" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RunsV1Api - functional programming interface
 * @export
 */
export const RunsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Archive run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).archiveRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Bookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).bookmarkRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Restart run with copy
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).copyRun(entity_owner, entity_project, entity_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRun(owner: string, project: string, body: V1Run, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).createRun(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run code ref
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1CodeReference} body Code ref object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunCodeRef(entity_owner: string, entity_project: string, entity_uuid: string, body: V1CodeReference, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1CodeReference> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).createRunCodeRef(entity_owner, entity_project, entity_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1EntityStatusBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunStatus(owner: string, project: string, uuid: string, body: V1EntityStatusBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Status> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).createRunStatus(owner, project, uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).deleteRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRuns(owner: string, project: string, body: V1Uuids, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).deleteRuns(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).getRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run code ref
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunCodeRefs(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListCodeRefsResponse> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).getRunCodeRefs(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunStatuses(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Status> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).getRunStatuses(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Impersonate run token
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        impersonateToken(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Auth> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).impersonateToken(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Invalidate run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1ProjectEntityResourceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateRun(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).invalidateRun(owner, project, uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Invalidate runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateRuns(owner: string, project: string, body: V1Uuids, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).invalidateRuns(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListRunsResponse> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).listArchivedRuns(user, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListRunsResponse> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).listBookmarkedRuns(user, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuns(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListRunsResponse> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).listRuns(owner, project, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} run_uuid UUID
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRun(owner: string, project: string, run_uuid: string, body: V1Run, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).patchRun(owner, project, run_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Restart run
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).restartRun(entity_owner, entity_project, entity_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Restore run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).restoreRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Resume run
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).resumeRun(entity_owner, entity_project, entity_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Start run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1ProjectEntityResourceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRunTensorboard(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).startRunTensorboard(owner, project, uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).stopRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stop run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRunTensorboard(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).stopRunTensorboard(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stop runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRuns(owner: string, project: string, body: V1Uuids, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).stopRuns(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Unbookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbookmarkRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).unbookmarkRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} run_uuid UUID
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRun(owner: string, project: string, run_uuid: string, body: V1Run, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).updateRun(owner, project, run_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RunsV1Api - factory interface
 * @export
 */
export const RunsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Archive run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveRun(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).archiveRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Bookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkRun(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).bookmarkRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Restart run with copy
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any) {
            return RunsV1ApiFp(configuration).copyRun(entity_owner, entity_project, entity_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRun(owner: string, project: string, body: V1Run, options?: any) {
            return RunsV1ApiFp(configuration).createRun(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run code ref
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1CodeReference} body Code ref object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunCodeRef(entity_owner: string, entity_project: string, entity_uuid: string, body: V1CodeReference, options?: any) {
            return RunsV1ApiFp(configuration).createRunCodeRef(entity_owner, entity_project, entity_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1EntityStatusBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunStatus(owner: string, project: string, uuid: string, body: V1EntityStatusBodyRequest, options?: any) {
            return RunsV1ApiFp(configuration).createRunStatus(owner, project, uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRun(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).deleteRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRuns(owner: string, project: string, body: V1Uuids, options?: any) {
            return RunsV1ApiFp(configuration).deleteRuns(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRun(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).getRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run code ref
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunCodeRefs(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).getRunCodeRefs(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunStatuses(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).getRunStatuses(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Impersonate run token
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        impersonateToken(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).impersonateToken(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Invalidate run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1ProjectEntityResourceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateRun(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options?: any) {
            return RunsV1ApiFp(configuration).invalidateRun(owner, project, uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Invalidate runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateRuns(owner: string, project: string, body: V1Uuids, options?: any) {
            return RunsV1ApiFp(configuration).invalidateRuns(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return RunsV1ApiFp(configuration).listArchivedRuns(user, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return RunsV1ApiFp(configuration).listBookmarkedRuns(user, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuns(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return RunsV1ApiFp(configuration).listRuns(owner, project, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} run_uuid UUID
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRun(owner: string, project: string, run_uuid: string, body: V1Run, options?: any) {
            return RunsV1ApiFp(configuration).patchRun(owner, project, run_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Restart run
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any) {
            return RunsV1ApiFp(configuration).restartRun(entity_owner, entity_project, entity_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Restore run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreRun(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).restoreRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Resume run
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the experiement will be assigned
         * @param {string} entity_uuid Unique integer identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any) {
            return RunsV1ApiFp(configuration).resumeRun(entity_owner, entity_project, entity_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Start run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {V1ProjectEntityResourceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRunTensorboard(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options?: any) {
            return RunsV1ApiFp(configuration).startRunTensorboard(owner, project, uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRun(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).stopRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stop run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRunTensorboard(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).stopRunTensorboard(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stop runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRuns(owner: string, project: string, body: V1Uuids, options?: any) {
            return RunsV1ApiFp(configuration).stopRuns(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Unbookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbookmarkRun(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).unbookmarkRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} run_uuid UUID
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRun(owner: string, project: string, run_uuid: string, body: V1Run, options?: any) {
            return RunsV1ApiFp(configuration).updateRun(owner, project, run_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * RunsV1Api - object-oriented interface
 * @export
 * @class RunsV1Api
 * @extends {BaseAPI}
 */
export class RunsV1Api extends BaseAPI {
    /**
     * 
     * @summary Archive run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public archiveRun(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).archiveRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Bookmark run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public bookmarkRun(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).bookmarkRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Restart run with copy
     * @param {string} entity_owner Owner of the namespace
     * @param {string} entity_project Project where the experiement will be assigned
     * @param {string} entity_uuid Unique integer identifier of the entity
     * @param {V1Run} body Run object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public copyRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any) {
        return RunsV1ApiFp(this.configuration).copyRun(entity_owner, entity_project, entity_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {V1Run} body Run object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public createRun(owner: string, project: string, body: V1Run, options?: any) {
        return RunsV1ApiFp(this.configuration).createRun(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run code ref
     * @param {string} entity_owner Owner of the namespace
     * @param {string} entity_project Project where the experiement will be assigned
     * @param {string} entity_uuid Unique integer identifier of the entity
     * @param {V1CodeReference} body Code ref object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public createRunCodeRef(entity_owner: string, entity_project: string, entity_uuid: string, body: V1CodeReference, options?: any) {
        return RunsV1ApiFp(this.configuration).createRunCodeRef(entity_owner, entity_project, entity_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run status
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {V1EntityStatusBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public createRunStatus(owner: string, project: string, uuid: string, body: V1EntityStatusBodyRequest, options?: any) {
        return RunsV1ApiFp(this.configuration).createRunStatus(owner, project, uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public deleteRun(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).deleteRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {V1Uuids} body Uuids of the entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public deleteRuns(owner: string, project: string, body: V1Uuids, options?: any) {
        return RunsV1ApiFp(this.configuration).deleteRuns(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public getRun(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).getRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run code ref
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public getRunCodeRefs(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).getRunCodeRefs(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run status
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public getRunStatuses(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).getRunStatuses(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Impersonate run token
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public impersonateToken(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).impersonateToken(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Invalidate run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {V1ProjectEntityResourceRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public invalidateRun(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options?: any) {
        return RunsV1ApiFp(this.configuration).invalidateRun(owner, project, uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Invalidate runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {V1Uuids} body Uuids of the entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public invalidateRuns(owner: string, project: string, body: V1Uuids, options?: any) {
        return RunsV1ApiFp(this.configuration).invalidateRuns(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List archived runs for user
     * @param {string} user User
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public listArchivedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).listArchivedRuns(user, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked runs for user
     * @param {string} user User
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public listBookmarkedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).listBookmarkedRuns(user, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public listRuns(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).listRuns(owner, project, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} run_uuid UUID
     * @param {V1Run} body Run object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public patchRun(owner: string, project: string, run_uuid: string, body: V1Run, options?: any) {
        return RunsV1ApiFp(this.configuration).patchRun(owner, project, run_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Restart run
     * @param {string} entity_owner Owner of the namespace
     * @param {string} entity_project Project where the experiement will be assigned
     * @param {string} entity_uuid Unique integer identifier of the entity
     * @param {V1Run} body Run object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public restartRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any) {
        return RunsV1ApiFp(this.configuration).restartRun(entity_owner, entity_project, entity_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Restore run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public restoreRun(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).restoreRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Resume run
     * @param {string} entity_owner Owner of the namespace
     * @param {string} entity_project Project where the experiement will be assigned
     * @param {string} entity_uuid Unique integer identifier of the entity
     * @param {V1Run} body Run object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public resumeRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any) {
        return RunsV1ApiFp(this.configuration).resumeRun(entity_owner, entity_project, entity_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Start run tensorboard
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {V1ProjectEntityResourceRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public startRunTensorboard(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options?: any) {
        return RunsV1ApiFp(this.configuration).startRunTensorboard(owner, project, uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stop run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public stopRun(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).stopRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stop run tensorboard
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public stopRunTensorboard(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).stopRunTensorboard(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stop runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {V1Uuids} body Uuids of the entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public stopRuns(owner: string, project: string, body: V1Uuids, options?: any) {
        return RunsV1ApiFp(this.configuration).stopRuns(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Unbookmark run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public unbookmarkRun(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).unbookmarkRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} run_uuid UUID
     * @param {V1Run} body Run object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public updateRun(owner: string, project: string, run_uuid: string, body: V1Run, options?: any) {
        return RunsV1ApiFp(this.configuration).updateRun(owner, project, run_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * SearchV1Api - fetch parameter creator
 * @export
 */
export const SearchV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Search} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSearch(owner: string, project: string, body: V1Search, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createSearch.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling createSearch.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createSearch.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/searches`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Search" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSearch(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteSearch.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling deleteSearch.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteSearch.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/searches/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearch(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getSearch.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getSearch.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getSearch.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/searches/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSearches(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listSearches.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling listSearches.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/searches`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} search_uuid UUID
         * @param {V1Search} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSearch(owner: string, project: string, search_uuid: string, body: V1Search, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchSearch.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling patchSearch.');
            }
            // verify required parameter 'search_uuid' is not null or undefined
            if (search_uuid === null || search_uuid === undefined) {
                throw new RequiredError('search_uuid','Required parameter search_uuid was null or undefined when calling patchSearch.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchSearch.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/searches/{search.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"search.uuid"}}`, encodeURIComponent(String(search_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Search" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} search_uuid UUID
         * @param {V1Search} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSearch(owner: string, project: string, search_uuid: string, body: V1Search, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateSearch.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling updateSearch.');
            }
            // verify required parameter 'search_uuid' is not null or undefined
            if (search_uuid === null || search_uuid === undefined) {
                throw new RequiredError('search_uuid','Required parameter search_uuid was null or undefined when calling updateSearch.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateSearch.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/searches/{search.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"search.uuid"}}`, encodeURIComponent(String(search_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Search" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchV1Api - functional programming interface
 * @export
 */
export const SearchV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Search} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSearch(owner: string, project: string, body: V1Search, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Search> {
            const localVarFetchArgs = SearchV1ApiFetchParamCreator(configuration).createSearch(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSearch(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = SearchV1ApiFetchParamCreator(configuration).deleteSearch(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearch(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Search> {
            const localVarFetchArgs = SearchV1ApiFetchParamCreator(configuration).getSearch(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSearches(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListSearchesResponse> {
            const localVarFetchArgs = SearchV1ApiFetchParamCreator(configuration).listSearches(owner, project, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} search_uuid UUID
         * @param {V1Search} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSearch(owner: string, project: string, search_uuid: string, body: V1Search, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Search> {
            const localVarFetchArgs = SearchV1ApiFetchParamCreator(configuration).patchSearch(owner, project, search_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} search_uuid UUID
         * @param {V1Search} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSearch(owner: string, project: string, search_uuid: string, body: V1Search, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Search> {
            const localVarFetchArgs = SearchV1ApiFetchParamCreator(configuration).updateSearch(owner, project, search_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SearchV1Api - factory interface
 * @export
 */
export const SearchV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List archived runs for user
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Search} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSearch(owner: string, project: string, body: V1Search, options?: any) {
            return SearchV1ApiFp(configuration).createSearch(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSearch(owner: string, project: string, uuid: string, options?: any) {
            return SearchV1ApiFp(configuration).deleteSearch(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearch(owner: string, project: string, uuid: string, options?: any) {
            return SearchV1ApiFp(configuration).getSearch(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSearches(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return SearchV1ApiFp(configuration).listSearches(owner, project, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} search_uuid UUID
         * @param {V1Search} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSearch(owner: string, project: string, search_uuid: string, body: V1Search, options?: any) {
            return SearchV1ApiFp(configuration).patchSearch(owner, project, search_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} search_uuid UUID
         * @param {V1Search} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSearch(owner: string, project: string, search_uuid: string, body: V1Search, options?: any) {
            return SearchV1ApiFp(configuration).updateSearch(owner, project, search_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * SearchV1Api - object-oriented interface
 * @export
 * @class SearchV1Api
 * @extends {BaseAPI}
 */
export class SearchV1Api extends BaseAPI {
    /**
     * 
     * @summary List archived runs for user
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {V1Search} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchV1Api
     */
    public createSearch(owner: string, project: string, body: V1Search, options?: any) {
        return SearchV1ApiFp(this.configuration).createSearch(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchV1Api
     */
    public deleteSearch(owner: string, project: string, uuid: string, options?: any) {
        return SearchV1ApiFp(this.configuration).deleteSearch(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchV1Api
     */
    public getSearch(owner: string, project: string, uuid: string, options?: any) {
        return SearchV1ApiFp(this.configuration).getSearch(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked runs for user
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchV1Api
     */
    public listSearches(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return SearchV1ApiFp(this.configuration).listSearches(owner, project, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {string} search_uuid UUID
     * @param {V1Search} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchV1Api
     */
    public patchSearch(owner: string, project: string, search_uuid: string, body: V1Search, options?: any) {
        return SearchV1ApiFp(this.configuration).patchSearch(owner, project, search_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {string} search_uuid UUID
     * @param {V1Search} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchV1Api
     */
    public updateSearch(owner: string, project: string, search_uuid: string, body: V1Search, options?: any) {
        return SearchV1ApiFp(this.configuration).updateSearch(owner, project, search_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * UsersV1Api - fetch parameter creator
 * @export
 */
export const UsersV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersV1Api - functional programming interface
 * @export
 */
export const UsersV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1User> {
            const localVarFetchArgs = UsersV1ApiFetchParamCreator(configuration).getUser(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UsersV1Api - factory interface
 * @export
 */
export const UsersV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options?: any) {
            return UsersV1ApiFp(configuration).getUser(options)(fetch, basePath);
        },
    };
};

/**
 * UsersV1Api - object-oriented interface
 * @export
 * @class UsersV1Api
 * @extends {BaseAPI}
 */
export class UsersV1Api extends BaseAPI {
    /**
     * 
     * @summary List bookmarked runs for user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersV1Api
     */
    public getUser(options?: any) {
        return UsersV1ApiFp(this.configuration).getUser(options)(this.fetch, this.basePath);
    }

}

/**
 * VersionsV1Api - fetch parameter creator
 * @export
 */
export const VersionsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List archived runs for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogHandler(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/log_handler`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersions(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/versions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VersionsV1Api - functional programming interface
 * @export
 */
export const VersionsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List archived runs for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogHandler(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1LogHandler> {
            const localVarFetchArgs = VersionsV1ApiFetchParamCreator(configuration).getLogHandler(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersions(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Versions> {
            const localVarFetchArgs = VersionsV1ApiFetchParamCreator(configuration).getVersions(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * VersionsV1Api - factory interface
 * @export
 */
export const VersionsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List archived runs for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogHandler(options?: any) {
            return VersionsV1ApiFp(configuration).getLogHandler(options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersions(options?: any) {
            return VersionsV1ApiFp(configuration).getVersions(options)(fetch, basePath);
        },
    };
};

/**
 * VersionsV1Api - object-oriented interface
 * @export
 * @class VersionsV1Api
 * @extends {BaseAPI}
 */
export class VersionsV1Api extends BaseAPI {
    /**
     * 
     * @summary List archived runs for user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsV1Api
     */
    public getLogHandler(options?: any) {
        return VersionsV1ApiFp(this.configuration).getLogHandler(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked runs for user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsV1Api
     */
    public getVersions(options?: any) {
        return VersionsV1ApiFp(this.configuration).getVersions(options)(this.fetch, this.basePath);
    }

}

