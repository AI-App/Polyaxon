// Copyright 2018-2020 Polyaxon, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Polyaxon SDKs and REST API specification.
 * Polyaxon SDKs and REST API specification.
 *
 * OpenAPI spec version: 1.0.71
 * Contact: contact@polyaxon.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AgentStateResponseAgentState
 */
export interface AgentStateResponseAgentState {
    /**
     * 
     * @type {any}
     * @memberof AgentStateResponseAgentState
     */
    schedules?: any;
    /**
     * 
     * @type {any}
     * @memberof AgentStateResponseAgentState
     */
    notifier?: any;
    /**
     * 
     * @type {any}
     * @memberof AgentStateResponseAgentState
     */
    watchdogs?: any;
    /**
     * 
     * @type {any}
     * @memberof AgentStateResponseAgentState
     */
    tuners?: any;
    /**
     * 
     * @type {any}
     * @memberof AgentStateResponseAgentState
     */
    queued?: any;
    /**
     * 
     * @type {any}
     * @memberof AgentStateResponseAgentState
     */
    stopping?: any;
    /**
     * 
     * @type {any}
     * @memberof AgentStateResponseAgentState
     */
    apply?: any;
    /**
     * 
     * @type {boolean}
     * @memberof AgentStateResponseAgentState
     */
    full?: boolean;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum NotificationTrigger {
    Succeeded = <any> 'succeeded',
    Failed = <any> 'failed',
    Stopped = <any> 'stopped',
    Done = <any> 'done'
}

/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := ptypes.MarshalAny(foo)      ...      foo := &pb.Foo{}      if err := ptypes.UnmarshalAny(any, foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use 'type.googleapis.com/full.type.name' as the type URL and the unpack methods only use the fully qualified type name after the last '/' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface ProtobufAny
 */
export interface ProtobufAny {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof ProtobufAny
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @type {string}
     * @memberof ProtobufAny
     */
    value?: string;
}

/**
 * `NullValue` is a singleton enumeration to represent the null value for the `Value` type union.   The JSON representation for `NullValue` is JSON `null`.   - NULL_VALUE: Null value.
 * @export
 * @enum {string}
 */
export enum ProtobufNullValue {
    NULLVALUE = <any> 'NULL_VALUE'
}

/**
 * 
 * @export
 * @interface RuntimeError
 */
export interface RuntimeError {
    /**
     * 
     * @type {string}
     * @memberof RuntimeError
     */
    error?: string;
    /**
     * 
     * @type {number}
     * @memberof RuntimeError
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof RuntimeError
     */
    message?: string;
    /**
     * 
     * @type {Array<ProtobufAny>}
     * @memberof RuntimeError
     */
    details?: Array<ProtobufAny>;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum SparkDeployMode {
    Cluster = <any> 'cluster',
    Client = <any> 'client',
    InClusterClient = <any> 'in_cluster_client'
}

/**
 * 
 * @export
 * @interface V1AccessResource
 */
export interface V1AccessResource {
    /**
     * 
     * @type {string}
     * @memberof V1AccessResource
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1AccessResource
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1AccessResource
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1AccessResource
     */
    tags?: Array<string>;
    /**
     * 
     * @type {Date}
     * @memberof V1AccessResource
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1AccessResource
     */
    updated_at?: Date;
    /**
     * 
     * @type {string}
     * @memberof V1AccessResource
     */
    kind?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1AccessResource
     */
    frozen?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1AccessResource
     */
    disabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1AccessResource
     */
    deleted?: boolean;
}

/**
 * 
 * @export
 * @interface V1Affinity
 */
export interface V1Affinity {
}

/**
 * 
 * @export
 * @interface V1Agent
 */
export interface V1Agent {
    /**
     * 
     * @type {string}
     * @memberof V1Agent
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Agent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Agent
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Agent
     */
    tags?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof V1Agent
     */
    disabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1Agent
     */
    deleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1Agent
     */
    namespace?: string;
    /**
     * 
     * @type {any}
     * @memberof V1Agent
     */
    version_api?: any;
    /**
     * 
     * @type {string}
     * @memberof V1Agent
     */
    content?: string;
    /**
     * 
     * @type {number}
     * @memberof V1Agent
     */
    concurrency?: number;
    /**
     * 
     * @type {Date}
     * @memberof V1Agent
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Agent
     */
    updated_at?: Date;
    /**
     * 
     * @type {V1Statuses}
     * @memberof V1Agent
     */
    status?: V1Statuses;
}

/**
 * 
 * @export
 * @interface V1AgentStateResponse
 */
export interface V1AgentStateResponse {
    /**
     * 
     * @type {V1Statuses}
     * @memberof V1AgentStateResponse
     */
    status?: V1Statuses;
    /**
     * 
     * @type {AgentStateResponseAgentState}
     * @memberof V1AgentStateResponse
     */
    state?: AgentStateResponseAgentState;
}

/**
 * 
 * @export
 * @interface V1AgentStatusBodyRequest
 */
export interface V1AgentStatusBodyRequest {
    /**
     * 
     * @type {string}
     * @memberof V1AgentStatusBodyRequest
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof V1AgentStatusBodyRequest
     */
    uuid?: string;
    /**
     * 
     * @type {V1StatusCondition}
     * @memberof V1AgentStatusBodyRequest
     */
    condition?: V1StatusCondition;
}

/**
 * - model: model  - audio: audio  - video: vidio  - histogram: histogram  - image: image  - tensor: tensor  - dataframe: dataframe  - chart: plotly/bokeh chart  - csv: Comma  - tsv: Tab  - psv: Pipe  - ssv: Space  - metric: Metric  - env: Env  - html: HTML  - text: Text  - file: File  - dir: Dir  - dockerfile: Dockerfile  - docker_image: docker image  - data: data  - coderef: coderef  - table: table
 * @export
 * @enum {string}
 */
export enum V1ArtifactKind {
    Model = <any> 'model',
    Audio = <any> 'audio',
    Video = <any> 'video',
    Histogram = <any> 'histogram',
    Image = <any> 'image',
    Tensor = <any> 'tensor',
    Dataframe = <any> 'dataframe',
    Chart = <any> 'chart',
    Csv = <any> 'csv',
    Tsv = <any> 'tsv',
    Psv = <any> 'psv',
    Ssv = <any> 'ssv',
    Metric = <any> 'metric',
    Env = <any> 'env',
    Html = <any> 'html',
    Text = <any> 'text',
    File = <any> 'file',
    Dir = <any> 'dir',
    Dockerfile = <any> 'dockerfile',
    DockerImage = <any> 'docker_image',
    Data = <any> 'data',
    Coderef = <any> 'coderef',
    Table = <any> 'table'
}

/**
 * 
 * @export
 * @interface V1ArtifactTree
 */
export interface V1ArtifactTree {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1ArtifactTree
     */
    files?: { [key: string]: string; };
    /**
     * 
     * @type {Array<string>}
     * @memberof V1ArtifactTree
     */
    dirs?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof V1ArtifactTree
     */
    is_done?: boolean;
}

/**
 * 
 * @export
 * @interface V1ArtifactsMount
 */
export interface V1ArtifactsMount {
    /**
     * 
     * @type {string}
     * @memberof V1ArtifactsMount
     */
    name?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1ArtifactsMount
     */
    paths?: Array<string>;
}

/**
 * 
 * @export
 * @interface V1ArtifactsType
 */
export interface V1ArtifactsType {
    /**
     * 
     * @type {string}
     * @memberof V1ArtifactsType
     */
    connection?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1ArtifactsType
     */
    files?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1ArtifactsType
     */
    dirs?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof V1ArtifactsType
     */
    init?: boolean;
    /**
     * 
     * @type {number}
     * @memberof V1ArtifactsType
     */
    workers?: number;
}

/**
 * 
 * @export
 * @interface V1Auth
 */
export interface V1Auth {
    /**
     * 
     * @type {string}
     * @memberof V1Auth
     */
    token?: string;
}

/**
 * 
 * @export
 * @interface V1AuthType
 */
export interface V1AuthType {
    /**
     * 
     * @type {string}
     * @memberof V1AuthType
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof V1AuthType
     */
    password?: string;
}

/**
 * 
 * @export
 * @interface V1AverageStoppingPolicy
 */
export interface V1AverageStoppingPolicy {
    /**
     * 
     * @type {any}
     * @memberof V1AverageStoppingPolicy
     */
    kind?: any;
}

/**
 * 
 * @export
 * @interface V1Bayes
 */
export interface V1Bayes {
    /**
     * 
     * @type {string}
     * @memberof V1Bayes
     */
    kind?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof V1Bayes
     */
    params?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof V1Bayes
     */
    num_initial_runs?: number;
    /**
     * 
     * @type {number}
     * @memberof V1Bayes
     */
    num_iterations?: number;
    /**
     * 
     * @type {any}
     * @memberof V1Bayes
     */
    utility_function?: any;
    /**
     * 
     * @type {V1OptimizationMetric}
     * @memberof V1Bayes
     */
    metric?: V1OptimizationMetric;
    /**
     * 
     * @type {number}
     * @memberof V1Bayes
     */
    seed?: number;
    /**
     * 
     * @type {number}
     * @memberof V1Bayes
     */
    concurrency?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1Bayes
     */
    early_stopping?: Array<any>;
}

/**
 * 
 * @export
 * @interface V1BucketConnection
 */
export interface V1BucketConnection {
    /**
     * 
     * @type {string}
     * @memberof V1BucketConnection
     */
    bucket?: string;
}

/**
 * 
 * @export
 * @interface V1Cache
 */
export interface V1Cache {
    /**
     * 
     * @type {boolean}
     * @memberof V1Cache
     */
    disable?: boolean;
    /**
     * 
     * @type {number}
     * @memberof V1Cache
     */
    ttl?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Cache
     */
    inputs?: Array<string>;
}

/**
 * 
 * @export
 * @interface V1ClaimConnection
 */
export interface V1ClaimConnection {
    /**
     * 
     * @type {string}
     * @memberof V1ClaimConnection
     */
    volume_claim?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ClaimConnection
     */
    mount_path?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1ClaimConnection
     */
    read_only?: boolean;
    /**
     * 
     * @type {any}
     * @memberof V1ClaimConnection
     */
    kind?: any;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum V1CleanPodPolicy {
    All = <any> 'All',
    Running = <any> 'Running',
    None = <any> 'None'
}

/**
 * 
 * @export
 * @interface V1Cloning
 */
export interface V1Cloning {
    /**
     * 
     * @type {string}
     * @memberof V1Cloning
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Cloning
     */
    name?: string;
    /**
     * 
     * @type {V1CloningKind}
     * @memberof V1Cloning
     */
    kind?: V1CloningKind;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum V1CloningKind {
    Copy = <any> 'copy',
    Restart = <any> 'restart',
    Cache = <any> 'cache',
    Schedule = <any> 'schedule'
}

/**
 * 
 * @export
 * @interface V1CompiledOperation
 */
export interface V1CompiledOperation {
    /**
     * 
     * @type {number}
     * @memberof V1CompiledOperation
     */
    version?: number;
    /**
     * 
     * @type {string}
     * @memberof V1CompiledOperation
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CompiledOperation
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CompiledOperation
     */
    tag?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CompiledOperation
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1CompiledOperation
     */
    tags?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof V1CompiledOperation
     */
    profile?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CompiledOperation
     */
    queue?: string;
    /**
     * 
     * @type {V1Cache}
     * @memberof V1CompiledOperation
     */
    cache?: V1Cache;
    /**
     * 
     * @type {any}
     * @memberof V1CompiledOperation
     */
    schedule?: any;
    /**
     * 
     * @type {any}
     * @memberof V1CompiledOperation
     */
    parallel?: any;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1CompiledOperation
     */
    dependencies?: Array<string>;
    /**
     * 
     * @type {V1TriggerPolicy}
     * @memberof V1CompiledOperation
     */
    trigger?: V1TriggerPolicy;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1CompiledOperation
     */
    conditions?: Array<any>;
    /**
     * 
     * @type {boolean}
     * @memberof V1CompiledOperation
     */
    skip_on_upstream_skip?: boolean;
    /**
     * 
     * @type {V1Termination}
     * @memberof V1CompiledOperation
     */
    termination?: V1Termination;
    /**
     * 
     * @type {V1Plugins}
     * @memberof V1CompiledOperation
     */
    plugins?: V1Plugins;
    /**
     * 
     * @type {Array<V1IO>}
     * @memberof V1CompiledOperation
     */
    inputs?: Array<V1IO>;
    /**
     * 
     * @type {Array<V1IO>}
     * @memberof V1CompiledOperation
     */
    outputs?: Array<V1IO>;
    /**
     * 
     * @type {any}
     * @memberof V1CompiledOperation
     */
    run?: any;
}

/**
 * 
 * @export
 * @interface V1Component
 */
export interface V1Component {
    /**
     * 
     * @type {number}
     * @memberof V1Component
     */
    version?: number;
    /**
     * 
     * @type {string}
     * @memberof V1Component
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Component
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Component
     */
    tag?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Component
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Component
     */
    tags?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof V1Component
     */
    profile?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Component
     */
    queue?: string;
    /**
     * 
     * @type {V1Cache}
     * @memberof V1Component
     */
    cache?: V1Cache;
    /**
     * 
     * @type {V1Termination}
     * @memberof V1Component
     */
    termination?: V1Termination;
    /**
     * 
     * @type {V1Plugins}
     * @memberof V1Component
     */
    plugins?: V1Plugins;
    /**
     * 
     * @type {Array<V1IO>}
     * @memberof V1Component
     */
    inputs?: Array<V1IO>;
    /**
     * 
     * @type {Array<V1IO>}
     * @memberof V1Component
     */
    outputs?: Array<V1IO>;
    /**
     * 
     * @type {any}
     * @memberof V1Component
     */
    run?: any;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum V1ConnectionKind {
    HostPath = <any> 'host_path',
    VolumeClaim = <any> 'volume_claim',
    Gcs = <any> 'gcs',
    S3 = <any> 's3',
    Wasb = <any> 'wasb',
    Registry = <any> 'registry',
    Git = <any> 'git',
    Aws = <any> 'aws',
    Gcp = <any> 'gcp',
    Azure = <any> 'azure',
    Mysql = <any> 'mysql',
    Postgres = <any> 'postgres',
    Oracle = <any> 'oracle',
    Vertica = <any> 'vertica',
    Sqlite = <any> 'sqlite',
    Mssql = <any> 'mssql',
    Redis = <any> 'redis',
    Presto = <any> 'presto',
    Mongo = <any> 'mongo',
    Cassandra = <any> 'cassandra',
    Ftp = <any> 'ftp',
    Grpc = <any> 'grpc',
    Hdfs = <any> 'hdfs',
    Http = <any> 'http',
    PigCli = <any> 'pig_cli',
    HiveCli = <any> 'hive_cli',
    HiveMetastore = <any> 'hive_metastore',
    HiveServer2 = <any> 'hive_server2',
    Jdbc = <any> 'jdbc',
    Jenkins = <any> 'jenkins',
    Samba = <any> 'samba',
    Snowflake = <any> 'snowflake',
    Ssh = <any> 'ssh',
    Cloudant = <any> 'cloudant',
    Databricks = <any> 'databricks',
    Segment = <any> 'segment',
    Slack = <any> 'slack',
    Discord = <any> 'discord',
    Mattermost = <any> 'mattermost',
    PagerDuty = <any> 'pager_duty',
    Hipchat = <any> 'hipchat',
    Webhook = <any> 'webhook',
    Custom = <any> 'custom'
}

/**
 * 
 * @export
 * @interface V1ConnectionResponse
 */
export interface V1ConnectionResponse {
    /**
     * 
     * @type {string}
     * @memberof V1ConnectionResponse
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ConnectionResponse
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ConnectionResponse
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1ConnectionResponse
     */
    tags?: Array<string>;
    /**
     * 
     * @type {Date}
     * @memberof V1ConnectionResponse
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1ConnectionResponse
     */
    updated_at?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof V1ConnectionResponse
     */
    frozen?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1ConnectionResponse
     */
    disabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1ConnectionResponse
     */
    deleted?: boolean;
    /**
     * 
     * @type {V1ConnectionKind}
     * @memberof V1ConnectionResponse
     */
    kind?: V1ConnectionKind;
}

/**
 * 
 * @export
 * @interface V1ConnectionSchema
 */
export interface V1ConnectionSchema {
    /**
     * 
     * @type {V1BucketConnection}
     * @memberof V1ConnectionSchema
     */
    bucket_connection?: V1BucketConnection;
    /**
     * 
     * @type {V1HostPathConnection}
     * @memberof V1ConnectionSchema
     */
    host_path_connection?: V1HostPathConnection;
    /**
     * 
     * @type {V1ClaimConnection}
     * @memberof V1ConnectionSchema
     */
    claim_connection?: V1ClaimConnection;
    /**
     * 
     * @type {V1HostConnection}
     * @memberof V1ConnectionSchema
     */
    host_connection?: V1HostConnection;
    /**
     * 
     * @type {V1GitConnection}
     * @memberof V1ConnectionSchema
     */
    git_connection?: V1GitConnection;
}

/**
 * 
 * @export
 * @interface V1ConnectionType
 */
export interface V1ConnectionType {
    /**
     * 
     * @type {string}
     * @memberof V1ConnectionType
     */
    name?: string;
    /**
     * 
     * @type {V1ConnectionKind}
     * @memberof V1ConnectionType
     */
    kind?: V1ConnectionKind;
    /**
     * 
     * @type {any}
     * @memberof V1ConnectionType
     */
    schema?: any;
    /**
     * 
     * @type {V1K8sResourceSchema}
     * @memberof V1ConnectionType
     */
    secret?: V1K8sResourceSchema;
    /**
     * 
     * @type {V1K8sResourceSchema}
     * @memberof V1ConnectionType
     */
    config_map?: V1K8sResourceSchema;
}

/**
 * 
 * @export
 * @interface V1Container
 */
export interface V1Container {
}

/**
 * 
 * @export
 * @interface V1CredsBodyRequest
 */
export interface V1CredsBodyRequest {
    /**
     * 
     * @type {string}
     * @memberof V1CredsBodyRequest
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CredsBodyRequest
     */
    password?: string;
}

/**
 * 
 * @export
 * @interface V1CronSchedule
 */
export interface V1CronSchedule {
    /**
     * 
     * @type {string}
     * @memberof V1CronSchedule
     */
    kind?: string;
    /**
     * 
     * @type {Date}
     * @memberof V1CronSchedule
     */
    start_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1CronSchedule
     */
    end_at?: Date;
    /**
     * 
     * @type {string}
     * @memberof V1CronSchedule
     */
    cron?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1CronSchedule
     */
    depends_on_past?: boolean;
}

/**
 * 
 * @export
 * @interface V1Dag
 */
export interface V1Dag {
    /**
     * 
     * @type {string}
     * @memberof V1Dag
     */
    kind?: string;
    /**
     * 
     * @type {Array<V1Operation>}
     * @memberof V1Dag
     */
    operations?: Array<V1Operation>;
    /**
     * 
     * @type {Array<V1Component>}
     * @memberof V1Dag
     */
    components?: Array<V1Component>;
    /**
     * 
     * @type {number}
     * @memberof V1Dag
     */
    concurrency?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1Dag
     */
    early_stopping?: Array<any>;
    /**
     * 
     * @type {V1Environment}
     * @memberof V1Dag
     */
    environment?: V1Environment;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Dag
     */
    connections?: Array<string>;
    /**
     * Volumes is a list of volumes that can be mounted.
     * @type {Array<V1Volume>}
     * @memberof V1Dag
     */
    volumes?: Array<V1Volume>;
}

/**
 * 
 * @export
 * @interface V1DagReference
 */
export interface V1DagReference {
    /**
     * 
     * @type {string}
     * @memberof V1DagReference
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof V1DagReference
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface V1Dashboard
 */
export interface V1Dashboard {
    /**
     * 
     * @type {string}
     * @memberof V1Dashboard
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Dashboard
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Dashboard
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Dashboard
     */
    tags?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof V1Dashboard
     */
    disabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1Dashboard
     */
    deleted?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1Dashboard
     */
    run_view?: boolean;
    /**
     * 
     * @type {any}
     * @memberof V1Dashboard
     */
    spec?: any;
    /**
     * 
     * @type {Date}
     * @memberof V1Dashboard
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Dashboard
     */
    updated_at?: Date;
}

/**
 * 
 * @export
 * @interface V1Dask
 */
export interface V1Dask {
    /**
     * 
     * @type {string}
     * @memberof V1Dask
     */
    kind?: string;
    /**
     * 
     * @type {number}
     * @memberof V1Dask
     */
    scale?: number;
    /**
     * 
     * @type {number}
     * @memberof V1Dask
     */
    adapt_min?: number;
    /**
     * 
     * @type {number}
     * @memberof V1Dask
     */
    adapt_max?: number;
    /**
     * 
     * @type {string}
     * @memberof V1Dask
     */
    adapt_interval?: string;
    /**
     * 
     * @type {V1Environment}
     * @memberof V1Dask
     */
    environment?: V1Environment;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Dask
     */
    connections?: Array<string>;
    /**
     * Volumes is a list of volumes that can be mounted.
     * @type {Array<V1Volume>}
     * @memberof V1Dask
     */
    volumes?: Array<V1Volume>;
    /**
     * 
     * @type {Array<V1Init>}
     * @memberof V1Dask
     */
    init?: Array<V1Init>;
    /**
     * 
     * @type {Array<V1Container>}
     * @memberof V1Dask
     */
    sidecars?: Array<V1Container>;
    /**
     * 
     * @type {V1Container}
     * @memberof V1Dask
     */
    container?: V1Container;
}

/**
 * Early stopping with diff factor stopping, this policy computes checks runs against the best run and stops those whose performance is worse than the best by the factor defined by the user.
 * @export
 * @interface V1DiffStoppingPolicy
 */
export interface V1DiffStoppingPolicy {
    /**
     * 
     * @type {string}
     * @memberof V1DiffStoppingPolicy
     */
    kind?: string;
    /**
     * 
     * @type {number}
     * @memberof V1DiffStoppingPolicy
     */
    percent?: number;
    /**
     * Interval/Frequency for applying the policy.
     * @type {number}
     * @memberof V1DiffStoppingPolicy
     */
    evaluation_interval?: number;
    /**
     * 
     * @type {number}
     * @memberof V1DiffStoppingPolicy
     */
    min_interval?: number;
    /**
     * 
     * @type {number}
     * @memberof V1DiffStoppingPolicy
     */
    min_samples?: number;
}

/**
 * 
 * @export
 * @interface V1DockerfileType
 */
export interface V1DockerfileType {
    /**
     * 
     * @type {string}
     * @memberof V1DockerfileType
     */
    image?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1DockerfileType
     */
    env?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1DockerfileType
     */
    path?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1DockerfileType
     */
    copy?: { [key: string]: string; };
    /**
     * 
     * @type {Array<string>}
     * @memberof V1DockerfileType
     */
    run?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof V1DockerfileType
     */
    lang_env?: string;
    /**
     * 
     * @type {number}
     * @memberof V1DockerfileType
     */
    uid?: number;
    /**
     * 
     * @type {number}
     * @memberof V1DockerfileType
     */
    gid?: number;
    /**
     * 
     * @type {string}
     * @memberof V1DockerfileType
     */
    filename?: string;
    /**
     * 
     * @type {string}
     * @memberof V1DockerfileType
     */
    workdir?: string;
    /**
     * 
     * @type {string}
     * @memberof V1DockerfileType
     */
    workdir_path?: string;
    /**
     * 
     * @type {string}
     * @memberof V1DockerfileType
     */
    shell?: string;
}

/**
 * 
 * @export
 * @interface V1EarlyStopping
 */
export interface V1EarlyStopping {
    /**
     * 
     * @type {V1MedianStoppingPolicy}
     * @memberof V1EarlyStopping
     */
    median?: V1MedianStoppingPolicy;
    /**
     * 
     * @type {V1DiffStoppingPolicy}
     * @memberof V1EarlyStopping
     */
    diff?: V1DiffStoppingPolicy;
    /**
     * 
     * @type {V1TruncationStoppingPolicy}
     * @memberof V1EarlyStopping
     */
    truncation?: V1TruncationStoppingPolicy;
    /**
     * 
     * @type {V1MetricEarlyStopping}
     * @memberof V1EarlyStopping
     */
    metric?: V1MetricEarlyStopping;
    /**
     * 
     * @type {V1FailureEarlyStopping}
     * @memberof V1EarlyStopping
     */
    failure?: V1FailureEarlyStopping;
}

/**
 * 
 * @export
 * @interface V1EntityNotificationBody
 */
export interface V1EntityNotificationBody {
    /**
     * 
     * @type {string}
     * @memberof V1EntityNotificationBody
     */
    namespace?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EntityNotificationBody
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EntityNotificationBody
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EntityNotificationBody
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EntityNotificationBody
     */
    name?: string;
    /**
     * 
     * @type {V1StatusCondition}
     * @memberof V1EntityNotificationBody
     */
    condition?: V1StatusCondition;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1EntityNotificationBody
     */
    connections?: Array<string>;
}

/**
 * 
 * @export
 * @interface V1EntityStatusBodyRequest
 */
export interface V1EntityStatusBodyRequest {
    /**
     * 
     * @type {string}
     * @memberof V1EntityStatusBodyRequest
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EntityStatusBodyRequest
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EntityStatusBodyRequest
     */
    uuid?: string;
    /**
     * 
     * @type {V1StatusCondition}
     * @memberof V1EntityStatusBodyRequest
     */
    condition?: V1StatusCondition;
}

/**
 * 
 * @export
 * @interface V1Environment
 */
export interface V1Environment {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1Environment
     */
    labels?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1Environment
     */
    annotations?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1Environment
     */
    node_selector?: { [key: string]: string; };
    /**
     * Optional Affinity sets the scheduling constraints.
     * @type {V1Affinity}
     * @memberof V1Environment
     */
    affinity?: V1Affinity;
    /**
     * Optional Tolerations to apply.
     * @type {Array<V1Toleration>}
     * @memberof V1Environment
     */
    tolerations?: Array<V1Toleration>;
    /**
     * Optional NodeName is a request to schedule this pod onto a specific node. If it is non-empty, the scheduler simply schedules this pod onto that node, assuming that it fits resource requirements.
     * @type {string}
     * @memberof V1Environment
     */
    node_name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Environment
     */
    service_account_name?: string;
    /**
     * Optional HostAliases is an optional list of hosts and IPs that will be injected into the pod spec.
     * @type {Array<V1HostAlias>}
     * @memberof V1Environment
     */
    host_aliases?: Array<V1HostAlias>;
    /**
     * PodSecurityContext holds pod-level security attributes and common container settings. Some fields are also present in container.securityContext.  Field values of container.securityContext take precedence over field values of PodSecurityContext.
     * @type {V1PodSecurityContext}
     * @memberof V1Environment
     */
    security_context?: V1PodSecurityContext;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Environment
     */
    image_pull_secrets?: Array<string>;
    /**
     * Host networking requested for this workflow pod. Default to false.
     * @type {boolean}
     * @memberof V1Environment
     */
    host_network?: boolean;
    /**
     * Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.
     * @type {string}
     * @memberof V1Environment
     */
    dns_policy?: string;
    /**
     * PodDNSConfig defines the DNS parameters of a pod in addition to those generated from DNSPolicy.
     * @type {V1PodDNSConfig}
     * @memberof V1Environment
     */
    dns_config?: V1PodDNSConfig;
    /**
     * 
     * @type {string}
     * @memberof V1Environment
     */
    scheduler_name?: string;
    /**
     * If specified, indicates the pod's priority. \"system-node-critical\" and \"system-cluster-critical\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.
     * @type {string}
     * @memberof V1Environment
     */
    priority_class_name?: string;
    /**
     * The priority value. Various system components use this field to find the priority of the pod. When Priority Admission Controller is enabled, it prevents users from setting this field. The admission controller populates this field from PriorityClassName. The higher the value, the higher the priority.
     * @type {number}
     * @memberof V1Environment
     */
    priority?: number;
    /**
     * 
     * @type {string}
     * @memberof V1Environment
     */
    restart_policy?: string;
}

/**
 * 
 * @export
 * @interface V1Event
 */
export interface V1Event {
    /**
     * 
     * @type {Date}
     * @memberof V1Event
     */
    timestamp?: Date;
    /**
     * Global step of the event.
     * @type {number}
     * @memberof V1Event
     */
    step?: number;
    /**
     * 
     * @type {number}
     * @memberof V1Event
     */
    metric?: number;
    /**
     * 
     * @type {V1EventImage}
     * @memberof V1Event
     */
    image?: V1EventImage;
    /**
     * 
     * @type {V1EventHistogram}
     * @memberof V1Event
     */
    histogram?: V1EventHistogram;
    /**
     * 
     * @type {V1EventAudio}
     * @memberof V1Event
     */
    audio?: V1EventAudio;
    /**
     * 
     * @type {V1EventVideo}
     * @memberof V1Event
     */
    video?: V1EventVideo;
    /**
     * 
     * @type {string}
     * @memberof V1Event
     */
    html?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Event
     */
    text?: string;
    /**
     * 
     * @type {V1EventChart}
     * @memberof V1Event
     */
    chart?: V1EventChart;
    /**
     * 
     * @type {V1EventModel}
     * @memberof V1Event
     */
    model?: V1EventModel;
    /**
     * 
     * @type {V1EventArtifact}
     * @memberof V1Event
     */
    artifact?: V1EventArtifact;
    /**
     * 
     * @type {V1EventDataframe}
     * @memberof V1Event
     */
    dataframe?: V1EventDataframe;
}

/**
 * 
 * @export
 * @interface V1EventArtifact
 */
export interface V1EventArtifact {
    /**
     * 
     * @type {V1ArtifactKind}
     * @memberof V1EventArtifact
     */
    kind?: V1ArtifactKind;
    /**
     * 
     * @type {string}
     * @memberof V1EventArtifact
     */
    path?: string;
}

/**
 * 
 * @export
 * @interface V1EventAudio
 */
export interface V1EventAudio {
    /**
     * Sample rate of the audio in Hz.
     * @type {number}
     * @memberof V1EventAudio
     */
    sample_rate?: number;
    /**
     * Number of channels of audio.
     * @type {number}
     * @memberof V1EventAudio
     */
    num_channels?: number;
    /**
     * Length of the audio in frames (samples per channel).
     * @type {number}
     * @memberof V1EventAudio
     */
    length_frames?: number;
    /**
     * 
     * @type {string}
     * @memberof V1EventAudio
     */
    content_type?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EventAudio
     */
    path?: string;
}

/**
 * 
 * @export
 * @interface V1EventChart
 */
export interface V1EventChart {
    /**
     * 
     * @type {V1EventChartKind}
     * @memberof V1EventChart
     */
    kind?: V1EventChartKind;
    /**
     * 
     * @type {any}
     * @memberof V1EventChart
     */
    figure?: any;
}

/**
 * - plotly: Plotly chart  - bokeh: Bokeh chart  - vega: Vega chart  - roc: ROC chart  - auc: AUC chart  - confusion: Confusion chart
 * @export
 * @enum {string}
 */
export enum V1EventChartKind {
    Plotly = <any> 'plotly',
    Bokeh = <any> 'bokeh',
    Vega = <any> 'vega',
    Roc = <any> 'roc',
    Auc = <any> 'auc',
    Confusion = <any> 'confusion'
}

/**
 * 
 * @export
 * @interface V1EventDataframe
 */
export interface V1EventDataframe {
    /**
     * 
     * @type {string}
     * @memberof V1EventDataframe
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EventDataframe
     */
    content_type?: string;
}

/**
 * 
 * @export
 * @interface V1EventHistogram
 */
export interface V1EventHistogram {
    /**
     * 
     * @type {Array<number>}
     * @memberof V1EventHistogram
     */
    values?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof V1EventHistogram
     */
    counts?: Array<number>;
}

/**
 * 
 * @export
 * @interface V1EventImage
 */
export interface V1EventImage {
    /**
     * Height of the image.
     * @type {number}
     * @memberof V1EventImage
     */
    height?: number;
    /**
     * Width of the image.
     * @type {number}
     * @memberof V1EventImage
     */
    width?: number;
    /**
     * 
     * @type {number}
     * @memberof V1EventImage
     */
    colorspace?: number;
    /**
     * 
     * @type {string}
     * @memberof V1EventImage
     */
    path?: string;
}

/**
 * 
 * @export
 * @interface V1EventModel
 */
export interface V1EventModel {
    /**
     * 
     * @type {string}
     * @memberof V1EventModel
     */
    framework?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EventModel
     */
    path?: string;
    /**
     * 
     * @type {any}
     * @memberof V1EventModel
     */
    spec?: any;
}

/**
 * 
 * @export
 * @interface V1EventType
 */
export interface V1EventType {
    /**
     * 
     * @type {string}
     * @memberof V1EventType
     */
    name?: string;
    /**
     * 
     * @type {V1ArtifactKind}
     * @memberof V1EventType
     */
    kind?: V1ArtifactKind;
}

/**
 * 
 * @export
 * @interface V1EventVideo
 */
export interface V1EventVideo {
    /**
     * Height of the video.
     * @type {number}
     * @memberof V1EventVideo
     */
    height?: number;
    /**
     * Width of the video.
     * @type {number}
     * @memberof V1EventVideo
     */
    width?: number;
    /**
     * 
     * @type {number}
     * @memberof V1EventVideo
     */
    colorspace?: number;
    /**
     * 
     * @type {string}
     * @memberof V1EventVideo
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EventVideo
     */
    content_type?: string;
}

/**
 * 
 * @export
 * @interface V1EventsResponse
 */
export interface V1EventsResponse {
    /**
     * 
     * @type {Array<any>}
     * @memberof V1EventsResponse
     */
    data?: Array<any>;
}

/**
 * 
 * @export
 * @interface V1ExactTimeSchedule
 */
export interface V1ExactTimeSchedule {
    /**
     * 
     * @type {string}
     * @memberof V1ExactTimeSchedule
     */
    kind?: string;
    /**
     * 
     * @type {Date}
     * @memberof V1ExactTimeSchedule
     */
    start_at?: Date;
}

/**
 * FailureEarlyStoppingSchema specification Early stopping based on failure config. this policy stops based on a percentage of failed runs at every evaluation.
 * @export
 * @interface V1FailureEarlyStopping
 */
export interface V1FailureEarlyStopping {
    /**
     * 
     * @type {string}
     * @memberof V1FailureEarlyStopping
     */
    kind?: string;
    /**
     * The percentage failed runs, at each evaluation interval. e.g. 1 - 99.
     * @type {number}
     * @memberof V1FailureEarlyStopping
     */
    percent?: number;
    /**
     * Interval/Frequency for applying the policy.
     * @type {string}
     * @memberof V1FailureEarlyStopping
     */
    evaluation_interval?: string;
}

/**
 * 
 * @export
 * @interface V1Flink
 */
export interface V1Flink {
    /**
     * 
     * @type {string}
     * @memberof V1Flink
     */
    kind?: string;
    /**
     * 
     * @type {any}
     * @memberof V1Flink
     */
    spec?: any;
}

/**
 * 
 * @export
 * @interface V1GcsType
 */
export interface V1GcsType {
    /**
     * 
     * @type {string}
     * @memberof V1GcsType
     */
    bucket?: string;
    /**
     * 
     * @type {string}
     * @memberof V1GcsType
     */
    blob?: string;
}

/**
 * 
 * @export
 * @interface V1GitConnection
 */
export interface V1GitConnection {
    /**
     * 
     * @type {string}
     * @memberof V1GitConnection
     */
    url?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1GitConnection
     */
    revision?: boolean;
}

/**
 * 
 * @export
 * @interface V1GitType
 */
export interface V1GitType {
    /**
     * 
     * @type {string}
     * @memberof V1GitType
     */
    url?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1GitType
     */
    revision?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1GitType
     */
    connection?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1GitType
     */
    init?: boolean;
}

/**
 * 
 * @export
 * @interface V1GridSearch
 */
export interface V1GridSearch {
    /**
     * 
     * @type {string}
     * @memberof V1GridSearch
     */
    kind?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof V1GridSearch
     */
    params?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof V1GridSearch
     */
    num_runs?: number;
    /**
     * 
     * @type {number}
     * @memberof V1GridSearch
     */
    seed?: number;
    /**
     * 
     * @type {number}
     * @memberof V1GridSearch
     */
    concurrency?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1GridSearch
     */
    early_stopping?: Array<any>;
}

/**
 * 
 * @export
 * @interface V1HostAlias
 */
export interface V1HostAlias {
}

/**
 * 
 * @export
 * @interface V1HostConnection
 */
export interface V1HostConnection {
    /**
     * 
     * @type {string}
     * @memberof V1HostConnection
     */
    url?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1HostConnection
     */
    insecure?: boolean;
}

/**
 * 
 * @export
 * @interface V1HostPathConnection
 */
export interface V1HostPathConnection {
    /**
     * 
     * @type {string}
     * @memberof V1HostPathConnection
     */
    host_path?: string;
    /**
     * 
     * @type {string}
     * @memberof V1HostPathConnection
     */
    mount_path?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1HostPathConnection
     */
    read_only?: boolean;
    /**
     * 
     * @type {any}
     * @memberof V1HostPathConnection
     */
    kind?: any;
}

/**
 * 
 * @export
 * @interface V1HpChoice
 */
export interface V1HpChoice {
    /**
     * 
     * @type {string}
     * @memberof V1HpChoice
     */
    kind?: string;
    /**
     * 
     * @type {any}
     * @memberof V1HpChoice
     */
    value?: any;
}

/**
 * 
 * @export
 * @interface V1HpGeomSpace
 */
export interface V1HpGeomSpace {
    /**
     * 
     * @type {string}
     * @memberof V1HpGeomSpace
     */
    kind?: string;
    /**
     * 
     * @type {any}
     * @memberof V1HpGeomSpace
     */
    value?: any;
}

/**
 * 
 * @export
 * @interface V1HpLinSpace
 */
export interface V1HpLinSpace {
    /**
     * 
     * @type {string}
     * @memberof V1HpLinSpace
     */
    kind?: string;
    /**
     * 
     * @type {any}
     * @memberof V1HpLinSpace
     */
    value?: any;
}

/**
 * 
 * @export
 * @interface V1HpLogNormal
 */
export interface V1HpLogNormal {
    /**
     * 
     * @type {string}
     * @memberof V1HpLogNormal
     */
    kind?: string;
    /**
     * 
     * @type {any}
     * @memberof V1HpLogNormal
     */
    value?: any;
}

/**
 * 
 * @export
 * @interface V1HpLogSpace
 */
export interface V1HpLogSpace {
    /**
     * 
     * @type {string}
     * @memberof V1HpLogSpace
     */
    kind?: string;
    /**
     * 
     * @type {any}
     * @memberof V1HpLogSpace
     */
    value?: any;
}

/**
 * 
 * @export
 * @interface V1HpLogUniform
 */
export interface V1HpLogUniform {
    /**
     * 
     * @type {string}
     * @memberof V1HpLogUniform
     */
    kind?: string;
    /**
     * 
     * @type {any}
     * @memberof V1HpLogUniform
     */
    value?: any;
}

/**
 * 
 * @export
 * @interface V1HpNormal
 */
export interface V1HpNormal {
    /**
     * 
     * @type {string}
     * @memberof V1HpNormal
     */
    kind?: string;
    /**
     * 
     * @type {any}
     * @memberof V1HpNormal
     */
    value?: any;
}

/**
 * 
 * @export
 * @interface V1HpPChoice
 */
export interface V1HpPChoice {
    /**
     * 
     * @type {string}
     * @memberof V1HpPChoice
     */
    kind?: string;
    /**
     * 
     * @type {any}
     * @memberof V1HpPChoice
     */
    value?: any;
}

/**
 * 
 * @export
 * @interface V1HpQLogNormal
 */
export interface V1HpQLogNormal {
    /**
     * 
     * @type {string}
     * @memberof V1HpQLogNormal
     */
    kind?: string;
    /**
     * 
     * @type {any}
     * @memberof V1HpQLogNormal
     */
    value?: any;
}

/**
 * 
 * @export
 * @interface V1HpQLogUniform
 */
export interface V1HpQLogUniform {
    /**
     * 
     * @type {string}
     * @memberof V1HpQLogUniform
     */
    kind?: string;
    /**
     * 
     * @type {any}
     * @memberof V1HpQLogUniform
     */
    value?: any;
}

/**
 * 
 * @export
 * @interface V1HpQNormal
 */
export interface V1HpQNormal {
    /**
     * 
     * @type {string}
     * @memberof V1HpQNormal
     */
    kind?: string;
    /**
     * 
     * @type {any}
     * @memberof V1HpQNormal
     */
    value?: any;
}

/**
 * 
 * @export
 * @interface V1HpQUniform
 */
export interface V1HpQUniform {
    /**
     * 
     * @type {string}
     * @memberof V1HpQUniform
     */
    kind?: string;
    /**
     * 
     * @type {any}
     * @memberof V1HpQUniform
     */
    value?: any;
}

/**
 * 
 * @export
 * @interface V1HpRange
 */
export interface V1HpRange {
    /**
     * 
     * @type {string}
     * @memberof V1HpRange
     */
    kind?: string;
    /**
     * 
     * @type {any}
     * @memberof V1HpRange
     */
    value?: any;
}

/**
 * 
 * @export
 * @interface V1HpUniform
 */
export interface V1HpUniform {
    /**
     * 
     * @type {string}
     * @memberof V1HpUniform
     */
    kind?: string;
    /**
     * 
     * @type {any}
     * @memberof V1HpUniform
     */
    value?: any;
}

/**
 * 
 * @export
 * @interface V1HubComponent
 */
export interface V1HubComponent {
    /**
     * 
     * @type {string}
     * @memberof V1HubComponent
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1HubComponent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1HubComponent
     */
    tag?: string;
    /**
     * 
     * @type {V1Component}
     * @memberof V1HubComponent
     */
    content?: V1Component;
    /**
     * 
     * @type {string}
     * @memberof V1HubComponent
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1HubComponent
     */
    tags?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof V1HubComponent
     */
    disabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1HubComponent
     */
    deleted?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof V1HubComponent
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1HubComponent
     */
    updated_at?: Date;
}

/**
 * 
 * @export
 * @interface V1HubModel
 */
export interface V1HubModel {
    /**
     * 
     * @type {string}
     * @memberof V1HubModel
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1HubModel
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1HubModel
     */
    tag?: string;
    /**
     * 
     * @type {string}
     * @memberof V1HubModel
     */
    framework?: string;
    /**
     * 
     * @type {string}
     * @memberof V1HubModel
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1HubModel
     */
    tags?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof V1HubModel
     */
    disabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1HubModel
     */
    deleted?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof V1HubModel
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1HubModel
     */
    updated_at?: Date;
}

/**
 * 
 * @export
 * @interface V1HubReference
 */
export interface V1HubReference {
    /**
     * 
     * @type {string}
     * @memberof V1HubReference
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof V1HubReference
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface V1Hyperband
 */
export interface V1Hyperband {
    /**
     * 
     * @type {string}
     * @memberof V1Hyperband
     */
    kind?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof V1Hyperband
     */
    params?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof V1Hyperband
     */
    max_iterations?: number;
    /**
     * 
     * @type {number}
     * @memberof V1Hyperband
     */
    eta?: number;
    /**
     * 
     * @type {V1OptimizationResource}
     * @memberof V1Hyperband
     */
    resource?: V1OptimizationResource;
    /**
     * 
     * @type {V1OptimizationMetric}
     * @memberof V1Hyperband
     */
    metric?: V1OptimizationMetric;
    /**
     * 
     * @type {boolean}
     * @memberof V1Hyperband
     */
    resume?: boolean;
    /**
     * 
     * @type {number}
     * @memberof V1Hyperband
     */
    seed?: number;
    /**
     * 
     * @type {number}
     * @memberof V1Hyperband
     */
    concurrency?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1Hyperband
     */
    early_stopping?: Array<any>;
}

/**
 * 
 * @export
 * @interface V1Hyperopt
 */
export interface V1Hyperopt {
    /**
     * 
     * @type {string}
     * @memberof V1Hyperopt
     */
    kind?: string;
    /**
     * 
     * @type {V1HyperoptAlgorithms}
     * @memberof V1Hyperopt
     */
    algorithm?: V1HyperoptAlgorithms;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof V1Hyperopt
     */
    params?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof V1Hyperopt
     */
    num_runs?: number;
    /**
     * 
     * @type {number}
     * @memberof V1Hyperopt
     */
    seed?: number;
    /**
     * 
     * @type {number}
     * @memberof V1Hyperopt
     */
    concurrency?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1Hyperopt
     */
    early_stopping?: Array<any>;
}

/**
 * - tpe: tpe algorithm  - rand: random algorithm  - anneal: anneal algorithm
 * @export
 * @enum {string}
 */
export enum V1HyperoptAlgorithms {
    Tpe = <any> 'tpe',
    Rand = <any> 'rand',
    Anneal = <any> 'anneal'
}

/**
 * 
 * @export
 * @interface V1IO
 */
export interface V1IO {
    /**
     * 
     * @type {string}
     * @memberof V1IO
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1IO
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof V1IO
     */
    iotype?: string;
    /**
     * 
     * @type {any}
     * @memberof V1IO
     */
    value?: any;
    /**
     * 
     * @type {boolean}
     * @memberof V1IO
     */
    is_optional?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1IO
     */
    is_list?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1IO
     */
    is_flag?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1IO
     */
    delay_validation?: boolean;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1IO
     */
    options?: Array<any>;
}

/**
 * 
 * @export
 * @interface V1ImageType
 */
export interface V1ImageType {
    /**
     * 
     * @type {string}
     * @memberof V1ImageType
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ImageType
     */
    connection?: string;
}

/**
 * 
 * @export
 * @interface V1Init
 */
export interface V1Init {
    /**
     * 
     * @type {V1ArtifactsType}
     * @memberof V1Init
     */
    artifacts?: V1ArtifactsType;
    /**
     * 
     * @type {V1GitType}
     * @memberof V1Init
     */
    git?: V1GitType;
    /**
     * 
     * @type {V1DockerfileType}
     * @memberof V1Init
     */
    dockerfile?: V1DockerfileType;
    /**
     * 
     * @type {string}
     * @memberof V1Init
     */
    connection?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Init
     */
    path?: string;
    /**
     * 
     * @type {V1Container}
     * @memberof V1Init
     */
    container?: V1Container;
}

/**
 * 
 * @export
 * @interface V1IntervalSchedule
 */
export interface V1IntervalSchedule {
    /**
     * 
     * @type {string}
     * @memberof V1IntervalSchedule
     */
    kind?: string;
    /**
     * 
     * @type {Date}
     * @memberof V1IntervalSchedule
     */
    start_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1IntervalSchedule
     */
    end_at?: Date;
    /**
     * 
     * @type {number}
     * @memberof V1IntervalSchedule
     */
    frequency?: number;
    /**
     * 
     * @type {boolean}
     * @memberof V1IntervalSchedule
     */
    depends_on_past?: boolean;
}

/**
 * 
 * @export
 * @interface V1IoCond
 */
export interface V1IoCond {
    /**
     * 
     * @type {string}
     * @memberof V1IoCond
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof V1IoCond
     */
    param?: string;
    /**
     * 
     * @type {string}
     * @memberof V1IoCond
     */
    trigger?: string;
}

/**
 * 
 * @export
 * @interface V1Iterative
 */
export interface V1Iterative {
    /**
     * 
     * @type {string}
     * @memberof V1Iterative
     */
    kind?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof V1Iterative
     */
    params?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof V1Iterative
     */
    num_iterations?: number;
    /**
     * 
     * @type {V1Container}
     * @memberof V1Iterative
     */
    container?: V1Container;
    /**
     * 
     * @type {number}
     * @memberof V1Iterative
     */
    seed?: number;
    /**
     * 
     * @type {number}
     * @memberof V1Iterative
     */
    concurrency?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1Iterative
     */
    early_stopping?: Array<any>;
}

/**
 * 
 * @export
 * @interface V1Job
 */
export interface V1Job {
    /**
     * 
     * @type {string}
     * @memberof V1Job
     */
    kind?: string;
    /**
     * 
     * @type {V1Environment}
     * @memberof V1Job
     */
    environment?: V1Environment;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Job
     */
    connections?: Array<string>;
    /**
     * Volumes is a list of volumes that can be mounted.
     * @type {Array<V1Volume>}
     * @memberof V1Job
     */
    volumes?: Array<V1Volume>;
    /**
     * 
     * @type {Array<V1Init>}
     * @memberof V1Job
     */
    init?: Array<V1Init>;
    /**
     * 
     * @type {Array<V1Container>}
     * @memberof V1Job
     */
    sidecars?: Array<V1Container>;
    /**
     * 
     * @type {V1Container}
     * @memberof V1Job
     */
    container?: V1Container;
}

/**
 * 
 * @export
 * @interface V1K8sResourceSchema
 */
export interface V1K8sResourceSchema {
    /**
     * 
     * @type {string}
     * @memberof V1K8sResourceSchema
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1K8sResourceSchema
     */
    mount_path?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1K8sResourceSchema
     */
    items?: Array<string>;
}

/**
 * 
 * @export
 * @interface V1K8sResourceType
 */
export interface V1K8sResourceType {
    /**
     * 
     * @type {string}
     * @memberof V1K8sResourceType
     */
    name?: string;
    /**
     * 
     * @type {V1K8sResourceSchema}
     * @memberof V1K8sResourceType
     */
    schema?: V1K8sResourceSchema;
    /**
     * 
     * @type {boolean}
     * @memberof V1K8sResourceType
     */
    is_requested?: boolean;
}

/**
 * 
 * @export
 * @interface V1KFReplica
 */
export interface V1KFReplica {
    /**
     * 
     * @type {number}
     * @memberof V1KFReplica
     */
    replicas?: number;
    /**
     * 
     * @type {V1Environment}
     * @memberof V1KFReplica
     */
    environment?: V1Environment;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1KFReplica
     */
    connections?: Array<string>;
    /**
     * 
     * @type {Array<V1Volume>}
     * @memberof V1KFReplica
     */
    volumes?: Array<V1Volume>;
    /**
     * 
     * @type {Array<V1Init>}
     * @memberof V1KFReplica
     */
    init?: Array<V1Init>;
    /**
     * 
     * @type {Array<V1Container>}
     * @memberof V1KFReplica
     */
    sidecars?: Array<V1Container>;
    /**
     * 
     * @type {V1Container}
     * @memberof V1KFReplica
     */
    container?: V1Container;
}

/**
 * 
 * @export
 * @interface V1ListAccessResourcesResponse
 */
export interface V1ListAccessResourcesResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListAccessResourcesResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1AccessResource>}
     * @memberof V1ListAccessResourcesResponse
     */
    results?: Array<V1AccessResource>;
    /**
     * 
     * @type {string}
     * @memberof V1ListAccessResourcesResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListAccessResourcesResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListAgentsResponse
 */
export interface V1ListAgentsResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListAgentsResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1Agent>}
     * @memberof V1ListAgentsResponse
     */
    results?: Array<V1Agent>;
    /**
     * 
     * @type {string}
     * @memberof V1ListAgentsResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListAgentsResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListConnectionsResponse
 */
export interface V1ListConnectionsResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListConnectionsResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1ConnectionResponse>}
     * @memberof V1ListConnectionsResponse
     */
    results?: Array<V1ConnectionResponse>;
    /**
     * 
     * @type {string}
     * @memberof V1ListConnectionsResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListConnectionsResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListDashboardsResponse
 */
export interface V1ListDashboardsResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListDashboardsResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1Dashboard>}
     * @memberof V1ListDashboardsResponse
     */
    results?: Array<V1Dashboard>;
    /**
     * 
     * @type {string}
     * @memberof V1ListDashboardsResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListDashboardsResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListHubComponentsResponse
 */
export interface V1ListHubComponentsResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListHubComponentsResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1HubComponent>}
     * @memberof V1ListHubComponentsResponse
     */
    results?: Array<V1HubComponent>;
    /**
     * 
     * @type {string}
     * @memberof V1ListHubComponentsResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListHubComponentsResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListHubModelsResponse
 */
export interface V1ListHubModelsResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListHubModelsResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1HubModel>}
     * @memberof V1ListHubModelsResponse
     */
    results?: Array<V1HubModel>;
    /**
     * 
     * @type {string}
     * @memberof V1ListHubModelsResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListHubModelsResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListOrganizationMembersResponse
 */
export interface V1ListOrganizationMembersResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListOrganizationMembersResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1OrganizationMember>}
     * @memberof V1ListOrganizationMembersResponse
     */
    results?: Array<V1OrganizationMember>;
    /**
     * 
     * @type {string}
     * @memberof V1ListOrganizationMembersResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListOrganizationMembersResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListOrganizationsResponse
 */
export interface V1ListOrganizationsResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListOrganizationsResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1Organization>}
     * @memberof V1ListOrganizationsResponse
     */
    results?: Array<V1Organization>;
    /**
     * 
     * @type {string}
     * @memberof V1ListOrganizationsResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListOrganizationsResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListProjectsResponse
 */
export interface V1ListProjectsResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListProjectsResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1Project>}
     * @memberof V1ListProjectsResponse
     */
    results?: Array<V1Project>;
    /**
     * 
     * @type {string}
     * @memberof V1ListProjectsResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListProjectsResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListQueuesResponse
 */
export interface V1ListQueuesResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListQueuesResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1Queue>}
     * @memberof V1ListQueuesResponse
     */
    results?: Array<V1Queue>;
    /**
     * 
     * @type {string}
     * @memberof V1ListQueuesResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListQueuesResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListRunArtifactsResponse
 */
export interface V1ListRunArtifactsResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListRunArtifactsResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1RunArtifact>}
     * @memberof V1ListRunArtifactsResponse
     */
    results?: Array<V1RunArtifact>;
    /**
     * 
     * @type {string}
     * @memberof V1ListRunArtifactsResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListRunArtifactsResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListRunProfilesResponse
 */
export interface V1ListRunProfilesResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListRunProfilesResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1RunProfile>}
     * @memberof V1ListRunProfilesResponse
     */
    results?: Array<V1RunProfile>;
    /**
     * 
     * @type {string}
     * @memberof V1ListRunProfilesResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListRunProfilesResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListRunsResponse
 */
export interface V1ListRunsResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListRunsResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1Run>}
     * @memberof V1ListRunsResponse
     */
    results?: Array<V1Run>;
    /**
     * 
     * @type {string}
     * @memberof V1ListRunsResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListRunsResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListSearchesResponse
 */
export interface V1ListSearchesResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListSearchesResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1Search>}
     * @memberof V1ListSearchesResponse
     */
    results?: Array<V1Search>;
    /**
     * 
     * @type {string}
     * @memberof V1ListSearchesResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListSearchesResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListTeamMembersResponse
 */
export interface V1ListTeamMembersResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListTeamMembersResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1TeamMember>}
     * @memberof V1ListTeamMembersResponse
     */
    results?: Array<V1TeamMember>;
    /**
     * 
     * @type {string}
     * @memberof V1ListTeamMembersResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListTeamMembersResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListTeamsResponse
 */
export interface V1ListTeamsResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListTeamsResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1Team>}
     * @memberof V1ListTeamsResponse
     */
    results?: Array<V1Team>;
    /**
     * 
     * @type {string}
     * @memberof V1ListTeamsResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListTeamsResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1Log
 */
export interface V1Log {
    /**
     * 
     * @type {Date}
     * @memberof V1Log
     */
    timestamp?: Date;
    /**
     * 
     * @type {string}
     * @memberof V1Log
     */
    node?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Log
     */
    pod?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Log
     */
    container?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Log
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface V1LogHandler
 */
export interface V1LogHandler {
    /**
     * 
     * @type {string}
     * @memberof V1LogHandler
     */
    dsn?: string;
    /**
     * 
     * @type {string}
     * @memberof V1LogHandler
     */
    environment?: string;
}

/**
 * 
 * @export
 * @interface V1Logs
 */
export interface V1Logs {
    /**
     * 
     * @type {Array<V1Log>}
     * @memberof V1Logs
     */
    logs?: Array<V1Log>;
    /**
     * 
     * @type {Date}
     * @memberof V1Logs
     */
    last_time?: Date;
    /**
     * 
     * @type {string}
     * @memberof V1Logs
     */
    last_file?: string;
}

/**
 * 
 * @export
 * @interface V1MPIJob
 */
export interface V1MPIJob {
    /**
     * 
     * @type {string}
     * @memberof V1MPIJob
     */
    kind?: string;
    /**
     * 
     * @type {V1CleanPodPolicy}
     * @memberof V1MPIJob
     */
    cleanPodPolicy?: V1CleanPodPolicy;
    /**
     * 
     * @type {number}
     * @memberof V1MPIJob
     */
    slots_per_worker?: number;
    /**
     * 
     * @type {V1KFReplica}
     * @memberof V1MPIJob
     */
    launcher?: V1KFReplica;
    /**
     * 
     * @type {V1KFReplica}
     * @memberof V1MPIJob
     */
    worker?: V1KFReplica;
}

/**
 * 
 * @export
 * @interface V1Mapping
 */
export interface V1Mapping {
    /**
     * 
     * @type {string}
     * @memberof V1Mapping
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Mapping
     */
    values?: string;
    /**
     * 
     * @type {number}
     * @memberof V1Mapping
     */
    concurrency?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1Mapping
     */
    early_stopping?: Array<any>;
}

/**
 * 
 * @export
 * @interface V1Matrix
 */
export interface V1Matrix {
    /**
     * 
     * @type {V1HpChoice}
     * @memberof V1Matrix
     */
    choice?: V1HpChoice;
    /**
     * 
     * @type {V1HpPChoice}
     * @memberof V1Matrix
     */
    pchoice?: V1HpPChoice;
    /**
     * 
     * @type {V1HpRange}
     * @memberof V1Matrix
     */
    range?: V1HpRange;
    /**
     * 
     * @type {V1HpLinSpace}
     * @memberof V1Matrix
     */
    linspace?: V1HpLinSpace;
    /**
     * 
     * @type {V1HpLogSpace}
     * @memberof V1Matrix
     */
    logspace?: V1HpLogSpace;
    /**
     * 
     * @type {V1HpGeomSpace}
     * @memberof V1Matrix
     */
    geomspace?: V1HpGeomSpace;
    /**
     * 
     * @type {V1HpUniform}
     * @memberof V1Matrix
     */
    uniform?: V1HpUniform;
    /**
     * 
     * @type {V1HpQUniform}
     * @memberof V1Matrix
     */
    quniform?: V1HpQUniform;
    /**
     * 
     * @type {V1HpLogUniform}
     * @memberof V1Matrix
     */
    loguniform?: V1HpLogUniform;
    /**
     * 
     * @type {V1HpQLogUniform}
     * @memberof V1Matrix
     */
    qloguniform?: V1HpQLogUniform;
    /**
     * 
     * @type {V1HpNormal}
     * @memberof V1Matrix
     */
    normal?: V1HpNormal;
    /**
     * 
     * @type {V1HpQNormal}
     * @memberof V1Matrix
     */
    qnormal?: V1HpQNormal;
    /**
     * 
     * @type {V1HpLogNormal}
     * @memberof V1Matrix
     */
    lognormal?: V1HpLogNormal;
    /**
     * 
     * @type {V1HpQLogNormal}
     * @memberof V1Matrix
     */
    qlognormal?: V1HpQLogNormal;
}

/**
 * 
 * @export
 * @interface V1MatrixChoice
 */
export interface V1MatrixChoice {
    /**
     * 
     * @type {any}
     * @memberof V1MatrixChoice
     */
    kind?: any;
}

/**
 * 
 * @export
 * @interface V1MatrixGeomSpace
 */
export interface V1MatrixGeomSpace {
    /**
     * 
     * @type {any}
     * @memberof V1MatrixGeomSpace
     */
    kind?: any;
}

/**
 * 
 * @export
 * @interface V1MatrixLinSpace
 */
export interface V1MatrixLinSpace {
    /**
     * 
     * @type {any}
     * @memberof V1MatrixLinSpace
     */
    kind?: any;
}

/**
 * 
 * @export
 * @interface V1MatrixLogNormal
 */
export interface V1MatrixLogNormal {
    /**
     * 
     * @type {any}
     * @memberof V1MatrixLogNormal
     */
    kind?: any;
}

/**
 * 
 * @export
 * @interface V1MatrixLogSpace
 */
export interface V1MatrixLogSpace {
    /**
     * 
     * @type {any}
     * @memberof V1MatrixLogSpace
     */
    kind?: any;
}

/**
 * 
 * @export
 * @interface V1MatrixLogUniform
 */
export interface V1MatrixLogUniform {
    /**
     * 
     * @type {any}
     * @memberof V1MatrixLogUniform
     */
    kind?: any;
}

/**
 * 
 * @export
 * @interface V1MatrixNormal
 */
export interface V1MatrixNormal {
    /**
     * 
     * @type {any}
     * @memberof V1MatrixNormal
     */
    kind?: any;
}

/**
 * 
 * @export
 * @interface V1MatrixPChoice
 */
export interface V1MatrixPChoice {
    /**
     * 
     * @type {any}
     * @memberof V1MatrixPChoice
     */
    kind?: any;
}

/**
 * 
 * @export
 * @interface V1MatrixQLogNormal
 */
export interface V1MatrixQLogNormal {
    /**
     * 
     * @type {any}
     * @memberof V1MatrixQLogNormal
     */
    kind?: any;
}

/**
 * 
 * @export
 * @interface V1MatrixQLogUniform
 */
export interface V1MatrixQLogUniform {
    /**
     * 
     * @type {any}
     * @memberof V1MatrixQLogUniform
     */
    kind?: any;
}

/**
 * 
 * @export
 * @interface V1MatrixQNormal
 */
export interface V1MatrixQNormal {
    /**
     * 
     * @type {any}
     * @memberof V1MatrixQNormal
     */
    kind?: any;
}

/**
 * 
 * @export
 * @interface V1MatrixQUniform
 */
export interface V1MatrixQUniform {
    /**
     * 
     * @type {any}
     * @memberof V1MatrixQUniform
     */
    kind?: any;
}

/**
 * 
 * @export
 * @interface V1MatrixRange
 */
export interface V1MatrixRange {
    /**
     * 
     * @type {any}
     * @memberof V1MatrixRange
     */
    kind?: any;
}

/**
 * 
 * @export
 * @interface V1MatrixUniform
 */
export interface V1MatrixUniform {
    /**
     * 
     * @type {any}
     * @memberof V1MatrixUniform
     */
    kind?: any;
}

/**
 * Early stopping with median stopping, this policy computes running medians across all runs and stops those whose best performance is worse than the median of the running runs.
 * @export
 * @interface V1MedianStoppingPolicy
 */
export interface V1MedianStoppingPolicy {
    /**
     * 
     * @type {string}
     * @memberof V1MedianStoppingPolicy
     */
    kind?: string;
    /**
     * Interval/Frequency for applying the policy.
     * @type {number}
     * @memberof V1MedianStoppingPolicy
     */
    evaluation_interval?: number;
    /**
     * 
     * @type {number}
     * @memberof V1MedianStoppingPolicy
     */
    min_interval?: number;
    /**
     * 
     * @type {number}
     * @memberof V1MedianStoppingPolicy
     */
    min_samples?: number;
}

/**
 * MetricEarlyStoppingSchema specification Early stopping based on metric config.
 * @export
 * @interface V1MetricEarlyStopping
 */
export interface V1MetricEarlyStopping {
    /**
     * 
     * @type {string}
     * @memberof V1MetricEarlyStopping
     */
    kind?: string;
    /**
     * Metric name to use for early stopping.
     * @type {string}
     * @memberof V1MetricEarlyStopping
     */
    metric?: string;
    /**
     * Metric value to use for the condition.
     * @type {string}
     * @memberof V1MetricEarlyStopping
     */
    value?: string;
    /**
     * Optimization to do: maximize or minimize.
     * @type {V1Optimization}
     * @memberof V1MetricEarlyStopping
     */
    optimization?: V1Optimization;
    /**
     * 
     * @type {any}
     * @memberof V1MetricEarlyStopping
     */
    policy?: any;
}

/**
 * 
 * @export
 * @interface V1Notification
 */
export interface V1Notification {
    /**
     * 
     * @type {string}
     * @memberof V1Notification
     */
    connection?: string;
    /**
     * 
     * @type {NotificationTrigger}
     * @memberof V1Notification
     */
    trigger?: NotificationTrigger;
}

/**
 * 
 * @export
 * @interface V1Operation
 */
export interface V1Operation {
    /**
     * 
     * @type {number}
     * @memberof V1Operation
     */
    version?: number;
    /**
     * 
     * @type {string}
     * @memberof V1Operation
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Operation
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Operation
     */
    tag?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Operation
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Operation
     */
    tags?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof V1Operation
     */
    profile?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Operation
     */
    queue?: string;
    /**
     * 
     * @type {V1Cache}
     * @memberof V1Operation
     */
    cache?: V1Cache;
    /**
     * 
     * @type {any}
     * @memberof V1Operation
     */
    schedule?: any;
    /**
     * 
     * @type {any}
     * @memberof V1Operation
     */
    parallel?: any;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Operation
     */
    dependencies?: Array<string>;
    /**
     * 
     * @type {V1TriggerPolicy}
     * @memberof V1Operation
     */
    trigger?: V1TriggerPolicy;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1Operation
     */
    conditions?: Array<any>;
    /**
     * 
     * @type {boolean}
     * @memberof V1Operation
     */
    skip_on_upstream_skip?: boolean;
    /**
     * 
     * @type {V1Termination}
     * @memberof V1Operation
     */
    termination?: V1Termination;
    /**
     * 
     * @type {V1Plugins}
     * @memberof V1Operation
     */
    plugins?: V1Plugins;
    /**
     * 
     * @type {{ [key: string]: V1Param; }}
     * @memberof V1Operation
     */
    params?: { [key: string]: V1Param; };
    /**
     * 
     * @type {any}
     * @memberof V1Operation
     */
    run_patch?: any;
    /**
     * 
     * @type {string}
     * @memberof V1Operation
     */
    dag_ref?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Operation
     */
    url_ref?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Operation
     */
    path_ref?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Operation
     */
    hub_ref?: string;
    /**
     * 
     * @type {V1Component}
     * @memberof V1Operation
     */
    component?: V1Component;
}

/**
 * 
 * @export
 * @interface V1OperationBody
 */
export interface V1OperationBody {
    /**
     * 
     * @type {V1Operation}
     * @memberof V1OperationBody
     */
    content?: V1Operation;
    /**
     * 
     * @type {boolean}
     * @memberof V1OperationBody
     */
    is_managed?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1OperationBody
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1OperationBody
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1OperationBody
     */
    tags?: Array<string>;
}

/**
 * 
 * @export
 * @interface V1OperationCond
 */
export interface V1OperationCond {
    /**
     * 
     * @type {V1IoCond}
     * @memberof V1OperationCond
     */
    io_conidtion?: V1IoCond;
    /**
     * 
     * @type {V1StatusCond}
     * @memberof V1OperationCond
     */
    status_condition?: V1StatusCond;
}

/**
 * - maximize: Minimize a metric  - minimize: Minimize a metric
 * @export
 * @enum {string}
 */
export enum V1Optimization {
    Maximize = <any> 'maximize',
    Minimize = <any> 'minimize'
}

/**
 * 
 * @export
 * @interface V1OptimizationMetric
 */
export interface V1OptimizationMetric {
    /**
     * 
     * @type {string}
     * @memberof V1OptimizationMetric
     */
    name?: string;
    /**
     * 
     * @type {V1Optimization}
     * @memberof V1OptimizationMetric
     */
    optimization?: V1Optimization;
}

/**
 * 
 * @export
 * @interface V1OptimizationResource
 */
export interface V1OptimizationResource {
    /**
     * 
     * @type {string}
     * @memberof V1OptimizationResource
     */
    name?: string;
    /**
     * 
     * @type {V1ResourceType}
     * @memberof V1OptimizationResource
     */
    type?: V1ResourceType;
}

/**
 * 
 * @export
 * @interface V1Organization
 */
export interface V1Organization {
    /**
     * 
     * @type {string}
     * @memberof V1Organization
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Organization
     */
    user_email?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Organization
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Organization
     */
    is_public?: string;
    /**
     * 
     * @type {Date}
     * @memberof V1Organization
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Organization
     */
    updated_at?: Date;
}

/**
 * 
 * @export
 * @interface V1OrganizationMember
 */
export interface V1OrganizationMember {
    /**
     * 
     * @type {string}
     * @memberof V1OrganizationMember
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof V1OrganizationMember
     */
    user_email?: string;
    /**
     * 
     * @type {string}
     * @memberof V1OrganizationMember
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof V1OrganizationMember
     */
    role?: string;
    /**
     * 
     * @type {Date}
     * @memberof V1OrganizationMember
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1OrganizationMember
     */
    updated_at?: Date;
}

/**
 * 
 * @export
 * @interface V1Parallel
 */
export interface V1Parallel {
    /**
     * 
     * @type {V1RandomSearch}
     * @memberof V1Parallel
     */
    random?: V1RandomSearch;
    /**
     * 
     * @type {V1GridSearch}
     * @memberof V1Parallel
     */
    grid?: V1GridSearch;
    /**
     * 
     * @type {V1Hyperband}
     * @memberof V1Parallel
     */
    hyperband?: V1Hyperband;
    /**
     * 
     * @type {V1Bayes}
     * @memberof V1Parallel
     */
    bayes?: V1Bayes;
    /**
     * 
     * @type {V1Hyperopt}
     * @memberof V1Parallel
     */
    hyperopt?: V1Hyperopt;
    /**
     * 
     * @type {V1Iterative}
     * @memberof V1Parallel
     */
    iterative?: V1Iterative;
    /**
     * 
     * @type {V1Mapping}
     * @memberof V1Parallel
     */
    mapping?: V1Mapping;
}

/**
 * 
 * @export
 * @interface V1Param
 */
export interface V1Param {
    /**
     * 
     * @type {any}
     * @memberof V1Param
     */
    value?: any;
    /**
     * 
     * @type {string}
     * @memberof V1Param
     */
    ref?: string;
    /**
     * 
     * @type {V1ParamSearch}
     * @memberof V1Param
     */
    search?: V1ParamSearch;
}

/**
 * 
 * @export
 * @interface V1ParamSearch
 */
export interface V1ParamSearch {
    /**
     * 
     * @type {string}
     * @memberof V1ParamSearch
     */
    query?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ParamSearch
     */
    sort?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ParamSearch
     */
    limit?: string;
}

/**
 * 
 * @export
 * @interface V1PathReference
 */
export interface V1PathReference {
    /**
     * 
     * @type {string}
     * @memberof V1PathReference
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof V1PathReference
     */
    path?: string;
}

/**
 * 
 * @export
 * @interface V1Pipeline
 */
export interface V1Pipeline {
    /**
     * 
     * @type {string}
     * @memberof V1Pipeline
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Pipeline
     */
    name?: string;
    /**
     * 
     * @type {V1PipelineKind}
     * @memberof V1Pipeline
     */
    kind?: V1PipelineKind;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum V1PipelineKind {
    Dag = <any> 'dag',
    Parallel = <any> 'parallel'
}

/**
 * 
 * @export
 * @interface V1Plugins
 */
export interface V1Plugins {
    /**
     * 
     * @type {boolean}
     * @memberof V1Plugins
     */
    auth?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1Plugins
     */
    docker?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1Plugins
     */
    shm?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1Plugins
     */
    collect_artifacts?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1Plugins
     */
    collect_logs?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1Plugins
     */
    collect_resources?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1Plugins
     */
    sync_statuses?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1Plugins
     */
    log_level?: string;
    /**
     * 
     * @type {Array<V1Notification>}
     * @memberof V1Plugins
     */
    notifications?: Array<V1Notification>;
}

/**
 * 
 * @export
 * @interface V1PodDNSConfig
 */
export interface V1PodDNSConfig {
}

/**
 * 
 * @export
 * @interface V1PodSecurityContext
 */
export interface V1PodSecurityContext {
}

/**
 * 
 * @export
 * @interface V1PolyaxonInitContainer
 */
export interface V1PolyaxonInitContainer {
    /**
     * 
     * @type {string}
     * @memberof V1PolyaxonInitContainer
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof V1PolyaxonInitContainer
     */
    image_tag?: string;
    /**
     * 
     * @type {string}
     * @memberof V1PolyaxonInitContainer
     */
    image_pull_policy?: string;
    /**
     * 
     * @type {V1ResourceRequirements}
     * @memberof V1PolyaxonInitContainer
     */
    resources?: V1ResourceRequirements;
}

/**
 * 
 * @export
 * @interface V1PolyaxonSidecarContainer
 */
export interface V1PolyaxonSidecarContainer {
    /**
     * 
     * @type {string}
     * @memberof V1PolyaxonSidecarContainer
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof V1PolyaxonSidecarContainer
     */
    image_tag?: string;
    /**
     * 
     * @type {string}
     * @memberof V1PolyaxonSidecarContainer
     */
    image_pull_policy?: string;
    /**
     * 
     * @type {number}
     * @memberof V1PolyaxonSidecarContainer
     */
    sleep_interval?: number;
    /**
     * 
     * @type {number}
     * @memberof V1PolyaxonSidecarContainer
     */
    sync_interval?: number;
    /**
     * 
     * @type {V1ResourceRequirements}
     * @memberof V1PolyaxonSidecarContainer
     */
    resources?: V1ResourceRequirements;
}

/**
 * 
 * @export
 * @interface V1Project
 */
export interface V1Project {
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    user_email?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Project
     */
    tags?: Array<string>;
    /**
     * 
     * @type {Date}
     * @memberof V1Project
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Project
     */
    updated_at?: Date;
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    is_public?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1Project
     */
    deleted?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1Project
     */
    bookmarked?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    readme?: string;
    /**
     * 
     * @type {V1ProjectSettings}
     * @memberof V1Project
     */
    settings?: V1ProjectSettings;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Project
     */
    teams?: Array<string>;
}

/**
 * 
 * @export
 * @interface V1ProjectEntityResourceRequest
 */
export interface V1ProjectEntityResourceRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ProjectEntityResourceRequest
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ProjectEntityResourceRequest
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ProjectEntityResourceRequest
     */
    uuid?: string;
}

/**
 * 
 * @export
 * @interface V1ProjectSettings
 */
export interface V1ProjectSettings {
    /**
     * 
     * @type {string}
     * @memberof V1ProjectSettings
     */
    artifacts_store?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1ProjectSettings
     */
    connections?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof V1ProjectSettings
     */
    run_profile?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1ProjectSettings
     */
    run_profiles?: Array<string>;
}

/**
 * 
 * @export
 * @interface V1ProjectTeams
 */
export interface V1ProjectTeams {
    /**
     * 
     * @type {Array<string>}
     * @memberof V1ProjectTeams
     */
    teams?: Array<string>;
}

/**
 * 
 * @export
 * @interface V1PytorchJob
 */
export interface V1PytorchJob {
    /**
     * 
     * @type {string}
     * @memberof V1PytorchJob
     */
    kind?: string;
    /**
     * 
     * @type {V1CleanPodPolicy}
     * @memberof V1PytorchJob
     */
    cleanPodPolicy?: V1CleanPodPolicy;
    /**
     * 
     * @type {V1KFReplica}
     * @memberof V1PytorchJob
     */
    master?: V1KFReplica;
    /**
     * 
     * @type {V1KFReplica}
     * @memberof V1PytorchJob
     */
    worker?: V1KFReplica;
}

/**
 * 
 * @export
 * @interface V1Queue
 */
export interface V1Queue {
    /**
     * 
     * @type {string}
     * @memberof V1Queue
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Queue
     */
    agent?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Queue
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof V1Queue
     */
    priority?: number;
    /**
     * 
     * @type {number}
     * @memberof V1Queue
     */
    concurrency?: number;
    /**
     * 
     * @type {Date}
     * @memberof V1Queue
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Queue
     */
    updated_at?: Date;
}

/**
 * 
 * @export
 * @interface V1RandomSearch
 */
export interface V1RandomSearch {
    /**
     * 
     * @type {string}
     * @memberof V1RandomSearch
     */
    kind?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof V1RandomSearch
     */
    params?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof V1RandomSearch
     */
    num_runs?: number;
    /**
     * 
     * @type {number}
     * @memberof V1RandomSearch
     */
    seed?: number;
    /**
     * 
     * @type {number}
     * @memberof V1RandomSearch
     */
    concurrency?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1RandomSearch
     */
    early_stopping?: Array<any>;
}

/**
 * 
 * @export
 * @interface V1Ray
 */
export interface V1Ray {
    /**
     * 
     * @type {string}
     * @memberof V1Ray
     */
    kind?: string;
    /**
     * 
     * @type {any}
     * @memberof V1Ray
     */
    spec?: any;
}

/**
 * 
 * @export
 * @interface V1Reference
 */
export interface V1Reference {
    /**
     * 
     * @type {V1HubReference}
     * @memberof V1Reference
     */
    hub_reference?: V1HubReference;
    /**
     * 
     * @type {V1DagReference}
     * @memberof V1Reference
     */
    dag_reference?: V1DagReference;
    /**
     * 
     * @type {V1UrlReference}
     * @memberof V1Reference
     */
    url_reference?: V1UrlReference;
    /**
     * 
     * @type {V1PathReference}
     * @memberof V1Reference
     */
    path_reference?: V1PathReference;
}

/**
 * 
 * @export
 * @interface V1RepeatableSchedule
 */
export interface V1RepeatableSchedule {
    /**
     * 
     * @type {string}
     * @memberof V1RepeatableSchedule
     */
    kind?: string;
    /**
     * 
     * @type {number}
     * @memberof V1RepeatableSchedule
     */
    limit?: number;
    /**
     * 
     * @type {boolean}
     * @memberof V1RepeatableSchedule
     */
    depends_on_past?: boolean;
}

/**
 * 
 * @export
 * @interface V1ResourceRequirements
 */
export interface V1ResourceRequirements {
}

/**
 * - int: Int resource  - float: Float resource
 * @export
 * @enum {string}
 */
export enum V1ResourceType {
    Int = <any> 'int',
    Float = <any> 'float'
}

/**
 * 
 * @export
 * @interface V1Run
 */
export interface V1Run {
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Run
     */
    tags?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof V1Run
     */
    deleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    project?: string;
    /**
     * 
     * @type {Date}
     * @memberof V1Run
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Run
     */
    updated_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Run
     */
    started_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Run
     */
    finished_at?: Date;
    /**
     * 
     * @type {number}
     * @memberof V1Run
     */
    run_time?: number;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    is_managed?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    content?: string;
    /**
     * 
     * @type {V1Statuses}
     * @memberof V1Run
     */
    status?: V1Statuses;
    /**
     * 
     * @type {boolean}
     * @memberof V1Run
     */
    bookmarked?: boolean;
    /**
     * 
     * @type {any}
     * @memberof V1Run
     */
    meta_info?: any;
    /**
     * 
     * @type {boolean}
     * @memberof V1Run
     */
    is_helper?: boolean;
    /**
     * 
     * @type {V1RunKind}
     * @memberof V1Run
     */
    kind?: V1RunKind;
    /**
     * 
     * @type {V1RunKind}
     * @memberof V1Run
     */
    meta_kind?: V1RunKind;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    hub?: string;
    /**
     * 
     * @type {any}
     * @memberof V1Run
     */
    inputs?: any;
    /**
     * 
     * @type {any}
     * @memberof V1Run
     */
    outputs?: any;
    /**
     * 
     * @type {V1Cloning}
     * @memberof V1Run
     */
    original?: V1Cloning;
    /**
     * 
     * @type {V1Pipeline}
     * @memberof V1Run
     */
    pipeline?: V1Pipeline;
    /**
     * 
     * @type {Array<V1StatusCondition>}
     * @memberof V1Run
     */
    status_conditions?: Array<V1StatusCondition>;
    /**
     * 
     * @type {V1RunSettings}
     * @memberof V1Run
     */
    settings?: V1RunSettings;
}

/**
 * 
 * @export
 * @interface V1RunArtifact
 */
export interface V1RunArtifact {
    /**
     * 
     * @type {string}
     * @memberof V1RunArtifact
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1RunArtifact
     */
    state?: string;
    /**
     * 
     * @type {V1ArtifactKind}
     * @memberof V1RunArtifact
     */
    kind?: V1ArtifactKind;
    /**
     * 
     * @type {string}
     * @memberof V1RunArtifact
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof V1RunArtifact
     */
    connection?: string;
    /**
     * 
     * @type {any}
     * @memberof V1RunArtifact
     */
    summary?: any;
    /**
     * 
     * @type {boolean}
     * @memberof V1RunArtifact
     */
    is_input?: boolean;
}

/**
 * 
 * @export
 * @interface V1RunArtifacts
 */
export interface V1RunArtifacts {
    /**
     * 
     * @type {Array<V1RunArtifact>}
     * @memberof V1RunArtifacts
     */
    artifacts?: Array<V1RunArtifact>;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum V1RunKind {
    Job = <any> 'job',
    Service = <any> 'service',
    Dag = <any> 'dag',
    Spark = <any> 'spark',
    Dask = <any> 'dask',
    Flink = <any> 'flink',
    Ray = <any> 'ray',
    Mpijob = <any> 'mpijob',
    Tfjob = <any> 'tfjob',
    Pytorchjob = <any> 'pytorchjob',
    Parallel = <any> 'parallel',
    Scheduler = <any> 'scheduler',
    Tuner = <any> 'tuner',
    Watchdog = <any> 'watchdog',
    Notifier = <any> 'notifier'
}

/**
 * 
 * @export
 * @interface V1RunProfile
 */
export interface V1RunProfile {
    /**
     * 
     * @type {string}
     * @memberof V1RunProfile
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1RunProfile
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1RunProfile
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1RunProfile
     */
    tags?: Array<string>;
    /**
     * 
     * @type {Date}
     * @memberof V1RunProfile
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1RunProfile
     */
    updated_at?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof V1RunProfile
     */
    frozen?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1RunProfile
     */
    disabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1RunProfile
     */
    agent?: string;
    /**
     * 
     * @type {string}
     * @memberof V1RunProfile
     */
    queue?: string;
    /**
     * 
     * @type {string}
     * @memberof V1RunProfile
     */
    namespace?: string;
    /**
     * 
     * @type {any}
     * @memberof V1RunProfile
     */
    termination?: any;
    /**
     * 
     * @type {any}
     * @memberof V1RunProfile
     */
    environment?: any;
}

/**
 * 
 * @export
 * @interface V1RunSchema
 */
export interface V1RunSchema {
    /**
     * 
     * @type {V1Job}
     * @memberof V1RunSchema
     */
    job?: V1Job;
    /**
     * 
     * @type {V1Service}
     * @memberof V1RunSchema
     */
    service?: V1Service;
    /**
     * 
     * @type {V1Dag}
     * @memberof V1RunSchema
     */
    dag?: V1Dag;
    /**
     * 
     * @type {V1TFJob}
     * @memberof V1RunSchema
     */
    tf_job?: V1TFJob;
    /**
     * 
     * @type {V1PytorchJob}
     * @memberof V1RunSchema
     */
    pytorch_job?: V1PytorchJob;
    /**
     * 
     * @type {V1MPIJob}
     * @memberof V1RunSchema
     */
    mpi_job?: V1MPIJob;
    /**
     * 
     * @type {V1Dask}
     * @memberof V1RunSchema
     */
    dask?: V1Dask;
    /**
     * 
     * @type {V1Spark}
     * @memberof V1RunSchema
     */
    spark?: V1Spark;
    /**
     * 
     * @type {V1Flink}
     * @memberof V1RunSchema
     */
    flink?: V1Flink;
    /**
     * 
     * @type {V1Ray}
     * @memberof V1RunSchema
     */
    ruy?: V1Ray;
}

/**
 * 
 * @export
 * @interface V1RunSettings
 */
export interface V1RunSettings {
    /**
     * 
     * @type {string}
     * @memberof V1RunSettings
     */
    namespace?: string;
    /**
     * 
     * @type {V1RunSettingsCatalog}
     * @memberof V1RunSettings
     */
    agent?: V1RunSettingsCatalog;
    /**
     * 
     * @type {V1RunSettingsCatalog}
     * @memberof V1RunSettings
     */
    queue?: V1RunSettingsCatalog;
    /**
     * 
     * @type {V1RunSettingsCatalog}
     * @memberof V1RunSettings
     */
    artifacts_store?: V1RunSettingsCatalog;
    /**
     * 
     * @type {Array<V1RunSettingsCatalog>}
     * @memberof V1RunSettings
     */
    connections?: Array<V1RunSettingsCatalog>;
}

/**
 * 
 * @export
 * @interface V1RunSettingsCatalog
 */
export interface V1RunSettingsCatalog {
    /**
     * 
     * @type {string}
     * @memberof V1RunSettingsCatalog
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1RunSettingsCatalog
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface V1S3Type
 */
export interface V1S3Type {
    /**
     * 
     * @type {string}
     * @memberof V1S3Type
     */
    bucket?: string;
    /**
     * 
     * @type {string}
     * @memberof V1S3Type
     */
    key?: string;
}

/**
 * 
 * @export
 * @interface V1Schedule
 */
export interface V1Schedule {
    /**
     * 
     * @type {V1CronSchedule}
     * @memberof V1Schedule
     */
    cron?: V1CronSchedule;
    /**
     * 
     * @type {V1ExactTimeSchedule}
     * @memberof V1Schedule
     */
    exact_time?: V1ExactTimeSchedule;
    /**
     * 
     * @type {V1IntervalSchedule}
     * @memberof V1Schedule
     */
    interval?: V1IntervalSchedule;
    /**
     * 
     * @type {V1RepeatableSchedule}
     * @memberof V1Schedule
     */
    repeatable?: V1RepeatableSchedule;
}

/**
 * 
 * @export
 * @interface V1Schemas
 */
export interface V1Schemas {
    /**
     * 
     * @type {V1OperationCond}
     * @memberof V1Schemas
     */
    operation_cond?: V1OperationCond;
    /**
     * 
     * @type {V1EarlyStopping}
     * @memberof V1Schemas
     */
    early_stopping?: V1EarlyStopping;
    /**
     * 
     * @type {V1Parallel}
     * @memberof V1Schemas
     */
    parallel?: V1Parallel;
    /**
     * 
     * @type {V1RunSchema}
     * @memberof V1Schemas
     */
    run?: V1RunSchema;
    /**
     * 
     * @type {V1CompiledOperation}
     * @memberof V1Schemas
     */
    compiled_operation?: V1CompiledOperation;
    /**
     * 
     * @type {V1Schedule}
     * @memberof V1Schemas
     */
    schedule?: V1Schedule;
    /**
     * 
     * @type {V1ConnectionSchema}
     * @memberof V1Schemas
     */
    connection_schema?: V1ConnectionSchema;
    /**
     * 
     * @type {V1Matrix}
     * @memberof V1Schemas
     */
    matrix?: V1Matrix;
    /**
     * 
     * @type {V1Reference}
     * @memberof V1Schemas
     */
    refrence?: V1Reference;
    /**
     * 
     * @type {V1ArtifactsMount}
     * @memberof V1Schemas
     */
    artifacts_mount?: V1ArtifactsMount;
    /**
     * 
     * @type {V1PolyaxonSidecarContainer}
     * @memberof V1Schemas
     */
    polyaxon_sidecar_container?: V1PolyaxonSidecarContainer;
    /**
     * 
     * @type {V1PolyaxonInitContainer}
     * @memberof V1Schemas
     */
    polyaxon_init_container?: V1PolyaxonInitContainer;
    /**
     * 
     * @type {V1ArtifactsType}
     * @memberof V1Schemas
     */
    artifacs?: V1ArtifactsType;
    /**
     * 
     * @type {V1WasbType}
     * @memberof V1Schemas
     */
    wasb?: V1WasbType;
    /**
     * 
     * @type {V1GcsType}
     * @memberof V1Schemas
     */
    gcs?: V1GcsType;
    /**
     * 
     * @type {V1S3Type}
     * @memberof V1Schemas
     */
    s3?: V1S3Type;
    /**
     * 
     * @type {V1AuthType}
     * @memberof V1Schemas
     */
    autg?: V1AuthType;
    /**
     * 
     * @type {V1DockerfileType}
     * @memberof V1Schemas
     */
    dockerfile?: V1DockerfileType;
    /**
     * 
     * @type {V1GitType}
     * @memberof V1Schemas
     */
    git?: V1GitType;
    /**
     * 
     * @type {V1UriType}
     * @memberof V1Schemas
     */
    uri?: V1UriType;
    /**
     * 
     * @type {V1K8sResourceType}
     * @memberof V1Schemas
     */
    k8s_resource?: V1K8sResourceType;
    /**
     * 
     * @type {V1ConnectionType}
     * @memberof V1Schemas
     */
    connection?: V1ConnectionType;
    /**
     * 
     * @type {V1ImageType}
     * @memberof V1Schemas
     */
    image?: V1ImageType;
    /**
     * 
     * @type {V1EventType}
     * @memberof V1Schemas
     */
    event_type?: V1EventType;
    /**
     * 
     * @type {V1Event}
     * @memberof V1Schemas
     */
    event?: V1Event;
}

/**
 * 
 * @export
 * @interface V1Search
 */
export interface V1Search {
    /**
     * 
     * @type {string}
     * @memberof V1Search
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Search
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Search
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Search
     */
    tags?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof V1Search
     */
    disabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1Search
     */
    deleted?: boolean;
    /**
     * 
     * @type {V1SearchSpec}
     * @memberof V1Search
     */
    spec?: V1SearchSpec;
    /**
     * 
     * @type {Date}
     * @memberof V1Search
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Search
     */
    updated_at?: Date;
}

/**
 * 
 * @export
 * @interface V1SearchSpec
 */
export interface V1SearchSpec {
    /**
     * 
     * @type {string}
     * @memberof V1SearchSpec
     */
    query?: string;
    /**
     * 
     * @type {string}
     * @memberof V1SearchSpec
     */
    sort?: string;
    /**
     * 
     * @type {number}
     * @memberof V1SearchSpec
     */
    limit?: number;
    /**
     * 
     * @type {string}
     * @memberof V1SearchSpec
     */
    groupby?: string;
    /**
     * 
     * @type {string}
     * @memberof V1SearchSpec
     */
    columns?: string;
}

/**
 * 
 * @export
 * @interface V1Service
 */
export interface V1Service {
    /**
     * 
     * @type {string}
     * @memberof V1Service
     */
    kind?: string;
    /**
     * 
     * @type {V1Environment}
     * @memberof V1Service
     */
    environment?: V1Environment;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Service
     */
    connections?: Array<string>;
    /**
     * Volumes is a list of volumes that can be mounted.
     * @type {Array<V1Volume>}
     * @memberof V1Service
     */
    volumes?: Array<V1Volume>;
    /**
     * 
     * @type {Array<V1Init>}
     * @memberof V1Service
     */
    init?: Array<V1Init>;
    /**
     * 
     * @type {Array<V1Container>}
     * @memberof V1Service
     */
    sidecars?: Array<V1Container>;
    /**
     * 
     * @type {V1Container}
     * @memberof V1Service
     */
    container?: V1Container;
    /**
     * 
     * @type {Array<number>}
     * @memberof V1Service
     */
    ports?: Array<number>;
    /**
     * Rewrite path to remove polyaxon base url(i.e. /v1/services/namespace/owner/project/). Default is false, the service shoud handle a base url.
     * @type {boolean}
     * @memberof V1Service
     */
    rewritePath?: boolean;
}

/**
 * 
 * @export
 * @interface V1Spark
 */
export interface V1Spark {
    /**
     * 
     * @type {string}
     * @memberof V1Spark
     */
    kind?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Spark
     */
    connections?: Array<string>;
    /**
     * Volumes is a list of volumes that can be mounted.
     * @type {Array<V1Volume>}
     * @memberof V1Spark
     */
    volumes?: Array<V1Volume>;
    /**
     * Type tells the type of the Spark application.
     * @type {V1SparkType}
     * @memberof V1Spark
     */
    type?: V1SparkType;
    /**
     * Spark version is the version of Spark the application uses.
     * @type {string}
     * @memberof V1Spark
     */
    spark_version?: string;
    /**
     * Spark version is the version of Spark the application uses.
     * @type {string}
     * @memberof V1Spark
     */
    python_version?: string;
    /**
     * Mode is the deployment mode of the Spark application.
     * @type {SparkDeployMode}
     * @memberof V1Spark
     */
    deploy_mode?: SparkDeployMode;
    /**
     * MainClass is the fully-qualified main class of the Spark application. This only applies to Java/Scala Spark applications.
     * @type {string}
     * @memberof V1Spark
     */
    main_class?: string;
    /**
     * MainFile is the path to a bundled JAR, Python, or R file of the application.
     * @type {string}
     * @memberof V1Spark
     */
    main_application_file?: string;
    /**
     * Arguments is a list of arguments to be passed to the application.
     * @type {Array<string>}
     * @memberof V1Spark
     */
    arguments?: Array<string>;
    /**
     * HadoopConf carries user-specified Hadoop configuration properties as they would use the  the \"--conf\" option in spark-submit.  The SparkApplication controller automatically adds prefix \"spark.hadoop.\" to Hadoop configuration properties.
     * @type {{ [key: string]: string; }}
     * @memberof V1Spark
     */
    hadoop_conf?: { [key: string]: string; };
    /**
     * HadoopConf carries user-specified Hadoop configuration properties as they would use the  the \"--conf\" option in spark-submit.  The SparkApplication controller automatically adds prefix \"spark.hadoop.\" to Hadoop configuration properties.
     * @type {{ [key: string]: string; }}
     * @memberof V1Spark
     */
    spark_conf?: { [key: string]: string; };
    /**
     * SparkConfigMap carries the name of the ConfigMap containing Spark configuration files such as log4j.properties. The controller will add environment variable SPARK_CONF_DIR to the path where the ConfigMap is mounted to.
     * @type {string}
     * @memberof V1Spark
     */
    spark_config_map?: string;
    /**
     * HadoopConfigMap carries the name of the ConfigMap containing Hadoop configuration files such as core-site.xml. The controller will add environment variable HADOOP_CONF_DIR to the path where the ConfigMap is mounted to.
     * @type {string}
     * @memberof V1Spark
     */
    hadoop_config_map?: string;
    /**
     * 
     * @type {V1SparkReplica}
     * @memberof V1Spark
     */
    executor?: V1SparkReplica;
    /**
     * 
     * @type {V1SparkReplica}
     * @memberof V1Spark
     */
    driver?: V1SparkReplica;
}

/**
 * 
 * @export
 * @interface V1SparkReplica
 */
export interface V1SparkReplica {
    /**
     * 
     * @type {number}
     * @memberof V1SparkReplica
     */
    replicas?: number;
    /**
     * 
     * @type {V1Environment}
     * @memberof V1SparkReplica
     */
    environment?: V1Environment;
    /**
     * 
     * @type {Array<V1Init>}
     * @memberof V1SparkReplica
     */
    init?: Array<V1Init>;
    /**
     * 
     * @type {Array<V1Container>}
     * @memberof V1SparkReplica
     */
    sidecars?: Array<V1Container>;
    /**
     * 
     * @type {V1Container}
     * @memberof V1SparkReplica
     */
    container?: V1Container;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum V1SparkType {
    Java = <any> 'java',
    Scala = <any> 'scala',
    Python = <any> 'python',
    R = <any> 'r'
}

/**
 * 
 * @export
 * @interface V1Status
 */
export interface V1Status {
    /**
     * 
     * @type {string}
     * @memberof V1Status
     */
    uuid?: string;
    /**
     * 
     * @type {V1Statuses}
     * @memberof V1Status
     */
    status?: V1Statuses;
    /**
     * 
     * @type {Array<V1StatusCondition>}
     * @memberof V1Status
     */
    status_conditions?: Array<V1StatusCondition>;
}

/**
 * 
 * @export
 * @interface V1StatusCond
 */
export interface V1StatusCond {
    /**
     * 
     * @type {string}
     * @memberof V1StatusCond
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof V1StatusCond
     */
    operation?: string;
    /**
     * 
     * @type {string}
     * @memberof V1StatusCond
     */
    trigger?: string;
}

/**
 * 
 * @export
 * @interface V1StatusCondition
 */
export interface V1StatusCondition {
    /**
     * 
     * @type {V1Statuses}
     * @memberof V1StatusCondition
     */
    type?: V1Statuses;
    /**
     * 
     * @type {string}
     * @memberof V1StatusCondition
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof V1StatusCondition
     */
    reason?: string;
    /**
     * 
     * @type {string}
     * @memberof V1StatusCondition
     */
    message?: string;
    /**
     * 
     * @type {Date}
     * @memberof V1StatusCondition
     */
    last_update_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1StatusCondition
     */
    last_transition_time?: Date;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum V1Statuses {
    Created = <any> 'created',
    Resuming = <any> 'resuming',
    Warning = <any> 'warning',
    Unschedulable = <any> 'unschedulable',
    Queued = <any> 'queued',
    Scheduled = <any> 'scheduled',
    Starting = <any> 'starting',
    Running = <any> 'running',
    Succeeded = <any> 'succeeded',
    Failed = <any> 'failed',
    UpstreamFailed = <any> 'upstream_failed',
    Stopping = <any> 'stopping',
    Stopped = <any> 'stopped',
    Skipped = <any> 'skipped',
    Retrying = <any> 'retrying',
    Unknown = <any> 'unknown'
}

/**
 * 
 * @export
 * @interface V1TFJob
 */
export interface V1TFJob {
    /**
     * 
     * @type {string}
     * @memberof V1TFJob
     */
    kind?: string;
    /**
     * 
     * @type {V1CleanPodPolicy}
     * @memberof V1TFJob
     */
    cleanPodPolicy?: V1CleanPodPolicy;
    /**
     * 
     * @type {V1KFReplica}
     * @memberof V1TFJob
     */
    chief?: V1KFReplica;
    /**
     * 
     * @type {V1KFReplica}
     * @memberof V1TFJob
     */
    ps?: V1KFReplica;
    /**
     * 
     * @type {V1KFReplica}
     * @memberof V1TFJob
     */
    worker?: V1KFReplica;
    /**
     * 
     * @type {V1KFReplica}
     * @memberof V1TFJob
     */
    evaluator?: V1KFReplica;
}

/**
 * 
 * @export
 * @interface V1Team
 */
export interface V1Team {
    /**
     * 
     * @type {string}
     * @memberof V1Team
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Team
     */
    name?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Team
     */
    projects?: Array<string>;
    /**
     * 
     * @type {Date}
     * @memberof V1Team
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Team
     */
    updated_at?: Date;
}

/**
 * 
 * @export
 * @interface V1TeamMember
 */
export interface V1TeamMember {
    /**
     * 
     * @type {string}
     * @memberof V1TeamMember
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof V1TeamMember
     */
    user_email?: string;
    /**
     * 
     * @type {string}
     * @memberof V1TeamMember
     */
    role?: string;
    /**
     * 
     * @type {string}
     * @memberof V1TeamMember
     */
    org_role?: string;
    /**
     * 
     * @type {Date}
     * @memberof V1TeamMember
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1TeamMember
     */
    updated_at?: Date;
}

/**
 * Termination specification, it defines how to handle failures, job runtime, and cleanup policy.
 * @export
 * @interface V1Termination
 */
export interface V1Termination {
    /**
     * 
     * @type {number}
     * @memberof V1Termination
     */
    max_retries?: number;
    /**
     * 
     * @type {number}
     * @memberof V1Termination
     */
    ttl?: number;
    /**
     * 
     * @type {number}
     * @memberof V1Termination
     */
    timeout?: number;
}

/**
 * 
 * @export
 * @interface V1Toleration
 */
export interface V1Toleration {
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum V1TriggerPolicy {
    AllSucceeded = <any> 'all_succeeded',
    AllFailed = <any> 'all_failed',
    AllDone = <any> 'all_done',
    OneSucceeded = <any> 'one_succeeded',
    OneFailed = <any> 'one_failed',
    OneDone = <any> 'one_done'
}

/**
 * Early stopping with truncation stopping, this policy stops a percentage of all running runs at every evaluation.
 * @export
 * @interface V1TruncationStoppingPolicy
 */
export interface V1TruncationStoppingPolicy {
    /**
     * 
     * @type {string}
     * @memberof V1TruncationStoppingPolicy
     */
    kind?: string;
    /**
     * The percentage of runs to stop, at each evaluation interval. e.g. 1 - 99.
     * @type {number}
     * @memberof V1TruncationStoppingPolicy
     */
    percent?: number;
    /**
     * Interval/Frequency for applying the policy.
     * @type {number}
     * @memberof V1TruncationStoppingPolicy
     */
    evaluation_interval?: number;
    /**
     * 
     * @type {number}
     * @memberof V1TruncationStoppingPolicy
     */
    min_interval?: number;
    /**
     * 
     * @type {number}
     * @memberof V1TruncationStoppingPolicy
     */
    min_samples?: number;
    /**
     * 
     * @type {boolean}
     * @memberof V1TruncationStoppingPolicy
     */
    include_succeeded?: boolean;
}

/**
 * 
 * @export
 * @interface V1UriType
 */
export interface V1UriType {
    /**
     * 
     * @type {string}
     * @memberof V1UriType
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof V1UriType
     */
    password?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1UriType
     */
    host?: boolean;
}

/**
 * 
 * @export
 * @interface V1UrlReference
 */
export interface V1UrlReference {
    /**
     * 
     * @type {string}
     * @memberof V1UrlReference
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof V1UrlReference
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface V1User
 */
export interface V1User {
    /**
     * 
     * @type {string}
     * @memberof V1User
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof V1User
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof V1User
     */
    role?: string;
}

/**
 * 
 * @export
 * @interface V1Uuids
 */
export interface V1Uuids {
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Uuids
     */
    uuids?: Array<string>;
}

/**
 * 
 * @export
 * @interface V1Version
 */
export interface V1Version {
    /**
     * 
     * @type {string}
     * @memberof V1Version
     */
    min_version?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Version
     */
    latest_version?: string;
}

/**
 * 
 * @export
 * @interface V1Versions
 */
export interface V1Versions {
    /**
     * 
     * @type {string}
     * @memberof V1Versions
     */
    platform_version?: string;
    /**
     * 
     * @type {V1Version}
     * @memberof V1Versions
     */
    cli?: V1Version;
    /**
     * 
     * @type {V1Version}
     * @memberof V1Versions
     */
    platform?: V1Version;
    /**
     * 
     * @type {V1Version}
     * @memberof V1Versions
     */
    agent?: V1Version;
}

/**
 * 
 * @export
 * @interface V1Volume
 */
export interface V1Volume {
}

/**
 * 
 * @export
 * @interface V1WasbType
 */
export interface V1WasbType {
    /**
     * 
     * @type {string}
     * @memberof V1WasbType
     */
    container?: string;
    /**
     * 
     * @type {string}
     * @memberof V1WasbType
     */
    storage_account?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1WasbType
     */
    path?: boolean;
}


/**
 * AccessResourcesV1Api - fetch parameter creator
 * @export
 */
export const AccessResourcesV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create access resource
         * @param {string} owner Owner of the namespace
         * @param {V1AccessResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessResourcesV1CreateAccessResource(owner: string, body: V1AccessResource, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling accessResourcesV1CreateAccessResource.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling accessResourcesV1CreateAccessResource.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/access_resources`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1AccessResource" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete access resource
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessResourcesV1DeleteAccessResource(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling accessResourcesV1DeleteAccessResource.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling accessResourcesV1DeleteAccessResource.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/access_resources/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get access resource
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessResourcesV1GetAccessResource(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling accessResourcesV1GetAccessResource.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling accessResourcesV1GetAccessResource.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/access_resources/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List access resource names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessResourcesV1ListAccessResourceNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling accessResourcesV1ListAccessResourceNames.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/access_resources/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List access resources
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessResourcesV1ListAccessResources(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling accessResourcesV1ListAccessResources.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/access_resources`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch access resource
         * @param {string} owner Owner of the namespace
         * @param {string} access_resource_uuid UUID
         * @param {V1AccessResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessResourcesV1PatchAccessResource(owner: string, access_resource_uuid: string, body: V1AccessResource, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling accessResourcesV1PatchAccessResource.');
            }
            // verify required parameter 'access_resource_uuid' is not null or undefined
            if (access_resource_uuid === null || access_resource_uuid === undefined) {
                throw new RequiredError('access_resource_uuid','Required parameter access_resource_uuid was null or undefined when calling accessResourcesV1PatchAccessResource.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling accessResourcesV1PatchAccessResource.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/access_resources/{access_resource.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"access_resource.uuid"}}`, encodeURIComponent(String(access_resource_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1AccessResource" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update access resource
         * @param {string} owner Owner of the namespace
         * @param {string} access_resource_uuid UUID
         * @param {V1AccessResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessResourcesV1UpdateAccessResource(owner: string, access_resource_uuid: string, body: V1AccessResource, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling accessResourcesV1UpdateAccessResource.');
            }
            // verify required parameter 'access_resource_uuid' is not null or undefined
            if (access_resource_uuid === null || access_resource_uuid === undefined) {
                throw new RequiredError('access_resource_uuid','Required parameter access_resource_uuid was null or undefined when calling accessResourcesV1UpdateAccessResource.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling accessResourcesV1UpdateAccessResource.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/access_resources/{access_resource.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"access_resource.uuid"}}`, encodeURIComponent(String(access_resource_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1AccessResource" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessResourcesV1Api - functional programming interface
 * @export
 */
export const AccessResourcesV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create access resource
         * @param {string} owner Owner of the namespace
         * @param {V1AccessResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessResourcesV1CreateAccessResource(owner: string, body: V1AccessResource, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1AccessResource> {
            const localVarFetchArgs = AccessResourcesV1ApiFetchParamCreator(configuration).accessResourcesV1CreateAccessResource(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete access resource
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessResourcesV1DeleteAccessResource(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccessResourcesV1ApiFetchParamCreator(configuration).accessResourcesV1DeleteAccessResource(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get access resource
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessResourcesV1GetAccessResource(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1AccessResource> {
            const localVarFetchArgs = AccessResourcesV1ApiFetchParamCreator(configuration).accessResourcesV1GetAccessResource(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List access resource names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessResourcesV1ListAccessResourceNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListAccessResourcesResponse> {
            const localVarFetchArgs = AccessResourcesV1ApiFetchParamCreator(configuration).accessResourcesV1ListAccessResourceNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List access resources
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessResourcesV1ListAccessResources(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListAccessResourcesResponse> {
            const localVarFetchArgs = AccessResourcesV1ApiFetchParamCreator(configuration).accessResourcesV1ListAccessResources(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch access resource
         * @param {string} owner Owner of the namespace
         * @param {string} access_resource_uuid UUID
         * @param {V1AccessResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessResourcesV1PatchAccessResource(owner: string, access_resource_uuid: string, body: V1AccessResource, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1AccessResource> {
            const localVarFetchArgs = AccessResourcesV1ApiFetchParamCreator(configuration).accessResourcesV1PatchAccessResource(owner, access_resource_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update access resource
         * @param {string} owner Owner of the namespace
         * @param {string} access_resource_uuid UUID
         * @param {V1AccessResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessResourcesV1UpdateAccessResource(owner: string, access_resource_uuid: string, body: V1AccessResource, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1AccessResource> {
            const localVarFetchArgs = AccessResourcesV1ApiFetchParamCreator(configuration).accessResourcesV1UpdateAccessResource(owner, access_resource_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AccessResourcesV1Api - factory interface
 * @export
 */
export const AccessResourcesV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create access resource
         * @param {string} owner Owner of the namespace
         * @param {V1AccessResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessResourcesV1CreateAccessResource(owner: string, body: V1AccessResource, options?: any) {
            return AccessResourcesV1ApiFp(configuration).accessResourcesV1CreateAccessResource(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete access resource
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessResourcesV1DeleteAccessResource(owner: string, uuid: string, options?: any) {
            return AccessResourcesV1ApiFp(configuration).accessResourcesV1DeleteAccessResource(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get access resource
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessResourcesV1GetAccessResource(owner: string, uuid: string, options?: any) {
            return AccessResourcesV1ApiFp(configuration).accessResourcesV1GetAccessResource(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List access resource names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessResourcesV1ListAccessResourceNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return AccessResourcesV1ApiFp(configuration).accessResourcesV1ListAccessResourceNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List access resources
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessResourcesV1ListAccessResources(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return AccessResourcesV1ApiFp(configuration).accessResourcesV1ListAccessResources(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch access resource
         * @param {string} owner Owner of the namespace
         * @param {string} access_resource_uuid UUID
         * @param {V1AccessResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessResourcesV1PatchAccessResource(owner: string, access_resource_uuid: string, body: V1AccessResource, options?: any) {
            return AccessResourcesV1ApiFp(configuration).accessResourcesV1PatchAccessResource(owner, access_resource_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update access resource
         * @param {string} owner Owner of the namespace
         * @param {string} access_resource_uuid UUID
         * @param {V1AccessResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessResourcesV1UpdateAccessResource(owner: string, access_resource_uuid: string, body: V1AccessResource, options?: any) {
            return AccessResourcesV1ApiFp(configuration).accessResourcesV1UpdateAccessResource(owner, access_resource_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * AccessResourcesV1Api - object-oriented interface
 * @export
 * @class AccessResourcesV1Api
 * @extends {BaseAPI}
 */
export class AccessResourcesV1Api extends BaseAPI {
    /**
     * 
     * @summary Create access resource
     * @param {string} owner Owner of the namespace
     * @param {V1AccessResource} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessResourcesV1Api
     */
    public accessResourcesV1CreateAccessResource(owner: string, body: V1AccessResource, options?: any) {
        return AccessResourcesV1ApiFp(this.configuration).accessResourcesV1CreateAccessResource(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete access resource
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessResourcesV1Api
     */
    public accessResourcesV1DeleteAccessResource(owner: string, uuid: string, options?: any) {
        return AccessResourcesV1ApiFp(this.configuration).accessResourcesV1DeleteAccessResource(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get access resource
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessResourcesV1Api
     */
    public accessResourcesV1GetAccessResource(owner: string, uuid: string, options?: any) {
        return AccessResourcesV1ApiFp(this.configuration).accessResourcesV1GetAccessResource(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List access resource names
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessResourcesV1Api
     */
    public accessResourcesV1ListAccessResourceNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return AccessResourcesV1ApiFp(this.configuration).accessResourcesV1ListAccessResourceNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List access resources
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessResourcesV1Api
     */
    public accessResourcesV1ListAccessResources(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return AccessResourcesV1ApiFp(this.configuration).accessResourcesV1ListAccessResources(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch access resource
     * @param {string} owner Owner of the namespace
     * @param {string} access_resource_uuid UUID
     * @param {V1AccessResource} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessResourcesV1Api
     */
    public accessResourcesV1PatchAccessResource(owner: string, access_resource_uuid: string, body: V1AccessResource, options?: any) {
        return AccessResourcesV1ApiFp(this.configuration).accessResourcesV1PatchAccessResource(owner, access_resource_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update access resource
     * @param {string} owner Owner of the namespace
     * @param {string} access_resource_uuid UUID
     * @param {V1AccessResource} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessResourcesV1Api
     */
    public accessResourcesV1UpdateAccessResource(owner: string, access_resource_uuid: string, body: V1AccessResource, options?: any) {
        return AccessResourcesV1ApiFp(this.configuration).accessResourcesV1UpdateAccessResource(owner, access_resource_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * AgentsV1Api - fetch parameter creator
 * @export
 */
export const AgentsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create run profile
         * @param {string} owner Owner of the namespace
         * @param {V1Agent} body Agent body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsV1CreateAgent(owner: string, body: V1Agent, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling agentsV1CreateAgent.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling agentsV1CreateAgent.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Agent" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {V1AgentStatusBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsV1CreateAgentStatus(owner: string, uuid: string, body: V1AgentStatusBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling agentsV1CreateAgentStatus.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling agentsV1CreateAgentStatus.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling agentsV1CreateAgentStatus.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{uuid}/statuses`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1AgentStatusBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete run profile
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsV1DeleteAgent(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling agentsV1DeleteAgent.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling agentsV1DeleteAgent.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run profile
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsV1GetAgent(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling agentsV1GetAgent.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling agentsV1GetAgent.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsV1GetAgentState(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling agentsV1GetAgentState.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling agentsV1GetAgentState.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{uuid}/state`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsV1GetAgentStatuses(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling agentsV1GetAgentStatuses.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling agentsV1GetAgentStatuses.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{uuid}/statuses`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List run profiles names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsV1ListAgentNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling agentsV1ListAgentNames.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List run profiles
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsV1ListAgents(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling agentsV1ListAgents.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch run profile
         * @param {string} owner Owner of the namespace
         * @param {string} agent_uuid UUID
         * @param {V1Agent} body Agent body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsV1PatchAgent(owner: string, agent_uuid: string, body: V1Agent, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling agentsV1PatchAgent.');
            }
            // verify required parameter 'agent_uuid' is not null or undefined
            if (agent_uuid === null || agent_uuid === undefined) {
                throw new RequiredError('agent_uuid','Required parameter agent_uuid was null or undefined when calling agentsV1PatchAgent.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling agentsV1PatchAgent.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{agent.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"agent.uuid"}}`, encodeURIComponent(String(agent_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Agent" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {string} agent_uuid UUID
         * @param {V1Agent} body Agent body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsV1SyncAgent(owner: string, agent_uuid: string, body: V1Agent, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling agentsV1SyncAgent.');
            }
            // verify required parameter 'agent_uuid' is not null or undefined
            if (agent_uuid === null || agent_uuid === undefined) {
                throw new RequiredError('agent_uuid','Required parameter agent_uuid was null or undefined when calling agentsV1SyncAgent.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling agentsV1SyncAgent.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{agent.uuid}/sync`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"agent.uuid"}}`, encodeURIComponent(String(agent_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Agent" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update run profile
         * @param {string} owner Owner of the namespace
         * @param {string} agent_uuid UUID
         * @param {V1Agent} body Agent body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsV1UpdateAgent(owner: string, agent_uuid: string, body: V1Agent, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling agentsV1UpdateAgent.');
            }
            // verify required parameter 'agent_uuid' is not null or undefined
            if (agent_uuid === null || agent_uuid === undefined) {
                throw new RequiredError('agent_uuid','Required parameter agent_uuid was null or undefined when calling agentsV1UpdateAgent.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling agentsV1UpdateAgent.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{agent.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"agent.uuid"}}`, encodeURIComponent(String(agent_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Agent" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AgentsV1Api - functional programming interface
 * @export
 */
export const AgentsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create run profile
         * @param {string} owner Owner of the namespace
         * @param {V1Agent} body Agent body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsV1CreateAgent(owner: string, body: V1Agent, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Agent> {
            const localVarFetchArgs = AgentsV1ApiFetchParamCreator(configuration).agentsV1CreateAgent(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {V1AgentStatusBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsV1CreateAgentStatus(owner: string, uuid: string, body: V1AgentStatusBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Status> {
            const localVarFetchArgs = AgentsV1ApiFetchParamCreator(configuration).agentsV1CreateAgentStatus(owner, uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete run profile
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsV1DeleteAgent(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AgentsV1ApiFetchParamCreator(configuration).agentsV1DeleteAgent(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run profile
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsV1GetAgent(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Agent> {
            const localVarFetchArgs = AgentsV1ApiFetchParamCreator(configuration).agentsV1GetAgent(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsV1GetAgentState(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1AgentStateResponse> {
            const localVarFetchArgs = AgentsV1ApiFetchParamCreator(configuration).agentsV1GetAgentState(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsV1GetAgentStatuses(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Status> {
            const localVarFetchArgs = AgentsV1ApiFetchParamCreator(configuration).agentsV1GetAgentStatuses(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List run profiles names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsV1ListAgentNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListAgentsResponse> {
            const localVarFetchArgs = AgentsV1ApiFetchParamCreator(configuration).agentsV1ListAgentNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List run profiles
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsV1ListAgents(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListAgentsResponse> {
            const localVarFetchArgs = AgentsV1ApiFetchParamCreator(configuration).agentsV1ListAgents(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch run profile
         * @param {string} owner Owner of the namespace
         * @param {string} agent_uuid UUID
         * @param {V1Agent} body Agent body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsV1PatchAgent(owner: string, agent_uuid: string, body: V1Agent, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Agent> {
            const localVarFetchArgs = AgentsV1ApiFetchParamCreator(configuration).agentsV1PatchAgent(owner, agent_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {string} agent_uuid UUID
         * @param {V1Agent} body Agent body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsV1SyncAgent(owner: string, agent_uuid: string, body: V1Agent, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AgentsV1ApiFetchParamCreator(configuration).agentsV1SyncAgent(owner, agent_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update run profile
         * @param {string} owner Owner of the namespace
         * @param {string} agent_uuid UUID
         * @param {V1Agent} body Agent body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsV1UpdateAgent(owner: string, agent_uuid: string, body: V1Agent, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Agent> {
            const localVarFetchArgs = AgentsV1ApiFetchParamCreator(configuration).agentsV1UpdateAgent(owner, agent_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AgentsV1Api - factory interface
 * @export
 */
export const AgentsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create run profile
         * @param {string} owner Owner of the namespace
         * @param {V1Agent} body Agent body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsV1CreateAgent(owner: string, body: V1Agent, options?: any) {
            return AgentsV1ApiFp(configuration).agentsV1CreateAgent(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {V1AgentStatusBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsV1CreateAgentStatus(owner: string, uuid: string, body: V1AgentStatusBodyRequest, options?: any) {
            return AgentsV1ApiFp(configuration).agentsV1CreateAgentStatus(owner, uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete run profile
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsV1DeleteAgent(owner: string, uuid: string, options?: any) {
            return AgentsV1ApiFp(configuration).agentsV1DeleteAgent(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run profile
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsV1GetAgent(owner: string, uuid: string, options?: any) {
            return AgentsV1ApiFp(configuration).agentsV1GetAgent(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsV1GetAgentState(owner: string, uuid: string, options?: any) {
            return AgentsV1ApiFp(configuration).agentsV1GetAgentState(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsV1GetAgentStatuses(owner: string, uuid: string, options?: any) {
            return AgentsV1ApiFp(configuration).agentsV1GetAgentStatuses(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List run profiles names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsV1ListAgentNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return AgentsV1ApiFp(configuration).agentsV1ListAgentNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List run profiles
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsV1ListAgents(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return AgentsV1ApiFp(configuration).agentsV1ListAgents(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch run profile
         * @param {string} owner Owner of the namespace
         * @param {string} agent_uuid UUID
         * @param {V1Agent} body Agent body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsV1PatchAgent(owner: string, agent_uuid: string, body: V1Agent, options?: any) {
            return AgentsV1ApiFp(configuration).agentsV1PatchAgent(owner, agent_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {string} agent_uuid UUID
         * @param {V1Agent} body Agent body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsV1SyncAgent(owner: string, agent_uuid: string, body: V1Agent, options?: any) {
            return AgentsV1ApiFp(configuration).agentsV1SyncAgent(owner, agent_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update run profile
         * @param {string} owner Owner of the namespace
         * @param {string} agent_uuid UUID
         * @param {V1Agent} body Agent body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsV1UpdateAgent(owner: string, agent_uuid: string, body: V1Agent, options?: any) {
            return AgentsV1ApiFp(configuration).agentsV1UpdateAgent(owner, agent_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * AgentsV1Api - object-oriented interface
 * @export
 * @class AgentsV1Api
 * @extends {BaseAPI}
 */
export class AgentsV1Api extends BaseAPI {
    /**
     * 
     * @summary Create run profile
     * @param {string} owner Owner of the namespace
     * @param {V1Agent} body Agent body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsV1Api
     */
    public agentsV1CreateAgent(owner: string, body: V1Agent, options?: any) {
        return AgentsV1ApiFp(this.configuration).agentsV1CreateAgent(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Uuid identifier of the entity
     * @param {V1AgentStatusBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsV1Api
     */
    public agentsV1CreateAgentStatus(owner: string, uuid: string, body: V1AgentStatusBodyRequest, options?: any) {
        return AgentsV1ApiFp(this.configuration).agentsV1CreateAgentStatus(owner, uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete run profile
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsV1Api
     */
    public agentsV1DeleteAgent(owner: string, uuid: string, options?: any) {
        return AgentsV1ApiFp(this.configuration).agentsV1DeleteAgent(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run profile
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsV1Api
     */
    public agentsV1GetAgent(owner: string, uuid: string, options?: any) {
        return AgentsV1ApiFp(this.configuration).agentsV1GetAgent(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsV1Api
     */
    public agentsV1GetAgentState(owner: string, uuid: string, options?: any) {
        return AgentsV1ApiFp(this.configuration).agentsV1GetAgentState(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsV1Api
     */
    public agentsV1GetAgentStatuses(owner: string, uuid: string, options?: any) {
        return AgentsV1ApiFp(this.configuration).agentsV1GetAgentStatuses(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List run profiles names
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsV1Api
     */
    public agentsV1ListAgentNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return AgentsV1ApiFp(this.configuration).agentsV1ListAgentNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List run profiles
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsV1Api
     */
    public agentsV1ListAgents(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return AgentsV1ApiFp(this.configuration).agentsV1ListAgents(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch run profile
     * @param {string} owner Owner of the namespace
     * @param {string} agent_uuid UUID
     * @param {V1Agent} body Agent body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsV1Api
     */
    public agentsV1PatchAgent(owner: string, agent_uuid: string, body: V1Agent, options?: any) {
        return AgentsV1ApiFp(this.configuration).agentsV1PatchAgent(owner, agent_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} owner Owner of the namespace
     * @param {string} agent_uuid UUID
     * @param {V1Agent} body Agent body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsV1Api
     */
    public agentsV1SyncAgent(owner: string, agent_uuid: string, body: V1Agent, options?: any) {
        return AgentsV1ApiFp(this.configuration).agentsV1SyncAgent(owner, agent_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update run profile
     * @param {string} owner Owner of the namespace
     * @param {string} agent_uuid UUID
     * @param {V1Agent} body Agent body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsV1Api
     */
    public agentsV1UpdateAgent(owner: string, agent_uuid: string, body: V1Agent, options?: any) {
        return AgentsV1ApiFp(this.configuration).agentsV1UpdateAgent(owner, agent_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * ArtifactsStoresV1Api - fetch parameter creator
 * @export
 */
export const ArtifactsStoresV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Upload artifact to a store
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadArtifact(owner: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling uploadArtifact.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling uploadArtifact.');
            }
            // verify required parameter 'uploadfile' is not null or undefined
            if (uploadfile === null || uploadfile === undefined) {
                throw new RequiredError('uploadfile','Required parameter uploadfile was null or undefined when calling uploadArtifact.');
            }
            const localVarPath = `/api/v1/catalogs/{owner}/artifacts/{uuid}/upload`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (overwrite !== undefined) {
                localVarQueryParameter['overwrite'] = overwrite;
            }

            if (uploadfile !== undefined) {
                localVarFormParams.set('uploadfile', uploadfile as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtifactsStoresV1Api - functional programming interface
 * @export
 */
export const ArtifactsStoresV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Upload artifact to a store
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadArtifact(owner: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ArtifactsStoresV1ApiFetchParamCreator(configuration).uploadArtifact(owner, uuid, uploadfile, path, overwrite, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ArtifactsStoresV1Api - factory interface
 * @export
 */
export const ArtifactsStoresV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Upload artifact to a store
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadArtifact(owner: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any) {
            return ArtifactsStoresV1ApiFp(configuration).uploadArtifact(owner, uuid, uploadfile, path, overwrite, options)(fetch, basePath);
        },
    };
};

/**
 * ArtifactsStoresV1Api - object-oriented interface
 * @export
 * @class ArtifactsStoresV1Api
 * @extends {BaseAPI}
 */
export class ArtifactsStoresV1Api extends BaseAPI {
    /**
     * 
     * @summary Upload artifact to a store
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Unique integer identifier of the entity
     * @param {any} uploadfile The file to upload.
     * @param {string} [path] File path query params.
     * @param {boolean} [overwrite] File path query params.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsStoresV1Api
     */
    public uploadArtifact(owner: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any) {
        return ArtifactsStoresV1ApiFp(this.configuration).uploadArtifact(owner, uuid, uploadfile, path, overwrite, options)(this.fetch, this.basePath);
    }

}

/**
 * AuthV1Api - fetch parameter creator
 * @export
 */
export const AuthV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List organization level queues names
         * @param {V1CredsBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authV1Login(body: V1CredsBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling authV1Login.');
            }
            const localVarPath = `/api/v1/users/token`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1CredsBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthV1Api - functional programming interface
 * @export
 */
export const AuthV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List organization level queues names
         * @param {V1CredsBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authV1Login(body: V1CredsBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Auth> {
            const localVarFetchArgs = AuthV1ApiFetchParamCreator(configuration).authV1Login(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuthV1Api - factory interface
 * @export
 */
export const AuthV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List organization level queues names
         * @param {V1CredsBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authV1Login(body: V1CredsBodyRequest, options?: any) {
            return AuthV1ApiFp(configuration).authV1Login(body, options)(fetch, basePath);
        },
    };
};

/**
 * AuthV1Api - object-oriented interface
 * @export
 * @class AuthV1Api
 * @extends {BaseAPI}
 */
export class AuthV1Api extends BaseAPI {
    /**
     * 
     * @summary List organization level queues names
     * @param {V1CredsBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthV1Api
     */
    public authV1Login(body: V1CredsBodyRequest, options?: any) {
        return AuthV1ApiFp(this.configuration).authV1Login(body, options)(this.fetch, this.basePath);
    }

}

/**
 * ConnectionsV1Api - fetch parameter creator
 * @export
 */
export const ConnectionsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create connection
         * @param {string} owner Owner of the namespace
         * @param {V1ConnectionResponse} body Connection body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectionsV1CreateConnection(owner: string, body: V1ConnectionResponse, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling connectionsV1CreateConnection.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling connectionsV1CreateConnection.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/connections`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ConnectionResponse" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete connection
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectionsV1DeleteConnection(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling connectionsV1DeleteConnection.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling connectionsV1DeleteConnection.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/connections/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get connection
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectionsV1GetConnection(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling connectionsV1GetConnection.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling connectionsV1GetConnection.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/connections/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List connections names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectionsV1ListConnectionNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling connectionsV1ListConnectionNames.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/connections/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List connections
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectionsV1ListConnections(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling connectionsV1ListConnections.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/connections`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch connection
         * @param {string} owner Owner of the namespace
         * @param {string} connection_uuid UUID
         * @param {V1ConnectionResponse} body Connection body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectionsV1PatchConnection(owner: string, connection_uuid: string, body: V1ConnectionResponse, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling connectionsV1PatchConnection.');
            }
            // verify required parameter 'connection_uuid' is not null or undefined
            if (connection_uuid === null || connection_uuid === undefined) {
                throw new RequiredError('connection_uuid','Required parameter connection_uuid was null or undefined when calling connectionsV1PatchConnection.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling connectionsV1PatchConnection.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/connections/{connection.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"connection.uuid"}}`, encodeURIComponent(String(connection_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ConnectionResponse" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update connection
         * @param {string} owner Owner of the namespace
         * @param {string} connection_uuid UUID
         * @param {V1ConnectionResponse} body Connection body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectionsV1UpdateConnection(owner: string, connection_uuid: string, body: V1ConnectionResponse, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling connectionsV1UpdateConnection.');
            }
            // verify required parameter 'connection_uuid' is not null or undefined
            if (connection_uuid === null || connection_uuid === undefined) {
                throw new RequiredError('connection_uuid','Required parameter connection_uuid was null or undefined when calling connectionsV1UpdateConnection.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling connectionsV1UpdateConnection.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/connections/{connection.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"connection.uuid"}}`, encodeURIComponent(String(connection_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ConnectionResponse" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectionsV1Api - functional programming interface
 * @export
 */
export const ConnectionsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create connection
         * @param {string} owner Owner of the namespace
         * @param {V1ConnectionResponse} body Connection body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectionsV1CreateConnection(owner: string, body: V1ConnectionResponse, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ConnectionResponse> {
            const localVarFetchArgs = ConnectionsV1ApiFetchParamCreator(configuration).connectionsV1CreateConnection(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete connection
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectionsV1DeleteConnection(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ConnectionsV1ApiFetchParamCreator(configuration).connectionsV1DeleteConnection(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get connection
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectionsV1GetConnection(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ConnectionResponse> {
            const localVarFetchArgs = ConnectionsV1ApiFetchParamCreator(configuration).connectionsV1GetConnection(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List connections names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectionsV1ListConnectionNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListConnectionsResponse> {
            const localVarFetchArgs = ConnectionsV1ApiFetchParamCreator(configuration).connectionsV1ListConnectionNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List connections
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectionsV1ListConnections(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListConnectionsResponse> {
            const localVarFetchArgs = ConnectionsV1ApiFetchParamCreator(configuration).connectionsV1ListConnections(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch connection
         * @param {string} owner Owner of the namespace
         * @param {string} connection_uuid UUID
         * @param {V1ConnectionResponse} body Connection body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectionsV1PatchConnection(owner: string, connection_uuid: string, body: V1ConnectionResponse, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ConnectionResponse> {
            const localVarFetchArgs = ConnectionsV1ApiFetchParamCreator(configuration).connectionsV1PatchConnection(owner, connection_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update connection
         * @param {string} owner Owner of the namespace
         * @param {string} connection_uuid UUID
         * @param {V1ConnectionResponse} body Connection body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectionsV1UpdateConnection(owner: string, connection_uuid: string, body: V1ConnectionResponse, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ConnectionResponse> {
            const localVarFetchArgs = ConnectionsV1ApiFetchParamCreator(configuration).connectionsV1UpdateConnection(owner, connection_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ConnectionsV1Api - factory interface
 * @export
 */
export const ConnectionsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create connection
         * @param {string} owner Owner of the namespace
         * @param {V1ConnectionResponse} body Connection body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectionsV1CreateConnection(owner: string, body: V1ConnectionResponse, options?: any) {
            return ConnectionsV1ApiFp(configuration).connectionsV1CreateConnection(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete connection
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectionsV1DeleteConnection(owner: string, uuid: string, options?: any) {
            return ConnectionsV1ApiFp(configuration).connectionsV1DeleteConnection(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get connection
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectionsV1GetConnection(owner: string, uuid: string, options?: any) {
            return ConnectionsV1ApiFp(configuration).connectionsV1GetConnection(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List connections names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectionsV1ListConnectionNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ConnectionsV1ApiFp(configuration).connectionsV1ListConnectionNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List connections
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectionsV1ListConnections(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ConnectionsV1ApiFp(configuration).connectionsV1ListConnections(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch connection
         * @param {string} owner Owner of the namespace
         * @param {string} connection_uuid UUID
         * @param {V1ConnectionResponse} body Connection body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectionsV1PatchConnection(owner: string, connection_uuid: string, body: V1ConnectionResponse, options?: any) {
            return ConnectionsV1ApiFp(configuration).connectionsV1PatchConnection(owner, connection_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update connection
         * @param {string} owner Owner of the namespace
         * @param {string} connection_uuid UUID
         * @param {V1ConnectionResponse} body Connection body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectionsV1UpdateConnection(owner: string, connection_uuid: string, body: V1ConnectionResponse, options?: any) {
            return ConnectionsV1ApiFp(configuration).connectionsV1UpdateConnection(owner, connection_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * ConnectionsV1Api - object-oriented interface
 * @export
 * @class ConnectionsV1Api
 * @extends {BaseAPI}
 */
export class ConnectionsV1Api extends BaseAPI {
    /**
     * 
     * @summary Create connection
     * @param {string} owner Owner of the namespace
     * @param {V1ConnectionResponse} body Connection body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsV1Api
     */
    public connectionsV1CreateConnection(owner: string, body: V1ConnectionResponse, options?: any) {
        return ConnectionsV1ApiFp(this.configuration).connectionsV1CreateConnection(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete connection
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsV1Api
     */
    public connectionsV1DeleteConnection(owner: string, uuid: string, options?: any) {
        return ConnectionsV1ApiFp(this.configuration).connectionsV1DeleteConnection(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get connection
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsV1Api
     */
    public connectionsV1GetConnection(owner: string, uuid: string, options?: any) {
        return ConnectionsV1ApiFp(this.configuration).connectionsV1GetConnection(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List connections names
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsV1Api
     */
    public connectionsV1ListConnectionNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ConnectionsV1ApiFp(this.configuration).connectionsV1ListConnectionNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List connections
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsV1Api
     */
    public connectionsV1ListConnections(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ConnectionsV1ApiFp(this.configuration).connectionsV1ListConnections(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch connection
     * @param {string} owner Owner of the namespace
     * @param {string} connection_uuid UUID
     * @param {V1ConnectionResponse} body Connection body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsV1Api
     */
    public connectionsV1PatchConnection(owner: string, connection_uuid: string, body: V1ConnectionResponse, options?: any) {
        return ConnectionsV1ApiFp(this.configuration).connectionsV1PatchConnection(owner, connection_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update connection
     * @param {string} owner Owner of the namespace
     * @param {string} connection_uuid UUID
     * @param {V1ConnectionResponse} body Connection body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsV1Api
     */
    public connectionsV1UpdateConnection(owner: string, connection_uuid: string, body: V1ConnectionResponse, options?: any) {
        return ConnectionsV1ApiFp(this.configuration).connectionsV1UpdateConnection(owner, connection_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * DashboardsV1Api - fetch parameter creator
 * @export
 */
export const DashboardsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsV1CreateDashboard(owner: string, body: V1Dashboard, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling dashboardsV1CreateDashboard.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling dashboardsV1CreateDashboard.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/dashboards`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Dashboard" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsV1DeleteDashboard(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling dashboardsV1DeleteDashboard.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling dashboardsV1DeleteDashboard.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/dashboards/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsV1GetDashboard(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling dashboardsV1GetDashboard.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling dashboardsV1GetDashboard.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/dashboards/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsV1ListDashboardNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling dashboardsV1ListDashboardNames.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/dashboards/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsV1ListDashboards(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling dashboardsV1ListDashboards.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/dashboards`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {string} dashboard_uuid UUID
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsV1PatchDashboard(owner: string, dashboard_uuid: string, body: V1Dashboard, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling dashboardsV1PatchDashboard.');
            }
            // verify required parameter 'dashboard_uuid' is not null or undefined
            if (dashboard_uuid === null || dashboard_uuid === undefined) {
                throw new RequiredError('dashboard_uuid','Required parameter dashboard_uuid was null or undefined when calling dashboardsV1PatchDashboard.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling dashboardsV1PatchDashboard.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/dashboards/{dashboard.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"dashboard.uuid"}}`, encodeURIComponent(String(dashboard_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Dashboard" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {string} dashboard_uuid UUID
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsV1UpdateDashboard(owner: string, dashboard_uuid: string, body: V1Dashboard, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling dashboardsV1UpdateDashboard.');
            }
            // verify required parameter 'dashboard_uuid' is not null or undefined
            if (dashboard_uuid === null || dashboard_uuid === undefined) {
                throw new RequiredError('dashboard_uuid','Required parameter dashboard_uuid was null or undefined when calling dashboardsV1UpdateDashboard.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling dashboardsV1UpdateDashboard.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/dashboards/{dashboard.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"dashboard.uuid"}}`, encodeURIComponent(String(dashboard_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Dashboard" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardsV1Api - functional programming interface
 * @export
 */
export const DashboardsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsV1CreateDashboard(owner: string, body: V1Dashboard, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Dashboard> {
            const localVarFetchArgs = DashboardsV1ApiFetchParamCreator(configuration).dashboardsV1CreateDashboard(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsV1DeleteDashboard(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DashboardsV1ApiFetchParamCreator(configuration).dashboardsV1DeleteDashboard(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsV1GetDashboard(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Dashboard> {
            const localVarFetchArgs = DashboardsV1ApiFetchParamCreator(configuration).dashboardsV1GetDashboard(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsV1ListDashboardNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListDashboardsResponse> {
            const localVarFetchArgs = DashboardsV1ApiFetchParamCreator(configuration).dashboardsV1ListDashboardNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsV1ListDashboards(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListDashboardsResponse> {
            const localVarFetchArgs = DashboardsV1ApiFetchParamCreator(configuration).dashboardsV1ListDashboards(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {string} dashboard_uuid UUID
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsV1PatchDashboard(owner: string, dashboard_uuid: string, body: V1Dashboard, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Dashboard> {
            const localVarFetchArgs = DashboardsV1ApiFetchParamCreator(configuration).dashboardsV1PatchDashboard(owner, dashboard_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {string} dashboard_uuid UUID
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsV1UpdateDashboard(owner: string, dashboard_uuid: string, body: V1Dashboard, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Dashboard> {
            const localVarFetchArgs = DashboardsV1ApiFetchParamCreator(configuration).dashboardsV1UpdateDashboard(owner, dashboard_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DashboardsV1Api - factory interface
 * @export
 */
export const DashboardsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsV1CreateDashboard(owner: string, body: V1Dashboard, options?: any) {
            return DashboardsV1ApiFp(configuration).dashboardsV1CreateDashboard(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsV1DeleteDashboard(owner: string, uuid: string, options?: any) {
            return DashboardsV1ApiFp(configuration).dashboardsV1DeleteDashboard(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsV1GetDashboard(owner: string, uuid: string, options?: any) {
            return DashboardsV1ApiFp(configuration).dashboardsV1GetDashboard(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsV1ListDashboardNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return DashboardsV1ApiFp(configuration).dashboardsV1ListDashboardNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsV1ListDashboards(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return DashboardsV1ApiFp(configuration).dashboardsV1ListDashboards(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {string} dashboard_uuid UUID
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsV1PatchDashboard(owner: string, dashboard_uuid: string, body: V1Dashboard, options?: any) {
            return DashboardsV1ApiFp(configuration).dashboardsV1PatchDashboard(owner, dashboard_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {string} dashboard_uuid UUID
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardsV1UpdateDashboard(owner: string, dashboard_uuid: string, body: V1Dashboard, options?: any) {
            return DashboardsV1ApiFp(configuration).dashboardsV1UpdateDashboard(owner, dashboard_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * DashboardsV1Api - object-oriented interface
 * @export
 * @class DashboardsV1Api
 * @extends {BaseAPI}
 */
export class DashboardsV1Api extends BaseAPI {
    /**
     * 
     * @param {string} owner Owner of the namespace
     * @param {V1Dashboard} body Dashboard body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsV1Api
     */
    public dashboardsV1CreateDashboard(owner: string, body: V1Dashboard, options?: any) {
        return DashboardsV1ApiFp(this.configuration).dashboardsV1CreateDashboard(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsV1Api
     */
    public dashboardsV1DeleteDashboard(owner: string, uuid: string, options?: any) {
        return DashboardsV1ApiFp(this.configuration).dashboardsV1DeleteDashboard(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsV1Api
     */
    public dashboardsV1GetDashboard(owner: string, uuid: string, options?: any) {
        return DashboardsV1ApiFp(this.configuration).dashboardsV1GetDashboard(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsV1Api
     */
    public dashboardsV1ListDashboardNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return DashboardsV1ApiFp(this.configuration).dashboardsV1ListDashboardNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsV1Api
     */
    public dashboardsV1ListDashboards(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return DashboardsV1ApiFp(this.configuration).dashboardsV1ListDashboards(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} owner Owner of the namespace
     * @param {string} dashboard_uuid UUID
     * @param {V1Dashboard} body Dashboard body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsV1Api
     */
    public dashboardsV1PatchDashboard(owner: string, dashboard_uuid: string, body: V1Dashboard, options?: any) {
        return DashboardsV1ApiFp(this.configuration).dashboardsV1PatchDashboard(owner, dashboard_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} owner Owner of the namespace
     * @param {string} dashboard_uuid UUID
     * @param {V1Dashboard} body Dashboard body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsV1Api
     */
    public dashboardsV1UpdateDashboard(owner: string, dashboard_uuid: string, body: V1Dashboard, options?: any) {
        return DashboardsV1ApiFp(this.configuration).dashboardsV1UpdateDashboard(owner, dashboard_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * HubComponentsV1Api - fetch parameter creator
 * @export
 */
export const HubComponentsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create hub model
         * @param {string} owner Owner of the namespace
         * @param {V1HubComponent} body Component body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubComponentsV1CreateHubComponent(owner: string, body: V1HubComponent, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling hubComponentsV1CreateHubComponent.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling hubComponentsV1CreateHubComponent.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/components`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1HubComponent" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete hub model
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubComponentsV1DeleteHubComponent(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling hubComponentsV1DeleteHubComponent.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling hubComponentsV1DeleteHubComponent.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/components/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get hub model
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubComponentsV1GetHubComponent(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling hubComponentsV1GetHubComponent.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling hubComponentsV1GetHubComponent.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/components/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List hub model names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubComponentsV1ListHubComponebtNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling hubComponentsV1ListHubComponebtNames.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/components/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List hub models
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubComponentsV1ListHubComponents(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling hubComponentsV1ListHubComponents.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/components`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch hub model
         * @param {string} owner Owner of the namespace
         * @param {string} component_uuid UUID
         * @param {V1HubComponent} body Component body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubComponentsV1PatchHubComponent(owner: string, component_uuid: string, body: V1HubComponent, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling hubComponentsV1PatchHubComponent.');
            }
            // verify required parameter 'component_uuid' is not null or undefined
            if (component_uuid === null || component_uuid === undefined) {
                throw new RequiredError('component_uuid','Required parameter component_uuid was null or undefined when calling hubComponentsV1PatchHubComponent.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling hubComponentsV1PatchHubComponent.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/components/{component.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"component.uuid"}}`, encodeURIComponent(String(component_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1HubComponent" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update hub model
         * @param {string} owner Owner of the namespace
         * @param {string} component_uuid UUID
         * @param {V1HubComponent} body Component body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubComponentsV1UpdateHubComponent(owner: string, component_uuid: string, body: V1HubComponent, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling hubComponentsV1UpdateHubComponent.');
            }
            // verify required parameter 'component_uuid' is not null or undefined
            if (component_uuid === null || component_uuid === undefined) {
                throw new RequiredError('component_uuid','Required parameter component_uuid was null or undefined when calling hubComponentsV1UpdateHubComponent.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling hubComponentsV1UpdateHubComponent.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/components/{component.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"component.uuid"}}`, encodeURIComponent(String(component_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1HubComponent" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HubComponentsV1Api - functional programming interface
 * @export
 */
export const HubComponentsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create hub model
         * @param {string} owner Owner of the namespace
         * @param {V1HubComponent} body Component body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubComponentsV1CreateHubComponent(owner: string, body: V1HubComponent, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1HubComponent> {
            const localVarFetchArgs = HubComponentsV1ApiFetchParamCreator(configuration).hubComponentsV1CreateHubComponent(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete hub model
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubComponentsV1DeleteHubComponent(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = HubComponentsV1ApiFetchParamCreator(configuration).hubComponentsV1DeleteHubComponent(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get hub model
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubComponentsV1GetHubComponent(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1HubComponent> {
            const localVarFetchArgs = HubComponentsV1ApiFetchParamCreator(configuration).hubComponentsV1GetHubComponent(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List hub model names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubComponentsV1ListHubComponebtNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListHubComponentsResponse> {
            const localVarFetchArgs = HubComponentsV1ApiFetchParamCreator(configuration).hubComponentsV1ListHubComponebtNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List hub models
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubComponentsV1ListHubComponents(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListHubComponentsResponse> {
            const localVarFetchArgs = HubComponentsV1ApiFetchParamCreator(configuration).hubComponentsV1ListHubComponents(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch hub model
         * @param {string} owner Owner of the namespace
         * @param {string} component_uuid UUID
         * @param {V1HubComponent} body Component body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubComponentsV1PatchHubComponent(owner: string, component_uuid: string, body: V1HubComponent, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1HubComponent> {
            const localVarFetchArgs = HubComponentsV1ApiFetchParamCreator(configuration).hubComponentsV1PatchHubComponent(owner, component_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update hub model
         * @param {string} owner Owner of the namespace
         * @param {string} component_uuid UUID
         * @param {V1HubComponent} body Component body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubComponentsV1UpdateHubComponent(owner: string, component_uuid: string, body: V1HubComponent, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1HubComponent> {
            const localVarFetchArgs = HubComponentsV1ApiFetchParamCreator(configuration).hubComponentsV1UpdateHubComponent(owner, component_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * HubComponentsV1Api - factory interface
 * @export
 */
export const HubComponentsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create hub model
         * @param {string} owner Owner of the namespace
         * @param {V1HubComponent} body Component body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubComponentsV1CreateHubComponent(owner: string, body: V1HubComponent, options?: any) {
            return HubComponentsV1ApiFp(configuration).hubComponentsV1CreateHubComponent(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete hub model
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubComponentsV1DeleteHubComponent(owner: string, uuid: string, options?: any) {
            return HubComponentsV1ApiFp(configuration).hubComponentsV1DeleteHubComponent(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get hub model
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubComponentsV1GetHubComponent(owner: string, uuid: string, options?: any) {
            return HubComponentsV1ApiFp(configuration).hubComponentsV1GetHubComponent(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List hub model names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubComponentsV1ListHubComponebtNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return HubComponentsV1ApiFp(configuration).hubComponentsV1ListHubComponebtNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List hub models
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubComponentsV1ListHubComponents(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return HubComponentsV1ApiFp(configuration).hubComponentsV1ListHubComponents(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch hub model
         * @param {string} owner Owner of the namespace
         * @param {string} component_uuid UUID
         * @param {V1HubComponent} body Component body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubComponentsV1PatchHubComponent(owner: string, component_uuid: string, body: V1HubComponent, options?: any) {
            return HubComponentsV1ApiFp(configuration).hubComponentsV1PatchHubComponent(owner, component_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update hub model
         * @param {string} owner Owner of the namespace
         * @param {string} component_uuid UUID
         * @param {V1HubComponent} body Component body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubComponentsV1UpdateHubComponent(owner: string, component_uuid: string, body: V1HubComponent, options?: any) {
            return HubComponentsV1ApiFp(configuration).hubComponentsV1UpdateHubComponent(owner, component_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * HubComponentsV1Api - object-oriented interface
 * @export
 * @class HubComponentsV1Api
 * @extends {BaseAPI}
 */
export class HubComponentsV1Api extends BaseAPI {
    /**
     * 
     * @summary Create hub model
     * @param {string} owner Owner of the namespace
     * @param {V1HubComponent} body Component body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HubComponentsV1Api
     */
    public hubComponentsV1CreateHubComponent(owner: string, body: V1HubComponent, options?: any) {
        return HubComponentsV1ApiFp(this.configuration).hubComponentsV1CreateHubComponent(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete hub model
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HubComponentsV1Api
     */
    public hubComponentsV1DeleteHubComponent(owner: string, uuid: string, options?: any) {
        return HubComponentsV1ApiFp(this.configuration).hubComponentsV1DeleteHubComponent(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get hub model
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HubComponentsV1Api
     */
    public hubComponentsV1GetHubComponent(owner: string, uuid: string, options?: any) {
        return HubComponentsV1ApiFp(this.configuration).hubComponentsV1GetHubComponent(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List hub model names
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HubComponentsV1Api
     */
    public hubComponentsV1ListHubComponebtNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return HubComponentsV1ApiFp(this.configuration).hubComponentsV1ListHubComponebtNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List hub models
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HubComponentsV1Api
     */
    public hubComponentsV1ListHubComponents(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return HubComponentsV1ApiFp(this.configuration).hubComponentsV1ListHubComponents(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch hub model
     * @param {string} owner Owner of the namespace
     * @param {string} component_uuid UUID
     * @param {V1HubComponent} body Component body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HubComponentsV1Api
     */
    public hubComponentsV1PatchHubComponent(owner: string, component_uuid: string, body: V1HubComponent, options?: any) {
        return HubComponentsV1ApiFp(this.configuration).hubComponentsV1PatchHubComponent(owner, component_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update hub model
     * @param {string} owner Owner of the namespace
     * @param {string} component_uuid UUID
     * @param {V1HubComponent} body Component body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HubComponentsV1Api
     */
    public hubComponentsV1UpdateHubComponent(owner: string, component_uuid: string, body: V1HubComponent, options?: any) {
        return HubComponentsV1ApiFp(this.configuration).hubComponentsV1UpdateHubComponent(owner, component_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * HubModelsV1Api - fetch parameter creator
 * @export
 */
export const HubModelsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create dashboard
         * @param {string} owner Owner of the namespace
         * @param {V1HubModel} body Model body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubModelsV1CreateHubModel(owner: string, body: V1HubModel, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling hubModelsV1CreateHubModel.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling hubModelsV1CreateHubModel.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/models`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1HubModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubModelsV1DeleteHubModel(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling hubModelsV1DeleteHubModel.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling hubModelsV1DeleteHubModel.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/models/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubModelsV1GetHubModel(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling hubModelsV1GetHubModel.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling hubModelsV1GetHubModel.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/models/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List dashboard names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubModelsV1ListHubModelNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling hubModelsV1ListHubModelNames.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/models/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List dashboards
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubModelsV1ListHubModels(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling hubModelsV1ListHubModels.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/models`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} model_uuid UUID
         * @param {V1HubModel} body Model body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubModelsV1PatchHubModel(owner: string, model_uuid: string, body: V1HubModel, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling hubModelsV1PatchHubModel.');
            }
            // verify required parameter 'model_uuid' is not null or undefined
            if (model_uuid === null || model_uuid === undefined) {
                throw new RequiredError('model_uuid','Required parameter model_uuid was null or undefined when calling hubModelsV1PatchHubModel.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling hubModelsV1PatchHubModel.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/models/{model.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"model.uuid"}}`, encodeURIComponent(String(model_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1HubModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} model_uuid UUID
         * @param {V1HubModel} body Model body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubModelsV1UpdateHubModel(owner: string, model_uuid: string, body: V1HubModel, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling hubModelsV1UpdateHubModel.');
            }
            // verify required parameter 'model_uuid' is not null or undefined
            if (model_uuid === null || model_uuid === undefined) {
                throw new RequiredError('model_uuid','Required parameter model_uuid was null or undefined when calling hubModelsV1UpdateHubModel.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling hubModelsV1UpdateHubModel.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/models/{model.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"model.uuid"}}`, encodeURIComponent(String(model_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1HubModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HubModelsV1Api - functional programming interface
 * @export
 */
export const HubModelsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create dashboard
         * @param {string} owner Owner of the namespace
         * @param {V1HubModel} body Model body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubModelsV1CreateHubModel(owner: string, body: V1HubModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1HubModel> {
            const localVarFetchArgs = HubModelsV1ApiFetchParamCreator(configuration).hubModelsV1CreateHubModel(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubModelsV1DeleteHubModel(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = HubModelsV1ApiFetchParamCreator(configuration).hubModelsV1DeleteHubModel(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubModelsV1GetHubModel(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1HubModel> {
            const localVarFetchArgs = HubModelsV1ApiFetchParamCreator(configuration).hubModelsV1GetHubModel(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List dashboard names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubModelsV1ListHubModelNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListHubModelsResponse> {
            const localVarFetchArgs = HubModelsV1ApiFetchParamCreator(configuration).hubModelsV1ListHubModelNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List dashboards
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubModelsV1ListHubModels(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListHubModelsResponse> {
            const localVarFetchArgs = HubModelsV1ApiFetchParamCreator(configuration).hubModelsV1ListHubModels(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} model_uuid UUID
         * @param {V1HubModel} body Model body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubModelsV1PatchHubModel(owner: string, model_uuid: string, body: V1HubModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1HubModel> {
            const localVarFetchArgs = HubModelsV1ApiFetchParamCreator(configuration).hubModelsV1PatchHubModel(owner, model_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} model_uuid UUID
         * @param {V1HubModel} body Model body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubModelsV1UpdateHubModel(owner: string, model_uuid: string, body: V1HubModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1HubModel> {
            const localVarFetchArgs = HubModelsV1ApiFetchParamCreator(configuration).hubModelsV1UpdateHubModel(owner, model_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * HubModelsV1Api - factory interface
 * @export
 */
export const HubModelsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create dashboard
         * @param {string} owner Owner of the namespace
         * @param {V1HubModel} body Model body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubModelsV1CreateHubModel(owner: string, body: V1HubModel, options?: any) {
            return HubModelsV1ApiFp(configuration).hubModelsV1CreateHubModel(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubModelsV1DeleteHubModel(owner: string, uuid: string, options?: any) {
            return HubModelsV1ApiFp(configuration).hubModelsV1DeleteHubModel(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubModelsV1GetHubModel(owner: string, uuid: string, options?: any) {
            return HubModelsV1ApiFp(configuration).hubModelsV1GetHubModel(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List dashboard names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubModelsV1ListHubModelNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return HubModelsV1ApiFp(configuration).hubModelsV1ListHubModelNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List dashboards
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubModelsV1ListHubModels(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return HubModelsV1ApiFp(configuration).hubModelsV1ListHubModels(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} model_uuid UUID
         * @param {V1HubModel} body Model body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubModelsV1PatchHubModel(owner: string, model_uuid: string, body: V1HubModel, options?: any) {
            return HubModelsV1ApiFp(configuration).hubModelsV1PatchHubModel(owner, model_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} model_uuid UUID
         * @param {V1HubModel} body Model body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubModelsV1UpdateHubModel(owner: string, model_uuid: string, body: V1HubModel, options?: any) {
            return HubModelsV1ApiFp(configuration).hubModelsV1UpdateHubModel(owner, model_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * HubModelsV1Api - object-oriented interface
 * @export
 * @class HubModelsV1Api
 * @extends {BaseAPI}
 */
export class HubModelsV1Api extends BaseAPI {
    /**
     * 
     * @summary Create dashboard
     * @param {string} owner Owner of the namespace
     * @param {V1HubModel} body Model body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HubModelsV1Api
     */
    public hubModelsV1CreateHubModel(owner: string, body: V1HubModel, options?: any) {
        return HubModelsV1ApiFp(this.configuration).hubModelsV1CreateHubModel(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete dashboard
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HubModelsV1Api
     */
    public hubModelsV1DeleteHubModel(owner: string, uuid: string, options?: any) {
        return HubModelsV1ApiFp(this.configuration).hubModelsV1DeleteHubModel(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get dashboard
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HubModelsV1Api
     */
    public hubModelsV1GetHubModel(owner: string, uuid: string, options?: any) {
        return HubModelsV1ApiFp(this.configuration).hubModelsV1GetHubModel(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List dashboard names
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HubModelsV1Api
     */
    public hubModelsV1ListHubModelNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return HubModelsV1ApiFp(this.configuration).hubModelsV1ListHubModelNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List dashboards
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HubModelsV1Api
     */
    public hubModelsV1ListHubModels(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return HubModelsV1ApiFp(this.configuration).hubModelsV1ListHubModels(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch dashboard
     * @param {string} owner Owner of the namespace
     * @param {string} model_uuid UUID
     * @param {V1HubModel} body Model body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HubModelsV1Api
     */
    public hubModelsV1PatchHubModel(owner: string, model_uuid: string, body: V1HubModel, options?: any) {
        return HubModelsV1ApiFp(this.configuration).hubModelsV1PatchHubModel(owner, model_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update dashboard
     * @param {string} owner Owner of the namespace
     * @param {string} model_uuid UUID
     * @param {V1HubModel} body Model body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HubModelsV1Api
     */
    public hubModelsV1UpdateHubModel(owner: string, model_uuid: string, body: V1HubModel, options?: any) {
        return HubModelsV1ApiFp(this.configuration).hubModelsV1UpdateHubModel(owner, model_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * OrganizationsV1Api - fetch parameter creator
 * @export
 */
export const OrganizationsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {V1Organization} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1CreateOrganization(body: V1Organization, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling organizationsV1CreateOrganization.');
            }
            const localVarPath = `/api/v1/orgs/create`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Organization" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {V1OrganizationMember} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1CreateOrganizationMember(owner: string, body: V1OrganizationMember, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling organizationsV1CreateOrganizationMember.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling organizationsV1CreateOrganizationMember.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/members`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1OrganizationMember" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1DeleteOrganization(owner: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling organizationsV1DeleteOrganization.');
            }
            const localVarPath = `/api/v1/orgs/{owner}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {string} user Memeber under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1DeleteOrganizationMember(owner: string, user: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling organizationsV1DeleteOrganizationMember.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling organizationsV1DeleteOrganizationMember.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/members/{user}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1GetOrganization(owner: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling organizationsV1GetOrganization.');
            }
            const localVarPath = `/api/v1/orgs/{owner}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {string} user Memeber under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1GetOrganizationMember(owner: string, user: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling organizationsV1GetOrganizationMember.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling organizationsV1GetOrganizationMember.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/members/{user}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1ListOrganizationMembers(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling organizationsV1ListOrganizationMembers.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/members`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1ListOrganizationNames(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/orgs/names`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get log handler
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1ListOrganizations(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/orgs/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {V1Organization} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1PatchOrganization(owner: string, body: V1Organization, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling organizationsV1PatchOrganization.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling organizationsV1PatchOrganization.');
            }
            const localVarPath = `/api/v1/orgs/{owner}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Organization" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {string} member_user User
         * @param {V1OrganizationMember} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1PatchOrganizationMember(owner: string, member_user: string, body: V1OrganizationMember, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling organizationsV1PatchOrganizationMember.');
            }
            // verify required parameter 'member_user' is not null or undefined
            if (member_user === null || member_user === undefined) {
                throw new RequiredError('member_user','Required parameter member_user was null or undefined when calling organizationsV1PatchOrganizationMember.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling organizationsV1PatchOrganizationMember.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/members/{member.user}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"member.user"}}`, encodeURIComponent(String(member_user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1OrganizationMember" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {V1Organization} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1UpdateOrganization(owner: string, body: V1Organization, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling organizationsV1UpdateOrganization.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling organizationsV1UpdateOrganization.');
            }
            const localVarPath = `/api/v1/orgs/{owner}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Organization" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {string} member_user User
         * @param {V1OrganizationMember} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1UpdateOrganizationMember(owner: string, member_user: string, body: V1OrganizationMember, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling organizationsV1UpdateOrganizationMember.');
            }
            // verify required parameter 'member_user' is not null or undefined
            if (member_user === null || member_user === undefined) {
                throw new RequiredError('member_user','Required parameter member_user was null or undefined when calling organizationsV1UpdateOrganizationMember.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling organizationsV1UpdateOrganizationMember.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/members/{member.user}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"member.user"}}`, encodeURIComponent(String(member_user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1OrganizationMember" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationsV1Api - functional programming interface
 * @export
 */
export const OrganizationsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {V1Organization} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1CreateOrganization(body: V1Organization, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Organization> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).organizationsV1CreateOrganization(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {V1OrganizationMember} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1CreateOrganizationMember(owner: string, body: V1OrganizationMember, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1OrganizationMember> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).organizationsV1CreateOrganizationMember(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1DeleteOrganization(owner: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).organizationsV1DeleteOrganization(owner, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {string} user Memeber under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1DeleteOrganizationMember(owner: string, user: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).organizationsV1DeleteOrganizationMember(owner, user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1GetOrganization(owner: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Organization> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).organizationsV1GetOrganization(owner, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {string} user Memeber under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1GetOrganizationMember(owner: string, user: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1OrganizationMember> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).organizationsV1GetOrganizationMember(owner, user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1ListOrganizationMembers(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListOrganizationMembersResponse> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).organizationsV1ListOrganizationMembers(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1ListOrganizationNames(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListOrganizationsResponse> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).organizationsV1ListOrganizationNames(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get log handler
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1ListOrganizations(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListOrganizationsResponse> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).organizationsV1ListOrganizations(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {V1Organization} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1PatchOrganization(owner: string, body: V1Organization, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Organization> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).organizationsV1PatchOrganization(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {string} member_user User
         * @param {V1OrganizationMember} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1PatchOrganizationMember(owner: string, member_user: string, body: V1OrganizationMember, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1OrganizationMember> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).organizationsV1PatchOrganizationMember(owner, member_user, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {V1Organization} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1UpdateOrganization(owner: string, body: V1Organization, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Organization> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).organizationsV1UpdateOrganization(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {string} member_user User
         * @param {V1OrganizationMember} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1UpdateOrganizationMember(owner: string, member_user: string, body: V1OrganizationMember, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1OrganizationMember> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).organizationsV1UpdateOrganizationMember(owner, member_user, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OrganizationsV1Api - factory interface
 * @export
 */
export const OrganizationsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {V1Organization} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1CreateOrganization(body: V1Organization, options?: any) {
            return OrganizationsV1ApiFp(configuration).organizationsV1CreateOrganization(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {V1OrganizationMember} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1CreateOrganizationMember(owner: string, body: V1OrganizationMember, options?: any) {
            return OrganizationsV1ApiFp(configuration).organizationsV1CreateOrganizationMember(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1DeleteOrganization(owner: string, options?: any) {
            return OrganizationsV1ApiFp(configuration).organizationsV1DeleteOrganization(owner, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {string} user Memeber under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1DeleteOrganizationMember(owner: string, user: string, options?: any) {
            return OrganizationsV1ApiFp(configuration).organizationsV1DeleteOrganizationMember(owner, user, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1GetOrganization(owner: string, options?: any) {
            return OrganizationsV1ApiFp(configuration).organizationsV1GetOrganization(owner, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {string} user Memeber under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1GetOrganizationMember(owner: string, user: string, options?: any) {
            return OrganizationsV1ApiFp(configuration).organizationsV1GetOrganizationMember(owner, user, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1ListOrganizationMembers(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return OrganizationsV1ApiFp(configuration).organizationsV1ListOrganizationMembers(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1ListOrganizationNames(options?: any) {
            return OrganizationsV1ApiFp(configuration).organizationsV1ListOrganizationNames(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get log handler
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1ListOrganizations(options?: any) {
            return OrganizationsV1ApiFp(configuration).organizationsV1ListOrganizations(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {V1Organization} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1PatchOrganization(owner: string, body: V1Organization, options?: any) {
            return OrganizationsV1ApiFp(configuration).organizationsV1PatchOrganization(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {string} member_user User
         * @param {V1OrganizationMember} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1PatchOrganizationMember(owner: string, member_user: string, body: V1OrganizationMember, options?: any) {
            return OrganizationsV1ApiFp(configuration).organizationsV1PatchOrganizationMember(owner, member_user, body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {V1Organization} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1UpdateOrganization(owner: string, body: V1Organization, options?: any) {
            return OrganizationsV1ApiFp(configuration).organizationsV1UpdateOrganization(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} owner Owner of the namespace
         * @param {string} member_user User
         * @param {V1OrganizationMember} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsV1UpdateOrganizationMember(owner: string, member_user: string, body: V1OrganizationMember, options?: any) {
            return OrganizationsV1ApiFp(configuration).organizationsV1UpdateOrganizationMember(owner, member_user, body, options)(fetch, basePath);
        },
    };
};

/**
 * OrganizationsV1Api - object-oriented interface
 * @export
 * @class OrganizationsV1Api
 * @extends {BaseAPI}
 */
export class OrganizationsV1Api extends BaseAPI {
    /**
     * 
     * @param {V1Organization} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public organizationsV1CreateOrganization(body: V1Organization, options?: any) {
        return OrganizationsV1ApiFp(this.configuration).organizationsV1CreateOrganization(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} owner Owner of the namespace
     * @param {V1OrganizationMember} body Organization body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public organizationsV1CreateOrganizationMember(owner: string, body: V1OrganizationMember, options?: any) {
        return OrganizationsV1ApiFp(this.configuration).organizationsV1CreateOrganizationMember(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} owner Owner of the namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public organizationsV1DeleteOrganization(owner: string, options?: any) {
        return OrganizationsV1ApiFp(this.configuration).organizationsV1DeleteOrganization(owner, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} owner Owner of the namespace
     * @param {string} user Memeber under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public organizationsV1DeleteOrganizationMember(owner: string, user: string, options?: any) {
        return OrganizationsV1ApiFp(this.configuration).organizationsV1DeleteOrganizationMember(owner, user, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} owner Owner of the namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public organizationsV1GetOrganization(owner: string, options?: any) {
        return OrganizationsV1ApiFp(this.configuration).organizationsV1GetOrganization(owner, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} owner Owner of the namespace
     * @param {string} user Memeber under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public organizationsV1GetOrganizationMember(owner: string, user: string, options?: any) {
        return OrganizationsV1ApiFp(this.configuration).organizationsV1GetOrganizationMember(owner, user, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public organizationsV1ListOrganizationMembers(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return OrganizationsV1ApiFp(this.configuration).organizationsV1ListOrganizationMembers(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get versions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public organizationsV1ListOrganizationNames(options?: any) {
        return OrganizationsV1ApiFp(this.configuration).organizationsV1ListOrganizationNames(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get log handler
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public organizationsV1ListOrganizations(options?: any) {
        return OrganizationsV1ApiFp(this.configuration).organizationsV1ListOrganizations(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} owner Owner of the namespace
     * @param {V1Organization} body Organization body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public organizationsV1PatchOrganization(owner: string, body: V1Organization, options?: any) {
        return OrganizationsV1ApiFp(this.configuration).organizationsV1PatchOrganization(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} owner Owner of the namespace
     * @param {string} member_user User
     * @param {V1OrganizationMember} body Organization body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public organizationsV1PatchOrganizationMember(owner: string, member_user: string, body: V1OrganizationMember, options?: any) {
        return OrganizationsV1ApiFp(this.configuration).organizationsV1PatchOrganizationMember(owner, member_user, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} owner Owner of the namespace
     * @param {V1Organization} body Organization body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public organizationsV1UpdateOrganization(owner: string, body: V1Organization, options?: any) {
        return OrganizationsV1ApiFp(this.configuration).organizationsV1UpdateOrganization(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} owner Owner of the namespace
     * @param {string} member_user User
     * @param {V1OrganizationMember} body Organization body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public organizationsV1UpdateOrganizationMember(owner: string, member_user: string, body: V1OrganizationMember, options?: any) {
        return OrganizationsV1ApiFp(this.configuration).organizationsV1UpdateOrganizationMember(owner, member_user, body, options)(this.fetch, this.basePath);
    }

}

/**
 * ProjectDashboardsV1Api - fetch parameter creator
 * @export
 */
export const ProjectDashboardsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDashboardsV1CreateProjectDashboard(owner: string, project: string, body: V1Dashboard, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling projectDashboardsV1CreateProjectDashboard.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling projectDashboardsV1CreateProjectDashboard.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling projectDashboardsV1CreateProjectDashboard.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/dashboards`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Dashboard" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDashboardsV1DeleteProjectDashboard(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling projectDashboardsV1DeleteProjectDashboard.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling projectDashboardsV1DeleteProjectDashboard.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling projectDashboardsV1DeleteProjectDashboard.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/dashboards/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDashboardsV1GetProjectDashboard(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling projectDashboardsV1GetProjectDashboard.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling projectDashboardsV1GetProjectDashboard.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling projectDashboardsV1GetProjectDashboard.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/dashboards/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDashboardsV1ListProjectDashboardNames(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling projectDashboardsV1ListProjectDashboardNames.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling projectDashboardsV1ListProjectDashboardNames.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/dashboards/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List project dashboards
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDashboardsV1ListProjectDashboards(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling projectDashboardsV1ListProjectDashboards.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling projectDashboardsV1ListProjectDashboards.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/dashboards`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} dashboard_uuid UUID
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDashboardsV1PatchProjectDashboard(owner: string, project: string, dashboard_uuid: string, body: V1Dashboard, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling projectDashboardsV1PatchProjectDashboard.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling projectDashboardsV1PatchProjectDashboard.');
            }
            // verify required parameter 'dashboard_uuid' is not null or undefined
            if (dashboard_uuid === null || dashboard_uuid === undefined) {
                throw new RequiredError('dashboard_uuid','Required parameter dashboard_uuid was null or undefined when calling projectDashboardsV1PatchProjectDashboard.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling projectDashboardsV1PatchProjectDashboard.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/dashboards/{dashboard.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"dashboard.uuid"}}`, encodeURIComponent(String(dashboard_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Dashboard" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Promote project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} dashboard_uuid UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDashboardsV1PromoteProjectDashboard(owner: string, project: string, dashboard_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling projectDashboardsV1PromoteProjectDashboard.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling projectDashboardsV1PromoteProjectDashboard.');
            }
            // verify required parameter 'dashboard_uuid' is not null or undefined
            if (dashboard_uuid === null || dashboard_uuid === undefined) {
                throw new RequiredError('dashboard_uuid','Required parameter dashboard_uuid was null or undefined when calling projectDashboardsV1PromoteProjectDashboard.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/dashboards/{dashboard.uuid}/promote`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"dashboard.uuid"}}`, encodeURIComponent(String(dashboard_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} dashboard_uuid UUID
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDashboardsV1UpdateProjectDashboard(owner: string, project: string, dashboard_uuid: string, body: V1Dashboard, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling projectDashboardsV1UpdateProjectDashboard.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling projectDashboardsV1UpdateProjectDashboard.');
            }
            // verify required parameter 'dashboard_uuid' is not null or undefined
            if (dashboard_uuid === null || dashboard_uuid === undefined) {
                throw new RequiredError('dashboard_uuid','Required parameter dashboard_uuid was null or undefined when calling projectDashboardsV1UpdateProjectDashboard.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling projectDashboardsV1UpdateProjectDashboard.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/dashboards/{dashboard.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"dashboard.uuid"}}`, encodeURIComponent(String(dashboard_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Dashboard" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectDashboardsV1Api - functional programming interface
 * @export
 */
export const ProjectDashboardsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDashboardsV1CreateProjectDashboard(owner: string, project: string, body: V1Dashboard, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Dashboard> {
            const localVarFetchArgs = ProjectDashboardsV1ApiFetchParamCreator(configuration).projectDashboardsV1CreateProjectDashboard(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDashboardsV1DeleteProjectDashboard(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectDashboardsV1ApiFetchParamCreator(configuration).projectDashboardsV1DeleteProjectDashboard(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDashboardsV1GetProjectDashboard(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Dashboard> {
            const localVarFetchArgs = ProjectDashboardsV1ApiFetchParamCreator(configuration).projectDashboardsV1GetProjectDashboard(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDashboardsV1ListProjectDashboardNames(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListDashboardsResponse> {
            const localVarFetchArgs = ProjectDashboardsV1ApiFetchParamCreator(configuration).projectDashboardsV1ListProjectDashboardNames(owner, project, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List project dashboards
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDashboardsV1ListProjectDashboards(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListDashboardsResponse> {
            const localVarFetchArgs = ProjectDashboardsV1ApiFetchParamCreator(configuration).projectDashboardsV1ListProjectDashboards(owner, project, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} dashboard_uuid UUID
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDashboardsV1PatchProjectDashboard(owner: string, project: string, dashboard_uuid: string, body: V1Dashboard, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Dashboard> {
            const localVarFetchArgs = ProjectDashboardsV1ApiFetchParamCreator(configuration).projectDashboardsV1PatchProjectDashboard(owner, project, dashboard_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Promote project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} dashboard_uuid UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDashboardsV1PromoteProjectDashboard(owner: string, project: string, dashboard_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Dashboard> {
            const localVarFetchArgs = ProjectDashboardsV1ApiFetchParamCreator(configuration).projectDashboardsV1PromoteProjectDashboard(owner, project, dashboard_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} dashboard_uuid UUID
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDashboardsV1UpdateProjectDashboard(owner: string, project: string, dashboard_uuid: string, body: V1Dashboard, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Dashboard> {
            const localVarFetchArgs = ProjectDashboardsV1ApiFetchParamCreator(configuration).projectDashboardsV1UpdateProjectDashboard(owner, project, dashboard_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProjectDashboardsV1Api - factory interface
 * @export
 */
export const ProjectDashboardsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDashboardsV1CreateProjectDashboard(owner: string, project: string, body: V1Dashboard, options?: any) {
            return ProjectDashboardsV1ApiFp(configuration).projectDashboardsV1CreateProjectDashboard(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDashboardsV1DeleteProjectDashboard(owner: string, project: string, uuid: string, options?: any) {
            return ProjectDashboardsV1ApiFp(configuration).projectDashboardsV1DeleteProjectDashboard(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDashboardsV1GetProjectDashboard(owner: string, project: string, uuid: string, options?: any) {
            return ProjectDashboardsV1ApiFp(configuration).projectDashboardsV1GetProjectDashboard(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDashboardsV1ListProjectDashboardNames(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ProjectDashboardsV1ApiFp(configuration).projectDashboardsV1ListProjectDashboardNames(owner, project, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List project dashboards
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDashboardsV1ListProjectDashboards(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ProjectDashboardsV1ApiFp(configuration).projectDashboardsV1ListProjectDashboards(owner, project, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} dashboard_uuid UUID
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDashboardsV1PatchProjectDashboard(owner: string, project: string, dashboard_uuid: string, body: V1Dashboard, options?: any) {
            return ProjectDashboardsV1ApiFp(configuration).projectDashboardsV1PatchProjectDashboard(owner, project, dashboard_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Promote project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} dashboard_uuid UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDashboardsV1PromoteProjectDashboard(owner: string, project: string, dashboard_uuid: string, options?: any) {
            return ProjectDashboardsV1ApiFp(configuration).projectDashboardsV1PromoteProjectDashboard(owner, project, dashboard_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} dashboard_uuid UUID
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDashboardsV1UpdateProjectDashboard(owner: string, project: string, dashboard_uuid: string, body: V1Dashboard, options?: any) {
            return ProjectDashboardsV1ApiFp(configuration).projectDashboardsV1UpdateProjectDashboard(owner, project, dashboard_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * ProjectDashboardsV1Api - object-oriented interface
 * @export
 * @class ProjectDashboardsV1Api
 * @extends {BaseAPI}
 */
export class ProjectDashboardsV1Api extends BaseAPI {
    /**
     * 
     * @summary Create project dashboard
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {V1Dashboard} body Dashboard body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDashboardsV1Api
     */
    public projectDashboardsV1CreateProjectDashboard(owner: string, project: string, body: V1Dashboard, options?: any) {
        return ProjectDashboardsV1ApiFp(this.configuration).projectDashboardsV1CreateProjectDashboard(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete project dashboard
     * @param {string} owner Owner of the namespace
     * @param {string} project Project
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDashboardsV1Api
     */
    public projectDashboardsV1DeleteProjectDashboard(owner: string, project: string, uuid: string, options?: any) {
        return ProjectDashboardsV1ApiFp(this.configuration).projectDashboardsV1DeleteProjectDashboard(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get project dashboard
     * @param {string} owner Owner of the namespace
     * @param {string} project Project
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDashboardsV1Api
     */
    public projectDashboardsV1GetProjectDashboard(owner: string, project: string, uuid: string, options?: any) {
        return ProjectDashboardsV1ApiFp(this.configuration).projectDashboardsV1GetProjectDashboard(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List project dashboard
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDashboardsV1Api
     */
    public projectDashboardsV1ListProjectDashboardNames(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ProjectDashboardsV1ApiFp(this.configuration).projectDashboardsV1ListProjectDashboardNames(owner, project, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List project dashboards
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDashboardsV1Api
     */
    public projectDashboardsV1ListProjectDashboards(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ProjectDashboardsV1ApiFp(this.configuration).projectDashboardsV1ListProjectDashboards(owner, project, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch project dashboard
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {string} dashboard_uuid UUID
     * @param {V1Dashboard} body Dashboard body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDashboardsV1Api
     */
    public projectDashboardsV1PatchProjectDashboard(owner: string, project: string, dashboard_uuid: string, body: V1Dashboard, options?: any) {
        return ProjectDashboardsV1ApiFp(this.configuration).projectDashboardsV1PatchProjectDashboard(owner, project, dashboard_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Promote project dashboard
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {string} dashboard_uuid UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDashboardsV1Api
     */
    public projectDashboardsV1PromoteProjectDashboard(owner: string, project: string, dashboard_uuid: string, options?: any) {
        return ProjectDashboardsV1ApiFp(this.configuration).projectDashboardsV1PromoteProjectDashboard(owner, project, dashboard_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update project dashboard
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {string} dashboard_uuid UUID
     * @param {V1Dashboard} body Dashboard body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDashboardsV1Api
     */
    public projectDashboardsV1UpdateProjectDashboard(owner: string, project: string, dashboard_uuid: string, body: V1Dashboard, options?: any) {
        return ProjectDashboardsV1ApiFp(this.configuration).projectDashboardsV1UpdateProjectDashboard(owner, project, dashboard_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * ProjectSearchesV1Api - fetch parameter creator
 * @export
 */
export const ProjectSearchesV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create project search
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSearchesV1CreateProjectSearch(owner: string, project: string, body: V1Search, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling projectSearchesV1CreateProjectSearch.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling projectSearchesV1CreateProjectSearch.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling projectSearchesV1CreateProjectSearch.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/searches`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Search" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete project search
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSearchesV1DeleteProjectSearch(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling projectSearchesV1DeleteProjectSearch.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling projectSearchesV1DeleteProjectSearch.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling projectSearchesV1DeleteProjectSearch.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/searches/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get project search
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSearchesV1GetProjectSearch(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling projectSearchesV1GetProjectSearch.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling projectSearchesV1GetProjectSearch.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling projectSearchesV1GetProjectSearch.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/searches/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List project search names
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSearchesV1ListProjectSearchNames(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling projectSearchesV1ListProjectSearchNames.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling projectSearchesV1ListProjectSearchNames.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/searches/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List project searches
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSearchesV1ListProjectSearches(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling projectSearchesV1ListProjectSearches.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling projectSearchesV1ListProjectSearches.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/searches`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch project search
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} search_uuid UUID
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSearchesV1PatchProjectSearch(owner: string, project: string, search_uuid: string, body: V1Search, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling projectSearchesV1PatchProjectSearch.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling projectSearchesV1PatchProjectSearch.');
            }
            // verify required parameter 'search_uuid' is not null or undefined
            if (search_uuid === null || search_uuid === undefined) {
                throw new RequiredError('search_uuid','Required parameter search_uuid was null or undefined when calling projectSearchesV1PatchProjectSearch.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling projectSearchesV1PatchProjectSearch.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/searches/{search.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"search.uuid"}}`, encodeURIComponent(String(search_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Search" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Promote project search
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSearchesV1PromoteProjectSearch(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling projectSearchesV1PromoteProjectSearch.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling projectSearchesV1PromoteProjectSearch.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling projectSearchesV1PromoteProjectSearch.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/searches/{uuid}/promote`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update project search
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} search_uuid UUID
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSearchesV1UpdateProjectSearch(owner: string, project: string, search_uuid: string, body: V1Search, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling projectSearchesV1UpdateProjectSearch.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling projectSearchesV1UpdateProjectSearch.');
            }
            // verify required parameter 'search_uuid' is not null or undefined
            if (search_uuid === null || search_uuid === undefined) {
                throw new RequiredError('search_uuid','Required parameter search_uuid was null or undefined when calling projectSearchesV1UpdateProjectSearch.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling projectSearchesV1UpdateProjectSearch.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/searches/{search.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"search.uuid"}}`, encodeURIComponent(String(search_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Search" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectSearchesV1Api - functional programming interface
 * @export
 */
export const ProjectSearchesV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create project search
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSearchesV1CreateProjectSearch(owner: string, project: string, body: V1Search, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Search> {
            const localVarFetchArgs = ProjectSearchesV1ApiFetchParamCreator(configuration).projectSearchesV1CreateProjectSearch(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete project search
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSearchesV1DeleteProjectSearch(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectSearchesV1ApiFetchParamCreator(configuration).projectSearchesV1DeleteProjectSearch(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get project search
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSearchesV1GetProjectSearch(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Search> {
            const localVarFetchArgs = ProjectSearchesV1ApiFetchParamCreator(configuration).projectSearchesV1GetProjectSearch(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List project search names
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSearchesV1ListProjectSearchNames(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListSearchesResponse> {
            const localVarFetchArgs = ProjectSearchesV1ApiFetchParamCreator(configuration).projectSearchesV1ListProjectSearchNames(owner, project, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List project searches
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSearchesV1ListProjectSearches(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListSearchesResponse> {
            const localVarFetchArgs = ProjectSearchesV1ApiFetchParamCreator(configuration).projectSearchesV1ListProjectSearches(owner, project, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch project search
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} search_uuid UUID
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSearchesV1PatchProjectSearch(owner: string, project: string, search_uuid: string, body: V1Search, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Search> {
            const localVarFetchArgs = ProjectSearchesV1ApiFetchParamCreator(configuration).projectSearchesV1PatchProjectSearch(owner, project, search_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Promote project search
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSearchesV1PromoteProjectSearch(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectSearchesV1ApiFetchParamCreator(configuration).projectSearchesV1PromoteProjectSearch(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update project search
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} search_uuid UUID
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSearchesV1UpdateProjectSearch(owner: string, project: string, search_uuid: string, body: V1Search, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Search> {
            const localVarFetchArgs = ProjectSearchesV1ApiFetchParamCreator(configuration).projectSearchesV1UpdateProjectSearch(owner, project, search_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProjectSearchesV1Api - factory interface
 * @export
 */
export const ProjectSearchesV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create project search
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSearchesV1CreateProjectSearch(owner: string, project: string, body: V1Search, options?: any) {
            return ProjectSearchesV1ApiFp(configuration).projectSearchesV1CreateProjectSearch(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete project search
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSearchesV1DeleteProjectSearch(owner: string, project: string, uuid: string, options?: any) {
            return ProjectSearchesV1ApiFp(configuration).projectSearchesV1DeleteProjectSearch(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get project search
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSearchesV1GetProjectSearch(owner: string, project: string, uuid: string, options?: any) {
            return ProjectSearchesV1ApiFp(configuration).projectSearchesV1GetProjectSearch(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List project search names
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSearchesV1ListProjectSearchNames(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ProjectSearchesV1ApiFp(configuration).projectSearchesV1ListProjectSearchNames(owner, project, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List project searches
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSearchesV1ListProjectSearches(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ProjectSearchesV1ApiFp(configuration).projectSearchesV1ListProjectSearches(owner, project, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch project search
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} search_uuid UUID
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSearchesV1PatchProjectSearch(owner: string, project: string, search_uuid: string, body: V1Search, options?: any) {
            return ProjectSearchesV1ApiFp(configuration).projectSearchesV1PatchProjectSearch(owner, project, search_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Promote project search
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSearchesV1PromoteProjectSearch(owner: string, project: string, uuid: string, options?: any) {
            return ProjectSearchesV1ApiFp(configuration).projectSearchesV1PromoteProjectSearch(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update project search
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} search_uuid UUID
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectSearchesV1UpdateProjectSearch(owner: string, project: string, search_uuid: string, body: V1Search, options?: any) {
            return ProjectSearchesV1ApiFp(configuration).projectSearchesV1UpdateProjectSearch(owner, project, search_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * ProjectSearchesV1Api - object-oriented interface
 * @export
 * @class ProjectSearchesV1Api
 * @extends {BaseAPI}
 */
export class ProjectSearchesV1Api extends BaseAPI {
    /**
     * 
     * @summary Create project search
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {V1Search} body Search body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSearchesV1Api
     */
    public projectSearchesV1CreateProjectSearch(owner: string, project: string, body: V1Search, options?: any) {
        return ProjectSearchesV1ApiFp(this.configuration).projectSearchesV1CreateProjectSearch(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete project search
     * @param {string} owner Owner of the namespace
     * @param {string} project Project
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSearchesV1Api
     */
    public projectSearchesV1DeleteProjectSearch(owner: string, project: string, uuid: string, options?: any) {
        return ProjectSearchesV1ApiFp(this.configuration).projectSearchesV1DeleteProjectSearch(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get project search
     * @param {string} owner Owner of the namespace
     * @param {string} project Project
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSearchesV1Api
     */
    public projectSearchesV1GetProjectSearch(owner: string, project: string, uuid: string, options?: any) {
        return ProjectSearchesV1ApiFp(this.configuration).projectSearchesV1GetProjectSearch(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List project search names
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSearchesV1Api
     */
    public projectSearchesV1ListProjectSearchNames(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ProjectSearchesV1ApiFp(this.configuration).projectSearchesV1ListProjectSearchNames(owner, project, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List project searches
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSearchesV1Api
     */
    public projectSearchesV1ListProjectSearches(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ProjectSearchesV1ApiFp(this.configuration).projectSearchesV1ListProjectSearches(owner, project, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch project search
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {string} search_uuid UUID
     * @param {V1Search} body Search body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSearchesV1Api
     */
    public projectSearchesV1PatchProjectSearch(owner: string, project: string, search_uuid: string, body: V1Search, options?: any) {
        return ProjectSearchesV1ApiFp(this.configuration).projectSearchesV1PatchProjectSearch(owner, project, search_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Promote project search
     * @param {string} owner Owner of the namespace
     * @param {string} project Project
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSearchesV1Api
     */
    public projectSearchesV1PromoteProjectSearch(owner: string, project: string, uuid: string, options?: any) {
        return ProjectSearchesV1ApiFp(this.configuration).projectSearchesV1PromoteProjectSearch(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update project search
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {string} search_uuid UUID
     * @param {V1Search} body Search body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSearchesV1Api
     */
    public projectSearchesV1UpdateProjectSearch(owner: string, project: string, search_uuid: string, body: V1Search, options?: any) {
        return ProjectSearchesV1ApiFp(this.configuration).projectSearchesV1UpdateProjectSearch(owner, project, search_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * ProjectsV1Api - fetch parameter creator
 * @export
 */
export const ProjectsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Archive project
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1ArchiveProject(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling projectsV1ArchiveProject.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling projectsV1ArchiveProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/archive`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Bookmark project
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1BookmarkProject(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling projectsV1BookmarkProject.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling projectsV1BookmarkProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/bookmark`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new project
         * @param {string} owner Owner of the namespace
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1CreateProject(owner: string, body: V1Project, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling projectsV1CreateProject.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling projectsV1CreateProject.');
            }
            const localVarPath = `/api/v1/{owner}/projects/create`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Project" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete project
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1DeleteProject(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling projectsV1DeleteProject.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling projectsV1DeleteProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Disbale project CI
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1DisableProjectCI(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling projectsV1DisableProjectCI.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling projectsV1DisableProjectCI.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/ci`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Enable project CI
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1EnableProjectCI(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling projectsV1EnableProjectCI.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling projectsV1EnableProjectCI.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/ci`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get project teams
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1FetchProjectTeams(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling projectsV1FetchProjectTeams.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling projectsV1FetchProjectTeams.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/teams`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get project
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1GetProject(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling projectsV1GetProject.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling projectsV1GetProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Project settings
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1GetProjectSettings(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling projectsV1GetProjectSettings.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling projectsV1GetProjectSettings.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/settings`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List archived projects for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1ListArchivedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling projectsV1ListArchivedProjects.');
            }
            const localVarPath = `/api/v1/archives/{user}/projects`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked projects for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1ListBookmarkedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling projectsV1ListBookmarkedProjects.');
            }
            const localVarPath = `/api/v1/bookmarks/{user}/projects`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List project names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1ListProjectNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling projectsV1ListProjectNames.');
            }
            const localVarPath = `/api/v1/{owner}/projects/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List projects
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1ListProjects(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling projectsV1ListProjects.');
            }
            const localVarPath = `/api/v1/{owner}/projects/list`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch project
         * @param {string} owner Owner of the namespace
         * @param {string} project_name Required name
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1PatchProject(owner: string, project_name: string, body: V1Project, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling projectsV1PatchProject.');
            }
            // verify required parameter 'project_name' is not null or undefined
            if (project_name === null || project_name === undefined) {
                throw new RequiredError('project_name','Required parameter project_name was null or undefined when calling projectsV1PatchProject.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling projectsV1PatchProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project.name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project.name"}}`, encodeURIComponent(String(project_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Project" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch project settings
         * @param {string} owner Owner of the namespace
         * @param {string} project Project name
         * @param {V1ProjectSettings} body Project settings body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1PatchProjectSettings(owner: string, project: string, body: V1ProjectSettings, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling projectsV1PatchProjectSettings.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling projectsV1PatchProjectSettings.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling projectsV1PatchProjectSettings.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/settings`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ProjectSettings" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch project teams
         * @param {string} owner Owner of the namespace
         * @param {string} project Project name
         * @param {V1ProjectTeams} body Project settings body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1PatchProjectTeams(owner: string, project: string, body: V1ProjectTeams, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling projectsV1PatchProjectTeams.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling projectsV1PatchProjectTeams.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling projectsV1PatchProjectTeams.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/teams`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ProjectTeams" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore project
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1RestoreProject(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling projectsV1RestoreProject.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling projectsV1RestoreProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/restore`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unbookmark project
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1UnbookmarkProject(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling projectsV1UnbookmarkProject.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling projectsV1UnbookmarkProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/unbookmark`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update project
         * @param {string} owner Owner of the namespace
         * @param {string} project_name Required name
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1UpdateProject(owner: string, project_name: string, body: V1Project, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling projectsV1UpdateProject.');
            }
            // verify required parameter 'project_name' is not null or undefined
            if (project_name === null || project_name === undefined) {
                throw new RequiredError('project_name','Required parameter project_name was null or undefined when calling projectsV1UpdateProject.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling projectsV1UpdateProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project.name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project.name"}}`, encodeURIComponent(String(project_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Project" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update project settings
         * @param {string} owner Owner of the namespace
         * @param {string} project Project name
         * @param {V1ProjectSettings} body Project settings body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1UpdateProjectSettings(owner: string, project: string, body: V1ProjectSettings, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling projectsV1UpdateProjectSettings.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling projectsV1UpdateProjectSettings.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling projectsV1UpdateProjectSettings.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/settings`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ProjectSettings" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update project teams
         * @param {string} owner Owner of the namespace
         * @param {string} project Project name
         * @param {V1ProjectTeams} body Project settings body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1UpdateProjectTeams(owner: string, project: string, body: V1ProjectTeams, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling projectsV1UpdateProjectTeams.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling projectsV1UpdateProjectTeams.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling projectsV1UpdateProjectTeams.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/teams`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ProjectTeams" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload artifact to a store via project access
         * @param {string} owner Owner of the namespace
         * @param {string} project Project having access to the store
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProjectArtifact(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling uploadProjectArtifact.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling uploadProjectArtifact.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling uploadProjectArtifact.');
            }
            // verify required parameter 'uploadfile' is not null or undefined
            if (uploadfile === null || uploadfile === undefined) {
                throw new RequiredError('uploadfile','Required parameter uploadfile was null or undefined when calling uploadProjectArtifact.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/artifacts/{uuid}/upload`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (overwrite !== undefined) {
                localVarQueryParameter['overwrite'] = overwrite;
            }

            if (uploadfile !== undefined) {
                localVarFormParams.set('uploadfile', uploadfile as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsV1Api - functional programming interface
 * @export
 */
export const ProjectsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Archive project
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1ArchiveProject(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).projectsV1ArchiveProject(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Bookmark project
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1BookmarkProject(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).projectsV1BookmarkProject(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new project
         * @param {string} owner Owner of the namespace
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1CreateProject(owner: string, body: V1Project, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Project> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).projectsV1CreateProject(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete project
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1DeleteProject(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).projectsV1DeleteProject(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Disbale project CI
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1DisableProjectCI(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).projectsV1DisableProjectCI(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Enable project CI
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1EnableProjectCI(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).projectsV1EnableProjectCI(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get project teams
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1FetchProjectTeams(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ProjectTeams> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).projectsV1FetchProjectTeams(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get project
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1GetProject(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Project> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).projectsV1GetProject(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get Project settings
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1GetProjectSettings(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ProjectSettings> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).projectsV1GetProjectSettings(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List archived projects for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1ListArchivedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListProjectsResponse> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).projectsV1ListArchivedProjects(user, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked projects for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1ListBookmarkedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListProjectsResponse> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).projectsV1ListBookmarkedProjects(user, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List project names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1ListProjectNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListProjectsResponse> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).projectsV1ListProjectNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List projects
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1ListProjects(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListProjectsResponse> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).projectsV1ListProjects(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch project
         * @param {string} owner Owner of the namespace
         * @param {string} project_name Required name
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1PatchProject(owner: string, project_name: string, body: V1Project, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Project> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).projectsV1PatchProject(owner, project_name, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch project settings
         * @param {string} owner Owner of the namespace
         * @param {string} project Project name
         * @param {V1ProjectSettings} body Project settings body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1PatchProjectSettings(owner: string, project: string, body: V1ProjectSettings, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ProjectSettings> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).projectsV1PatchProjectSettings(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch project teams
         * @param {string} owner Owner of the namespace
         * @param {string} project Project name
         * @param {V1ProjectTeams} body Project settings body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1PatchProjectTeams(owner: string, project: string, body: V1ProjectTeams, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ProjectTeams> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).projectsV1PatchProjectTeams(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Restore project
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1RestoreProject(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).projectsV1RestoreProject(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Unbookmark project
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1UnbookmarkProject(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).projectsV1UnbookmarkProject(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update project
         * @param {string} owner Owner of the namespace
         * @param {string} project_name Required name
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1UpdateProject(owner: string, project_name: string, body: V1Project, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Project> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).projectsV1UpdateProject(owner, project_name, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update project settings
         * @param {string} owner Owner of the namespace
         * @param {string} project Project name
         * @param {V1ProjectSettings} body Project settings body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1UpdateProjectSettings(owner: string, project: string, body: V1ProjectSettings, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ProjectSettings> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).projectsV1UpdateProjectSettings(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update project teams
         * @param {string} owner Owner of the namespace
         * @param {string} project Project name
         * @param {V1ProjectTeams} body Project settings body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1UpdateProjectTeams(owner: string, project: string, body: V1ProjectTeams, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ProjectTeams> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).projectsV1UpdateProjectTeams(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Upload artifact to a store via project access
         * @param {string} owner Owner of the namespace
         * @param {string} project Project having access to the store
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProjectArtifact(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).uploadProjectArtifact(owner, project, uuid, uploadfile, path, overwrite, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProjectsV1Api - factory interface
 * @export
 */
export const ProjectsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Archive project
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1ArchiveProject(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).projectsV1ArchiveProject(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Bookmark project
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1BookmarkProject(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).projectsV1BookmarkProject(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new project
         * @param {string} owner Owner of the namespace
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1CreateProject(owner: string, body: V1Project, options?: any) {
            return ProjectsV1ApiFp(configuration).projectsV1CreateProject(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete project
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1DeleteProject(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).projectsV1DeleteProject(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Disbale project CI
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1DisableProjectCI(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).projectsV1DisableProjectCI(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Enable project CI
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1EnableProjectCI(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).projectsV1EnableProjectCI(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get project teams
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1FetchProjectTeams(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).projectsV1FetchProjectTeams(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get project
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1GetProject(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).projectsV1GetProject(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get Project settings
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1GetProjectSettings(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).projectsV1GetProjectSettings(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List archived projects for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1ListArchivedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ProjectsV1ApiFp(configuration).projectsV1ListArchivedProjects(user, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked projects for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1ListBookmarkedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ProjectsV1ApiFp(configuration).projectsV1ListBookmarkedProjects(user, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List project names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1ListProjectNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ProjectsV1ApiFp(configuration).projectsV1ListProjectNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List projects
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1ListProjects(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ProjectsV1ApiFp(configuration).projectsV1ListProjects(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch project
         * @param {string} owner Owner of the namespace
         * @param {string} project_name Required name
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1PatchProject(owner: string, project_name: string, body: V1Project, options?: any) {
            return ProjectsV1ApiFp(configuration).projectsV1PatchProject(owner, project_name, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch project settings
         * @param {string} owner Owner of the namespace
         * @param {string} project Project name
         * @param {V1ProjectSettings} body Project settings body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1PatchProjectSettings(owner: string, project: string, body: V1ProjectSettings, options?: any) {
            return ProjectsV1ApiFp(configuration).projectsV1PatchProjectSettings(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch project teams
         * @param {string} owner Owner of the namespace
         * @param {string} project Project name
         * @param {V1ProjectTeams} body Project settings body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1PatchProjectTeams(owner: string, project: string, body: V1ProjectTeams, options?: any) {
            return ProjectsV1ApiFp(configuration).projectsV1PatchProjectTeams(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Restore project
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1RestoreProject(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).projectsV1RestoreProject(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Unbookmark project
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1UnbookmarkProject(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).projectsV1UnbookmarkProject(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update project
         * @param {string} owner Owner of the namespace
         * @param {string} project_name Required name
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1UpdateProject(owner: string, project_name: string, body: V1Project, options?: any) {
            return ProjectsV1ApiFp(configuration).projectsV1UpdateProject(owner, project_name, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update project settings
         * @param {string} owner Owner of the namespace
         * @param {string} project Project name
         * @param {V1ProjectSettings} body Project settings body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1UpdateProjectSettings(owner: string, project: string, body: V1ProjectSettings, options?: any) {
            return ProjectsV1ApiFp(configuration).projectsV1UpdateProjectSettings(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update project teams
         * @param {string} owner Owner of the namespace
         * @param {string} project Project name
         * @param {V1ProjectTeams} body Project settings body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsV1UpdateProjectTeams(owner: string, project: string, body: V1ProjectTeams, options?: any) {
            return ProjectsV1ApiFp(configuration).projectsV1UpdateProjectTeams(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Upload artifact to a store via project access
         * @param {string} owner Owner of the namespace
         * @param {string} project Project having access to the store
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProjectArtifact(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any) {
            return ProjectsV1ApiFp(configuration).uploadProjectArtifact(owner, project, uuid, uploadfile, path, overwrite, options)(fetch, basePath);
        },
    };
};

/**
 * ProjectsV1Api - object-oriented interface
 * @export
 * @class ProjectsV1Api
 * @extends {BaseAPI}
 */
export class ProjectsV1Api extends BaseAPI {
    /**
     * 
     * @summary Archive project
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public projectsV1ArchiveProject(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).projectsV1ArchiveProject(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Bookmark project
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public projectsV1BookmarkProject(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).projectsV1BookmarkProject(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new project
     * @param {string} owner Owner of the namespace
     * @param {V1Project} body Project body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public projectsV1CreateProject(owner: string, body: V1Project, options?: any) {
        return ProjectsV1ApiFp(this.configuration).projectsV1CreateProject(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete project
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public projectsV1DeleteProject(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).projectsV1DeleteProject(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Disbale project CI
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public projectsV1DisableProjectCI(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).projectsV1DisableProjectCI(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Enable project CI
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public projectsV1EnableProjectCI(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).projectsV1EnableProjectCI(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get project teams
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public projectsV1FetchProjectTeams(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).projectsV1FetchProjectTeams(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get project
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public projectsV1GetProject(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).projectsV1GetProject(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get Project settings
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public projectsV1GetProjectSettings(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).projectsV1GetProjectSettings(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List archived projects for user
     * @param {string} user User
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public projectsV1ListArchivedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).projectsV1ListArchivedProjects(user, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked projects for user
     * @param {string} user User
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public projectsV1ListBookmarkedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).projectsV1ListBookmarkedProjects(user, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List project names
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public projectsV1ListProjectNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).projectsV1ListProjectNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List projects
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public projectsV1ListProjects(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).projectsV1ListProjects(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch project
     * @param {string} owner Owner of the namespace
     * @param {string} project_name Required name
     * @param {V1Project} body Project body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public projectsV1PatchProject(owner: string, project_name: string, body: V1Project, options?: any) {
        return ProjectsV1ApiFp(this.configuration).projectsV1PatchProject(owner, project_name, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch project settings
     * @param {string} owner Owner of the namespace
     * @param {string} project Project name
     * @param {V1ProjectSettings} body Project settings body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public projectsV1PatchProjectSettings(owner: string, project: string, body: V1ProjectSettings, options?: any) {
        return ProjectsV1ApiFp(this.configuration).projectsV1PatchProjectSettings(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch project teams
     * @param {string} owner Owner of the namespace
     * @param {string} project Project name
     * @param {V1ProjectTeams} body Project settings body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public projectsV1PatchProjectTeams(owner: string, project: string, body: V1ProjectTeams, options?: any) {
        return ProjectsV1ApiFp(this.configuration).projectsV1PatchProjectTeams(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Restore project
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public projectsV1RestoreProject(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).projectsV1RestoreProject(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Unbookmark project
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public projectsV1UnbookmarkProject(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).projectsV1UnbookmarkProject(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update project
     * @param {string} owner Owner of the namespace
     * @param {string} project_name Required name
     * @param {V1Project} body Project body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public projectsV1UpdateProject(owner: string, project_name: string, body: V1Project, options?: any) {
        return ProjectsV1ApiFp(this.configuration).projectsV1UpdateProject(owner, project_name, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update project settings
     * @param {string} owner Owner of the namespace
     * @param {string} project Project name
     * @param {V1ProjectSettings} body Project settings body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public projectsV1UpdateProjectSettings(owner: string, project: string, body: V1ProjectSettings, options?: any) {
        return ProjectsV1ApiFp(this.configuration).projectsV1UpdateProjectSettings(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update project teams
     * @param {string} owner Owner of the namespace
     * @param {string} project Project name
     * @param {V1ProjectTeams} body Project settings body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public projectsV1UpdateProjectTeams(owner: string, project: string, body: V1ProjectTeams, options?: any) {
        return ProjectsV1ApiFp(this.configuration).projectsV1UpdateProjectTeams(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Upload artifact to a store via project access
     * @param {string} owner Owner of the namespace
     * @param {string} project Project having access to the store
     * @param {string} uuid Unique integer identifier of the entity
     * @param {any} uploadfile The file to upload.
     * @param {string} [path] File path query params.
     * @param {boolean} [overwrite] File path query params.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public uploadProjectArtifact(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any) {
        return ProjectsV1ApiFp(this.configuration).uploadProjectArtifact(owner, project, uuid, uploadfile, path, overwrite, options)(this.fetch, this.basePath);
    }

}

/**
 * QueuesV1Api - fetch parameter creator
 * @export
 */
export const QueuesV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Update agent
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent that consumes the queue
         * @param {V1Queue} body Queue body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesV1CreateQueue(owner: string, agent: string, body: V1Queue, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling queuesV1CreateQueue.');
            }
            // verify required parameter 'agent' is not null or undefined
            if (agent === null || agent === undefined) {
                throw new RequiredError('agent','Required parameter agent was null or undefined when calling queuesV1CreateQueue.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling queuesV1CreateQueue.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{agent}/queues`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"agent"}}`, encodeURIComponent(String(agent)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Queue" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sync agent
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent managing the resource
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesV1DeleteQueue(owner: string, agent: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling queuesV1DeleteQueue.');
            }
            // verify required parameter 'agent' is not null or undefined
            if (agent === null || agent === undefined) {
                throw new RequiredError('agent','Required parameter agent was null or undefined when calling queuesV1DeleteQueue.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling queuesV1DeleteQueue.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{agent}/queues/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"agent"}}`, encodeURIComponent(String(agent)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch agent
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent managing the resource
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesV1GetQueue(owner: string, agent: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling queuesV1GetQueue.');
            }
            // verify required parameter 'agent' is not null or undefined
            if (agent === null || agent === undefined) {
                throw new RequiredError('agent','Required parameter agent was null or undefined when calling queuesV1GetQueue.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling queuesV1GetQueue.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{agent}/queues/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"agent"}}`, encodeURIComponent(String(agent)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List agents names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesV1ListOrganizationQueueNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling queuesV1ListOrganizationQueueNames.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/queues/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List agents
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesV1ListOrganizationQueues(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling queuesV1ListOrganizationQueues.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/queues`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create agent
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent man managing the resource
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesV1ListQueueNames(owner: string, agent: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling queuesV1ListQueueNames.');
            }
            // verify required parameter 'agent' is not null or undefined
            if (agent === null || agent === undefined) {
                throw new RequiredError('agent','Required parameter agent was null or undefined when calling queuesV1ListQueueNames.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{agent}/queues/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"agent"}}`, encodeURIComponent(String(agent)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get agent
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent man managing the resource
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesV1ListQueues(owner: string, agent: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling queuesV1ListQueues.');
            }
            // verify required parameter 'agent' is not null or undefined
            if (agent === null || agent === undefined) {
                throw new RequiredError('agent','Required parameter agent was null or undefined when calling queuesV1ListQueues.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{agent}/queues`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"agent"}}`, encodeURIComponent(String(agent)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get State (queues/runs)
         * @param {string} owner Owner of the namespace
         * @param {string} queue_agent Agent
         * @param {string} queue_uuid UUID
         * @param {V1Queue} body Queue body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesV1PatchQueue(owner: string, queue_agent: string, queue_uuid: string, body: V1Queue, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling queuesV1PatchQueue.');
            }
            // verify required parameter 'queue_agent' is not null or undefined
            if (queue_agent === null || queue_agent === undefined) {
                throw new RequiredError('queue_agent','Required parameter queue_agent was null or undefined when calling queuesV1PatchQueue.');
            }
            // verify required parameter 'queue_uuid' is not null or undefined
            if (queue_uuid === null || queue_uuid === undefined) {
                throw new RequiredError('queue_uuid','Required parameter queue_uuid was null or undefined when calling queuesV1PatchQueue.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling queuesV1PatchQueue.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{queue.agent}/queues/{queue.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"queue.agent"}}`, encodeURIComponent(String(queue_agent)))
                .replace(`{${"queue.uuid"}}`, encodeURIComponent(String(queue_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Queue" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete agent
         * @param {string} owner Owner of the namespace
         * @param {string} queue_agent Agent
         * @param {string} queue_uuid UUID
         * @param {V1Queue} body Queue body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesV1UpdateQueue(owner: string, queue_agent: string, queue_uuid: string, body: V1Queue, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling queuesV1UpdateQueue.');
            }
            // verify required parameter 'queue_agent' is not null or undefined
            if (queue_agent === null || queue_agent === undefined) {
                throw new RequiredError('queue_agent','Required parameter queue_agent was null or undefined when calling queuesV1UpdateQueue.');
            }
            // verify required parameter 'queue_uuid' is not null or undefined
            if (queue_uuid === null || queue_uuid === undefined) {
                throw new RequiredError('queue_uuid','Required parameter queue_uuid was null or undefined when calling queuesV1UpdateQueue.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling queuesV1UpdateQueue.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{queue.agent}/queues/{queue.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"queue.agent"}}`, encodeURIComponent(String(queue_agent)))
                .replace(`{${"queue.uuid"}}`, encodeURIComponent(String(queue_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Queue" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueuesV1Api - functional programming interface
 * @export
 */
export const QueuesV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Update agent
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent that consumes the queue
         * @param {V1Queue} body Queue body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesV1CreateQueue(owner: string, agent: string, body: V1Queue, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Agent> {
            const localVarFetchArgs = QueuesV1ApiFetchParamCreator(configuration).queuesV1CreateQueue(owner, agent, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Sync agent
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent managing the resource
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesV1DeleteQueue(owner: string, agent: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = QueuesV1ApiFetchParamCreator(configuration).queuesV1DeleteQueue(owner, agent, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch agent
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent managing the resource
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesV1GetQueue(owner: string, agent: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Queue> {
            const localVarFetchArgs = QueuesV1ApiFetchParamCreator(configuration).queuesV1GetQueue(owner, agent, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List agents names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesV1ListOrganizationQueueNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListQueuesResponse> {
            const localVarFetchArgs = QueuesV1ApiFetchParamCreator(configuration).queuesV1ListOrganizationQueueNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List agents
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesV1ListOrganizationQueues(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListQueuesResponse> {
            const localVarFetchArgs = QueuesV1ApiFetchParamCreator(configuration).queuesV1ListOrganizationQueues(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create agent
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent man managing the resource
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesV1ListQueueNames(owner: string, agent: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListQueuesResponse> {
            const localVarFetchArgs = QueuesV1ApiFetchParamCreator(configuration).queuesV1ListQueueNames(owner, agent, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get agent
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent man managing the resource
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesV1ListQueues(owner: string, agent: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListQueuesResponse> {
            const localVarFetchArgs = QueuesV1ApiFetchParamCreator(configuration).queuesV1ListQueues(owner, agent, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get State (queues/runs)
         * @param {string} owner Owner of the namespace
         * @param {string} queue_agent Agent
         * @param {string} queue_uuid UUID
         * @param {V1Queue} body Queue body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesV1PatchQueue(owner: string, queue_agent: string, queue_uuid: string, body: V1Queue, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Queue> {
            const localVarFetchArgs = QueuesV1ApiFetchParamCreator(configuration).queuesV1PatchQueue(owner, queue_agent, queue_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete agent
         * @param {string} owner Owner of the namespace
         * @param {string} queue_agent Agent
         * @param {string} queue_uuid UUID
         * @param {V1Queue} body Queue body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesV1UpdateQueue(owner: string, queue_agent: string, queue_uuid: string, body: V1Queue, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Queue> {
            const localVarFetchArgs = QueuesV1ApiFetchParamCreator(configuration).queuesV1UpdateQueue(owner, queue_agent, queue_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QueuesV1Api - factory interface
 * @export
 */
export const QueuesV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Update agent
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent that consumes the queue
         * @param {V1Queue} body Queue body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesV1CreateQueue(owner: string, agent: string, body: V1Queue, options?: any) {
            return QueuesV1ApiFp(configuration).queuesV1CreateQueue(owner, agent, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Sync agent
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent managing the resource
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesV1DeleteQueue(owner: string, agent: string, uuid: string, options?: any) {
            return QueuesV1ApiFp(configuration).queuesV1DeleteQueue(owner, agent, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch agent
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent managing the resource
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesV1GetQueue(owner: string, agent: string, uuid: string, options?: any) {
            return QueuesV1ApiFp(configuration).queuesV1GetQueue(owner, agent, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List agents names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesV1ListOrganizationQueueNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return QueuesV1ApiFp(configuration).queuesV1ListOrganizationQueueNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List agents
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesV1ListOrganizationQueues(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return QueuesV1ApiFp(configuration).queuesV1ListOrganizationQueues(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create agent
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent man managing the resource
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesV1ListQueueNames(owner: string, agent: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return QueuesV1ApiFp(configuration).queuesV1ListQueueNames(owner, agent, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get agent
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent man managing the resource
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesV1ListQueues(owner: string, agent: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return QueuesV1ApiFp(configuration).queuesV1ListQueues(owner, agent, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get State (queues/runs)
         * @param {string} owner Owner of the namespace
         * @param {string} queue_agent Agent
         * @param {string} queue_uuid UUID
         * @param {V1Queue} body Queue body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesV1PatchQueue(owner: string, queue_agent: string, queue_uuid: string, body: V1Queue, options?: any) {
            return QueuesV1ApiFp(configuration).queuesV1PatchQueue(owner, queue_agent, queue_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete agent
         * @param {string} owner Owner of the namespace
         * @param {string} queue_agent Agent
         * @param {string} queue_uuid UUID
         * @param {V1Queue} body Queue body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queuesV1UpdateQueue(owner: string, queue_agent: string, queue_uuid: string, body: V1Queue, options?: any) {
            return QueuesV1ApiFp(configuration).queuesV1UpdateQueue(owner, queue_agent, queue_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * QueuesV1Api - object-oriented interface
 * @export
 * @class QueuesV1Api
 * @extends {BaseAPI}
 */
export class QueuesV1Api extends BaseAPI {
    /**
     * 
     * @summary Update agent
     * @param {string} owner Owner of the namespace
     * @param {string} agent Agent that consumes the queue
     * @param {V1Queue} body Queue body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesV1Api
     */
    public queuesV1CreateQueue(owner: string, agent: string, body: V1Queue, options?: any) {
        return QueuesV1ApiFp(this.configuration).queuesV1CreateQueue(owner, agent, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Sync agent
     * @param {string} owner Owner of the namespace
     * @param {string} agent Agent managing the resource
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesV1Api
     */
    public queuesV1DeleteQueue(owner: string, agent: string, uuid: string, options?: any) {
        return QueuesV1ApiFp(this.configuration).queuesV1DeleteQueue(owner, agent, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch agent
     * @param {string} owner Owner of the namespace
     * @param {string} agent Agent managing the resource
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesV1Api
     */
    public queuesV1GetQueue(owner: string, agent: string, uuid: string, options?: any) {
        return QueuesV1ApiFp(this.configuration).queuesV1GetQueue(owner, agent, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List agents names
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesV1Api
     */
    public queuesV1ListOrganizationQueueNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return QueuesV1ApiFp(this.configuration).queuesV1ListOrganizationQueueNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List agents
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesV1Api
     */
    public queuesV1ListOrganizationQueues(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return QueuesV1ApiFp(this.configuration).queuesV1ListOrganizationQueues(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create agent
     * @param {string} owner Owner of the namespace
     * @param {string} agent Agent man managing the resource
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesV1Api
     */
    public queuesV1ListQueueNames(owner: string, agent: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return QueuesV1ApiFp(this.configuration).queuesV1ListQueueNames(owner, agent, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get agent
     * @param {string} owner Owner of the namespace
     * @param {string} agent Agent man managing the resource
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesV1Api
     */
    public queuesV1ListQueues(owner: string, agent: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return QueuesV1ApiFp(this.configuration).queuesV1ListQueues(owner, agent, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get State (queues/runs)
     * @param {string} owner Owner of the namespace
     * @param {string} queue_agent Agent
     * @param {string} queue_uuid UUID
     * @param {V1Queue} body Queue body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesV1Api
     */
    public queuesV1PatchQueue(owner: string, queue_agent: string, queue_uuid: string, body: V1Queue, options?: any) {
        return QueuesV1ApiFp(this.configuration).queuesV1PatchQueue(owner, queue_agent, queue_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete agent
     * @param {string} owner Owner of the namespace
     * @param {string} queue_agent Agent
     * @param {string} queue_uuid UUID
     * @param {V1Queue} body Queue body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesV1Api
     */
    public queuesV1UpdateQueue(owner: string, queue_agent: string, queue_uuid: string, body: V1Queue, options?: any) {
        return QueuesV1ApiFp(this.configuration).queuesV1UpdateQueue(owner, queue_agent, queue_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * RunProfilesV1Api - fetch parameter creator
 * @export
 */
export const RunProfilesV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create hub component
         * @param {string} owner Owner of the namespace
         * @param {V1RunProfile} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runProfilesV1CreateRunProfile(owner: string, body: V1RunProfile, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runProfilesV1CreateRunProfile.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling runProfilesV1CreateRunProfile.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/run_profiles`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1RunProfile" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete hub component
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runProfilesV1DeleteRunProfile(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runProfilesV1DeleteRunProfile.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling runProfilesV1DeleteRunProfile.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/run_profiles/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get hub component
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runProfilesV1GetRunProfile(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runProfilesV1GetRunProfile.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling runProfilesV1GetRunProfile.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/run_profiles/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List hub component names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runProfilesV1ListRunProfileNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runProfilesV1ListRunProfileNames.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/run_profiles/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List hub components
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runProfilesV1ListRunProfiles(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runProfilesV1ListRunProfiles.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/run_profiles`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch hub component
         * @param {string} owner Owner of the namespace
         * @param {string} run_profile_uuid UUID
         * @param {V1RunProfile} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runProfilesV1PatchRunProfile(owner: string, run_profile_uuid: string, body: V1RunProfile, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runProfilesV1PatchRunProfile.');
            }
            // verify required parameter 'run_profile_uuid' is not null or undefined
            if (run_profile_uuid === null || run_profile_uuid === undefined) {
                throw new RequiredError('run_profile_uuid','Required parameter run_profile_uuid was null or undefined when calling runProfilesV1PatchRunProfile.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling runProfilesV1PatchRunProfile.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/run_profiles/{run_profile.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"run_profile.uuid"}}`, encodeURIComponent(String(run_profile_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1RunProfile" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update hub component
         * @param {string} owner Owner of the namespace
         * @param {string} run_profile_uuid UUID
         * @param {V1RunProfile} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runProfilesV1UpdateRunProfile(owner: string, run_profile_uuid: string, body: V1RunProfile, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runProfilesV1UpdateRunProfile.');
            }
            // verify required parameter 'run_profile_uuid' is not null or undefined
            if (run_profile_uuid === null || run_profile_uuid === undefined) {
                throw new RequiredError('run_profile_uuid','Required parameter run_profile_uuid was null or undefined when calling runProfilesV1UpdateRunProfile.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling runProfilesV1UpdateRunProfile.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/run_profiles/{run_profile.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"run_profile.uuid"}}`, encodeURIComponent(String(run_profile_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1RunProfile" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RunProfilesV1Api - functional programming interface
 * @export
 */
export const RunProfilesV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create hub component
         * @param {string} owner Owner of the namespace
         * @param {V1RunProfile} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runProfilesV1CreateRunProfile(owner: string, body: V1RunProfile, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1RunProfile> {
            const localVarFetchArgs = RunProfilesV1ApiFetchParamCreator(configuration).runProfilesV1CreateRunProfile(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete hub component
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runProfilesV1DeleteRunProfile(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunProfilesV1ApiFetchParamCreator(configuration).runProfilesV1DeleteRunProfile(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get hub component
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runProfilesV1GetRunProfile(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1RunProfile> {
            const localVarFetchArgs = RunProfilesV1ApiFetchParamCreator(configuration).runProfilesV1GetRunProfile(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List hub component names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runProfilesV1ListRunProfileNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListRunProfilesResponse> {
            const localVarFetchArgs = RunProfilesV1ApiFetchParamCreator(configuration).runProfilesV1ListRunProfileNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List hub components
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runProfilesV1ListRunProfiles(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListRunProfilesResponse> {
            const localVarFetchArgs = RunProfilesV1ApiFetchParamCreator(configuration).runProfilesV1ListRunProfiles(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch hub component
         * @param {string} owner Owner of the namespace
         * @param {string} run_profile_uuid UUID
         * @param {V1RunProfile} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runProfilesV1PatchRunProfile(owner: string, run_profile_uuid: string, body: V1RunProfile, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1RunProfile> {
            const localVarFetchArgs = RunProfilesV1ApiFetchParamCreator(configuration).runProfilesV1PatchRunProfile(owner, run_profile_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update hub component
         * @param {string} owner Owner of the namespace
         * @param {string} run_profile_uuid UUID
         * @param {V1RunProfile} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runProfilesV1UpdateRunProfile(owner: string, run_profile_uuid: string, body: V1RunProfile, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1RunProfile> {
            const localVarFetchArgs = RunProfilesV1ApiFetchParamCreator(configuration).runProfilesV1UpdateRunProfile(owner, run_profile_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RunProfilesV1Api - factory interface
 * @export
 */
export const RunProfilesV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create hub component
         * @param {string} owner Owner of the namespace
         * @param {V1RunProfile} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runProfilesV1CreateRunProfile(owner: string, body: V1RunProfile, options?: any) {
            return RunProfilesV1ApiFp(configuration).runProfilesV1CreateRunProfile(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete hub component
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runProfilesV1DeleteRunProfile(owner: string, uuid: string, options?: any) {
            return RunProfilesV1ApiFp(configuration).runProfilesV1DeleteRunProfile(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get hub component
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runProfilesV1GetRunProfile(owner: string, uuid: string, options?: any) {
            return RunProfilesV1ApiFp(configuration).runProfilesV1GetRunProfile(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List hub component names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runProfilesV1ListRunProfileNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return RunProfilesV1ApiFp(configuration).runProfilesV1ListRunProfileNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List hub components
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runProfilesV1ListRunProfiles(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return RunProfilesV1ApiFp(configuration).runProfilesV1ListRunProfiles(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch hub component
         * @param {string} owner Owner of the namespace
         * @param {string} run_profile_uuid UUID
         * @param {V1RunProfile} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runProfilesV1PatchRunProfile(owner: string, run_profile_uuid: string, body: V1RunProfile, options?: any) {
            return RunProfilesV1ApiFp(configuration).runProfilesV1PatchRunProfile(owner, run_profile_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update hub component
         * @param {string} owner Owner of the namespace
         * @param {string} run_profile_uuid UUID
         * @param {V1RunProfile} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runProfilesV1UpdateRunProfile(owner: string, run_profile_uuid: string, body: V1RunProfile, options?: any) {
            return RunProfilesV1ApiFp(configuration).runProfilesV1UpdateRunProfile(owner, run_profile_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * RunProfilesV1Api - object-oriented interface
 * @export
 * @class RunProfilesV1Api
 * @extends {BaseAPI}
 */
export class RunProfilesV1Api extends BaseAPI {
    /**
     * 
     * @summary Create hub component
     * @param {string} owner Owner of the namespace
     * @param {V1RunProfile} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunProfilesV1Api
     */
    public runProfilesV1CreateRunProfile(owner: string, body: V1RunProfile, options?: any) {
        return RunProfilesV1ApiFp(this.configuration).runProfilesV1CreateRunProfile(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete hub component
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunProfilesV1Api
     */
    public runProfilesV1DeleteRunProfile(owner: string, uuid: string, options?: any) {
        return RunProfilesV1ApiFp(this.configuration).runProfilesV1DeleteRunProfile(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get hub component
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunProfilesV1Api
     */
    public runProfilesV1GetRunProfile(owner: string, uuid: string, options?: any) {
        return RunProfilesV1ApiFp(this.configuration).runProfilesV1GetRunProfile(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List hub component names
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunProfilesV1Api
     */
    public runProfilesV1ListRunProfileNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return RunProfilesV1ApiFp(this.configuration).runProfilesV1ListRunProfileNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List hub components
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunProfilesV1Api
     */
    public runProfilesV1ListRunProfiles(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return RunProfilesV1ApiFp(this.configuration).runProfilesV1ListRunProfiles(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch hub component
     * @param {string} owner Owner of the namespace
     * @param {string} run_profile_uuid UUID
     * @param {V1RunProfile} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunProfilesV1Api
     */
    public runProfilesV1PatchRunProfile(owner: string, run_profile_uuid: string, body: V1RunProfile, options?: any) {
        return RunProfilesV1ApiFp(this.configuration).runProfilesV1PatchRunProfile(owner, run_profile_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update hub component
     * @param {string} owner Owner of the namespace
     * @param {string} run_profile_uuid UUID
     * @param {V1RunProfile} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunProfilesV1Api
     */
    public runProfilesV1UpdateRunProfile(owner: string, run_profile_uuid: string, body: V1RunProfile, options?: any) {
        return RunProfilesV1ApiFp(this.configuration).runProfilesV1UpdateRunProfile(owner, run_profile_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * RunsV1Api - fetch parameter creator
 * @export
 */
export const RunsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get run artifact
         * @param {string} namespace namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {string} [path] Artifact filepath.
         * @param {boolean} [stream] Whether to stream the file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunArtifact(namespace: string, owner: string, project: string, uuid: string, path?: string, stream?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getRunArtifact.');
            }
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRunArtifact.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getRunArtifact.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRunArtifact.');
            }
            const localVarPath = `/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/artifact`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (stream !== undefined) {
                localVarQueryParameter['stream'] = stream;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run artifacts
         * @param {string} namespace namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {string} [path] Artifact filepath.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunArtifacts(namespace: string, owner: string, project: string, uuid: string, path?: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getRunArtifacts.');
            }
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRunArtifacts.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getRunArtifacts.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRunArtifacts.');
            }
            const localVarPath = `/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/artifacts`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Archive run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1ArchiveRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runsV1ArchiveRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling runsV1ArchiveRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling runsV1ArchiveRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/archive`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Bookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1BookmarkRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runsV1BookmarkRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling runsV1BookmarkRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling runsV1BookmarkRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/bookmark`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Bookmark runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1BookmarkRuns(owner: string, project: string, body: V1Uuids, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runsV1BookmarkRuns.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling runsV1BookmarkRuns.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling runsV1BookmarkRuns.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/bookmark`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Uuids" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Collect run logs
         * @param {string} namespace 
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1CollectRunLogs(namespace: string, owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling runsV1CollectRunLogs.');
            }
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runsV1CollectRunLogs.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling runsV1CollectRunLogs.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling runsV1CollectRunLogs.');
            }
            const localVarPath = `/streams/v1/{namespace}/_internal/{owner}/{project}/runs/{uuid}/logs`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restart run with copy
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project
         * @param {string} entity_uuid Uuid identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1CopyRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options: any = {}): FetchArgs {
            // verify required parameter 'entity_owner' is not null or undefined
            if (entity_owner === null || entity_owner === undefined) {
                throw new RequiredError('entity_owner','Required parameter entity_owner was null or undefined when calling runsV1CopyRun.');
            }
            // verify required parameter 'entity_project' is not null or undefined
            if (entity_project === null || entity_project === undefined) {
                throw new RequiredError('entity_project','Required parameter entity_project was null or undefined when calling runsV1CopyRun.');
            }
            // verify required parameter 'entity_uuid' is not null or undefined
            if (entity_uuid === null || entity_uuid === undefined) {
                throw new RequiredError('entity_uuid','Required parameter entity_uuid was null or undefined when calling runsV1CopyRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling runsV1CopyRun.');
            }
            const localVarPath = `/api/v1/{entity.owner}/{entity.project}/runs/{entity.uuid}/copy`
                .replace(`{${"entity.owner"}}`, encodeURIComponent(String(entity_owner)))
                .replace(`{${"entity.project"}}`, encodeURIComponent(String(entity_project)))
                .replace(`{${"entity.uuid"}}`, encodeURIComponent(String(entity_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Run" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {V1OperationBody} body operation object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1CreateRun(owner: string, project: string, body: V1OperationBody, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runsV1CreateRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling runsV1CreateRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling runsV1CreateRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1OperationBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create bulk run run artifacts lineage
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {V1RunArtifacts} body Run Artifacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1CreateRunArtifactsLineage(owner: string, project: string, uuid: string, body: V1RunArtifacts, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runsV1CreateRunArtifactsLineage.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling runsV1CreateRunArtifactsLineage.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling runsV1CreateRunArtifactsLineage.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling runsV1CreateRunArtifactsLineage.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/artifacts_lineage`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1RunArtifacts" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {V1EntityStatusBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1CreateRunStatus(owner: string, project: string, uuid: string, body: V1EntityStatusBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runsV1CreateRunStatus.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling runsV1CreateRunStatus.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling runsV1CreateRunStatus.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling runsV1CreateRunStatus.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/statuses`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1EntityStatusBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1DeleteRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runsV1DeleteRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling runsV1DeleteRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling runsV1DeleteRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete run artifact lineage
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {string} name Artifact name
         * @param {string} [namespace] namespace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1DeleteRunArtifactLineage(owner: string, project: string, uuid: string, name: string, namespace?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runsV1DeleteRunArtifactLineage.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling runsV1DeleteRunArtifactLineage.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling runsV1DeleteRunArtifactLineage.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling runsV1DeleteRunArtifactLineage.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/artifacts_lineage/{name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1DeleteRuns(owner: string, project: string, body: V1Uuids, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runsV1DeleteRuns.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling runsV1DeleteRuns.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling runsV1DeleteRuns.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/delete`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Uuids" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get multi runs events
         * @param {string} namespace namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table'} kind The artifact kind
         * @param {string} [names] Names query param.
         * @param {string} [runs] Runs query param.
         * @param {string} [orient] Orient query param.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetMultiRunEvents(namespace: string, owner: string, project: string, kind: 'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table', names?: string, runs?: string, orient?: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling runsV1GetMultiRunEvents.');
            }
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runsV1GetMultiRunEvents.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling runsV1GetMultiRunEvents.');
            }
            // verify required parameter 'kind' is not null or undefined
            if (kind === null || kind === undefined) {
                throw new RequiredError('kind','Required parameter kind was null or undefined when calling runsV1GetMultiRunEvents.');
            }
            const localVarPath = `/streams/v1/{namespace}/{owner}/{project}/runs/multi/events/{kind}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"kind"}}`, encodeURIComponent(String(kind)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (names !== undefined) {
                localVarQueryParameter['names'] = names;
            }

            if (runs !== undefined) {
                localVarQueryParameter['runs'] = runs;
            }

            if (orient !== undefined) {
                localVarQueryParameter['orient'] = orient;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runsV1GetRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling runsV1GetRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling runsV1GetRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run artifacts lineage
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {string} name Artifact name
         * @param {string} [namespace] namespace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetRunArtifactLineage(owner: string, project: string, uuid: string, name: string, namespace?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runsV1GetRunArtifactLineage.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling runsV1GetRunArtifactLineage.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling runsV1GetRunArtifactLineage.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling runsV1GetRunArtifactLineage.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/artifacts_lineage/{name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run artifacts lineage
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetRunArtifactsLineage(owner: string, project: string, uuid: string, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runsV1GetRunArtifactsLineage.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling runsV1GetRunArtifactsLineage.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling runsV1GetRunArtifactsLineage.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/artifacts_lineage`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run artifacts lineage names
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetRunArtifactsLineageNames(owner: string, project: string, uuid: string, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runsV1GetRunArtifactsLineageNames.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling runsV1GetRunArtifactsLineageNames.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling runsV1GetRunArtifactsLineageNames.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/artifacts_lineage/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run artifacts tree
         * @param {string} namespace namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {string} [path] Path query param.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetRunArtifactsTree(namespace: string, owner: string, project: string, uuid: string, path?: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling runsV1GetRunArtifactsTree.');
            }
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runsV1GetRunArtifactsTree.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling runsV1GetRunArtifactsTree.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling runsV1GetRunArtifactsTree.');
            }
            const localVarPath = `/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/artifacts/tree`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run events
         * @param {string} namespace namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table'} kind The artifact kind
         * @param {string} [names] Names query param.
         * @param {string} [orient] Orient query param.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetRunEvents(namespace: string, owner: string, project: string, uuid: string, kind: 'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table', names?: string, orient?: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling runsV1GetRunEvents.');
            }
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runsV1GetRunEvents.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling runsV1GetRunEvents.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling runsV1GetRunEvents.');
            }
            // verify required parameter 'kind' is not null or undefined
            if (kind === null || kind === undefined) {
                throw new RequiredError('kind','Required parameter kind was null or undefined when calling runsV1GetRunEvents.');
            }
            const localVarPath = `/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/events/{kind}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
                .replace(`{${"kind"}}`, encodeURIComponent(String(kind)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (names !== undefined) {
                localVarQueryParameter['names'] = names;
            }

            if (orient !== undefined) {
                localVarQueryParameter['orient'] = orient;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run logs
         * @param {string} namespace 
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {Date} [last_time] last time.
         * @param {string} [last_file] last file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetRunLogs(namespace: string, owner: string, project: string, uuid: string, last_time?: Date, last_file?: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling runsV1GetRunLogs.');
            }
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runsV1GetRunLogs.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling runsV1GetRunLogs.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling runsV1GetRunLogs.');
            }
            const localVarPath = `/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/logs`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (last_time !== undefined) {
                localVarQueryParameter['last_time'] = (last_time as any).toISOString();
            }

            if (last_file !== undefined) {
                localVarQueryParameter['last_file'] = last_file;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Run namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetRunNamespace(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runsV1GetRunNamespace.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling runsV1GetRunNamespace.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling runsV1GetRunNamespace.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/namespace`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run resources events
         * @param {string} namespace namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {string} [names] Names query param.
         * @param {boolean} [tail] Query param flag to tail the values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetRunResources(namespace: string, owner: string, project: string, uuid: string, names?: string, tail?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling runsV1GetRunResources.');
            }
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runsV1GetRunResources.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling runsV1GetRunResources.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling runsV1GetRunResources.');
            }
            const localVarPath = `/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/resources`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (names !== undefined) {
                localVarQueryParameter['names'] = names;
            }

            if (tail !== undefined) {
                localVarQueryParameter['tail'] = tail;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Run settings
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetRunSettings(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runsV1GetRunSettings.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling runsV1GetRunSettings.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling runsV1GetRunSettings.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/settings`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetRunStatuses(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runsV1GetRunStatuses.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling runsV1GetRunStatuses.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling runsV1GetRunStatuses.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/statuses`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get runs artifacts lineage
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetRunsArtifactsLineage(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runsV1GetRunsArtifactsLineage.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling runsV1GetRunsArtifactsLineage.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/artifacts_lineage`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Impersonate run token
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1ImpersonateToken(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runsV1ImpersonateToken.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling runsV1ImpersonateToken.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling runsV1ImpersonateToken.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/impersonate`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invalidate run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {V1ProjectEntityResourceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1InvalidateRun(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runsV1InvalidateRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling runsV1InvalidateRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling runsV1InvalidateRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling runsV1InvalidateRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/invalidate`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ProjectEntityResourceRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invalidate runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1InvalidateRuns(owner: string, project: string, body: V1Uuids, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runsV1InvalidateRuns.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling runsV1InvalidateRuns.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling runsV1InvalidateRuns.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/invalidate`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Uuids" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1ListArchivedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling runsV1ListArchivedRuns.');
            }
            const localVarPath = `/api/v1/archives/{user}/runs`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1ListBookmarkedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling runsV1ListBookmarkedRuns.');
            }
            const localVarPath = `/api/v1/bookmarks/{user}/runs`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1ListRuns(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runsV1ListRuns.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling runsV1ListRuns.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List runs io
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1ListRunsIo(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runsV1ListRunsIo.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling runsV1ListRunsIo.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/io`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Notify run status
         * @param {string} namespace Na,espace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {V1EntityNotificationBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1NotifyRunStatus(namespace: string, owner: string, project: string, uuid: string, body: V1EntityNotificationBody, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling runsV1NotifyRunStatus.');
            }
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runsV1NotifyRunStatus.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling runsV1NotifyRunStatus.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling runsV1NotifyRunStatus.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling runsV1NotifyRunStatus.');
            }
            const localVarPath = `/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/notify`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1EntityNotificationBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} run_uuid UUID
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1PatchRun(owner: string, project: string, run_uuid: string, body: V1Run, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runsV1PatchRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling runsV1PatchRun.');
            }
            // verify required parameter 'run_uuid' is not null or undefined
            if (run_uuid === null || run_uuid === undefined) {
                throw new RequiredError('run_uuid','Required parameter run_uuid was null or undefined when calling runsV1PatchRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling runsV1PatchRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{run.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"run.uuid"}}`, encodeURIComponent(String(run_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Run" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restart run
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project
         * @param {string} entity_uuid Uuid identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1RestartRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options: any = {}): FetchArgs {
            // verify required parameter 'entity_owner' is not null or undefined
            if (entity_owner === null || entity_owner === undefined) {
                throw new RequiredError('entity_owner','Required parameter entity_owner was null or undefined when calling runsV1RestartRun.');
            }
            // verify required parameter 'entity_project' is not null or undefined
            if (entity_project === null || entity_project === undefined) {
                throw new RequiredError('entity_project','Required parameter entity_project was null or undefined when calling runsV1RestartRun.');
            }
            // verify required parameter 'entity_uuid' is not null or undefined
            if (entity_uuid === null || entity_uuid === undefined) {
                throw new RequiredError('entity_uuid','Required parameter entity_uuid was null or undefined when calling runsV1RestartRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling runsV1RestartRun.');
            }
            const localVarPath = `/api/v1/{entity.owner}/{entity.project}/runs/{entity.uuid}/restart`
                .replace(`{${"entity.owner"}}`, encodeURIComponent(String(entity_owner)))
                .replace(`{${"entity.project"}}`, encodeURIComponent(String(entity_project)))
                .replace(`{${"entity.uuid"}}`, encodeURIComponent(String(entity_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Run" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1RestoreRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runsV1RestoreRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling runsV1RestoreRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling runsV1RestoreRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/restore`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resume run
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project
         * @param {string} entity_uuid Uuid identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1ResumeRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options: any = {}): FetchArgs {
            // verify required parameter 'entity_owner' is not null or undefined
            if (entity_owner === null || entity_owner === undefined) {
                throw new RequiredError('entity_owner','Required parameter entity_owner was null or undefined when calling runsV1ResumeRun.');
            }
            // verify required parameter 'entity_project' is not null or undefined
            if (entity_project === null || entity_project === undefined) {
                throw new RequiredError('entity_project','Required parameter entity_project was null or undefined when calling runsV1ResumeRun.');
            }
            // verify required parameter 'entity_uuid' is not null or undefined
            if (entity_uuid === null || entity_uuid === undefined) {
                throw new RequiredError('entity_uuid','Required parameter entity_uuid was null or undefined when calling runsV1ResumeRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling runsV1ResumeRun.');
            }
            const localVarPath = `/api/v1/{entity.owner}/{entity.project}/runs/{entity.uuid}/resume`
                .replace(`{${"entity.owner"}}`, encodeURIComponent(String(entity_owner)))
                .replace(`{${"entity.project"}}`, encodeURIComponent(String(entity_project)))
                .replace(`{${"entity.uuid"}}`, encodeURIComponent(String(entity_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Run" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {V1ProjectEntityResourceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1StartRunTensorboard(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runsV1StartRunTensorboard.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling runsV1StartRunTensorboard.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling runsV1StartRunTensorboard.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling runsV1StartRunTensorboard.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/tensorboard/start`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ProjectEntityResourceRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1StopRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runsV1StopRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling runsV1StopRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling runsV1StopRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/stop`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1StopRunTensorboard(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runsV1StopRunTensorboard.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling runsV1StopRunTensorboard.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling runsV1StopRunTensorboard.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/tensorboard/stop`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1StopRuns(owner: string, project: string, body: V1Uuids, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runsV1StopRuns.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling runsV1StopRuns.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling runsV1StopRuns.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/stop`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Uuids" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tag runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1TagRuns(owner: string, project: string, body: V1Uuids, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runsV1TagRuns.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling runsV1TagRuns.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling runsV1TagRuns.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/tag`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Uuids" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unbookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1UnbookmarkRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runsV1UnbookmarkRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling runsV1UnbookmarkRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling runsV1UnbookmarkRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/unbookmark`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} run_uuid UUID
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1UpdateRun(owner: string, project: string, run_uuid: string, body: V1Run, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling runsV1UpdateRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling runsV1UpdateRun.');
            }
            // verify required parameter 'run_uuid' is not null or undefined
            if (run_uuid === null || run_uuid === undefined) {
                throw new RequiredError('run_uuid','Required parameter run_uuid was null or undefined when calling runsV1UpdateRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling runsV1UpdateRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{run.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"run.uuid"}}`, encodeURIComponent(String(run_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Run" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload an artifact file to a store via run access
         * @param {string} owner Owner of the namespace
         * @param {string} project Project having access to the store
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRunArtifact(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling uploadRunArtifact.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling uploadRunArtifact.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling uploadRunArtifact.');
            }
            // verify required parameter 'uploadfile' is not null or undefined
            if (uploadfile === null || uploadfile === undefined) {
                throw new RequiredError('uploadfile','Required parameter uploadfile was null or undefined when calling uploadRunArtifact.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/artifacts/upload`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (overwrite !== undefined) {
                localVarQueryParameter['overwrite'] = overwrite;
            }

            if (uploadfile !== undefined) {
                localVarFormParams.set('uploadfile', uploadfile as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload a logs file to a store via run access
         * @param {string} owner Owner of the namespace
         * @param {string} project Project having access to the store
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRunLogs(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling uploadRunLogs.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling uploadRunLogs.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling uploadRunLogs.');
            }
            // verify required parameter 'uploadfile' is not null or undefined
            if (uploadfile === null || uploadfile === undefined) {
                throw new RequiredError('uploadfile','Required parameter uploadfile was null or undefined when calling uploadRunLogs.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/logs/upload`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (overwrite !== undefined) {
                localVarQueryParameter['overwrite'] = overwrite;
            }

            if (uploadfile !== undefined) {
                localVarFormParams.set('uploadfile', uploadfile as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RunsV1Api - functional programming interface
 * @export
 */
export const RunsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get run artifact
         * @param {string} namespace namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {string} [path] Artifact filepath.
         * @param {boolean} [stream] Whether to stream the file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunArtifact(namespace: string, owner: string, project: string, uuid: string, path?: string, stream?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).getRunArtifact(namespace, owner, project, uuid, path, stream, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run artifacts
         * @param {string} namespace namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {string} [path] Artifact filepath.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunArtifacts(namespace: string, owner: string, project: string, uuid: string, path?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).getRunArtifacts(namespace, owner, project, uuid, path, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Archive run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1ArchiveRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1ArchiveRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Bookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1BookmarkRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1BookmarkRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Bookmark runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1BookmarkRuns(owner: string, project: string, body: V1Uuids, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1BookmarkRuns(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Collect run logs
         * @param {string} namespace 
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1CollectRunLogs(namespace: string, owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1CollectRunLogs(namespace, owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Restart run with copy
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project
         * @param {string} entity_uuid Uuid identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1CopyRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1CopyRun(entity_owner, entity_project, entity_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {V1OperationBody} body operation object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1CreateRun(owner: string, project: string, body: V1OperationBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1CreateRun(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create bulk run run artifacts lineage
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {V1RunArtifacts} body Run Artifacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1CreateRunArtifactsLineage(owner: string, project: string, uuid: string, body: V1RunArtifacts, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1CreateRunArtifactsLineage(owner, project, uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {V1EntityStatusBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1CreateRunStatus(owner: string, project: string, uuid: string, body: V1EntityStatusBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Status> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1CreateRunStatus(owner, project, uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1DeleteRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1DeleteRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete run artifact lineage
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {string} name Artifact name
         * @param {string} [namespace] namespace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1DeleteRunArtifactLineage(owner: string, project: string, uuid: string, name: string, namespace?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1DeleteRunArtifactLineage(owner, project, uuid, name, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1DeleteRuns(owner: string, project: string, body: V1Uuids, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1DeleteRuns(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get multi runs events
         * @param {string} namespace namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table'} kind The artifact kind
         * @param {string} [names] Names query param.
         * @param {string} [runs] Runs query param.
         * @param {string} [orient] Orient query param.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetMultiRunEvents(namespace: string, owner: string, project: string, kind: 'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table', names?: string, runs?: string, orient?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1EventsResponse> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1GetMultiRunEvents(namespace, owner, project, kind, names, runs, orient, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1GetRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run artifacts lineage
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {string} name Artifact name
         * @param {string} [namespace] namespace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetRunArtifactLineage(owner: string, project: string, uuid: string, name: string, namespace?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1RunArtifact> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1GetRunArtifactLineage(owner, project, uuid, name, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run artifacts lineage
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetRunArtifactsLineage(owner: string, project: string, uuid: string, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListRunArtifactsResponse> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1GetRunArtifactsLineage(owner, project, uuid, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run artifacts lineage names
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetRunArtifactsLineageNames(owner: string, project: string, uuid: string, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListRunArtifactsResponse> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1GetRunArtifactsLineageNames(owner, project, uuid, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run artifacts tree
         * @param {string} namespace namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {string} [path] Path query param.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetRunArtifactsTree(namespace: string, owner: string, project: string, uuid: string, path?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ArtifactTree> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1GetRunArtifactsTree(namespace, owner, project, uuid, path, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run events
         * @param {string} namespace namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table'} kind The artifact kind
         * @param {string} [names] Names query param.
         * @param {string} [orient] Orient query param.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetRunEvents(namespace: string, owner: string, project: string, uuid: string, kind: 'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table', names?: string, orient?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1EventsResponse> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1GetRunEvents(namespace, owner, project, uuid, kind, names, orient, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run logs
         * @param {string} namespace 
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {Date} [last_time] last time.
         * @param {string} [last_file] last file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetRunLogs(namespace: string, owner: string, project: string, uuid: string, last_time?: Date, last_file?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Logs> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1GetRunLogs(namespace, owner, project, uuid, last_time, last_file, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get Run namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetRunNamespace(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1RunSettings> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1GetRunNamespace(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run resources events
         * @param {string} namespace namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {string} [names] Names query param.
         * @param {boolean} [tail] Query param flag to tail the values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetRunResources(namespace: string, owner: string, project: string, uuid: string, names?: string, tail?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1EventsResponse> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1GetRunResources(namespace, owner, project, uuid, names, tail, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get Run settings
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetRunSettings(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1RunSettings> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1GetRunSettings(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetRunStatuses(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Status> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1GetRunStatuses(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get runs artifacts lineage
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetRunsArtifactsLineage(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1GetRunsArtifactsLineage(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Impersonate run token
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1ImpersonateToken(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Auth> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1ImpersonateToken(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Invalidate run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {V1ProjectEntityResourceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1InvalidateRun(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1InvalidateRun(owner, project, uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Invalidate runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1InvalidateRuns(owner: string, project: string, body: V1Uuids, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1InvalidateRuns(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1ListArchivedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListRunsResponse> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1ListArchivedRuns(user, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1ListBookmarkedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListRunsResponse> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1ListBookmarkedRuns(user, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1ListRuns(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListRunsResponse> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1ListRuns(owner, project, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List runs io
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1ListRunsIo(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListRunsResponse> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1ListRunsIo(owner, project, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Notify run status
         * @param {string} namespace Na,espace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {V1EntityNotificationBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1NotifyRunStatus(namespace: string, owner: string, project: string, uuid: string, body: V1EntityNotificationBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1NotifyRunStatus(namespace, owner, project, uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} run_uuid UUID
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1PatchRun(owner: string, project: string, run_uuid: string, body: V1Run, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1PatchRun(owner, project, run_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Restart run
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project
         * @param {string} entity_uuid Uuid identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1RestartRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1RestartRun(entity_owner, entity_project, entity_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Restore run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1RestoreRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1RestoreRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Resume run
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project
         * @param {string} entity_uuid Uuid identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1ResumeRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1ResumeRun(entity_owner, entity_project, entity_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Start run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {V1ProjectEntityResourceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1StartRunTensorboard(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1StartRunTensorboard(owner, project, uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1StopRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1StopRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stop run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1StopRunTensorboard(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1StopRunTensorboard(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stop runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1StopRuns(owner: string, project: string, body: V1Uuids, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1StopRuns(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Tag runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1TagRuns(owner: string, project: string, body: V1Uuids, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1TagRuns(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Unbookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1UnbookmarkRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1UnbookmarkRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} run_uuid UUID
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1UpdateRun(owner: string, project: string, run_uuid: string, body: V1Run, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).runsV1UpdateRun(owner, project, run_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Upload an artifact file to a store via run access
         * @param {string} owner Owner of the namespace
         * @param {string} project Project having access to the store
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRunArtifact(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).uploadRunArtifact(owner, project, uuid, uploadfile, path, overwrite, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Upload a logs file to a store via run access
         * @param {string} owner Owner of the namespace
         * @param {string} project Project having access to the store
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRunLogs(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).uploadRunLogs(owner, project, uuid, uploadfile, path, overwrite, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RunsV1Api - factory interface
 * @export
 */
export const RunsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get run artifact
         * @param {string} namespace namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {string} [path] Artifact filepath.
         * @param {boolean} [stream] Whether to stream the file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunArtifact(namespace: string, owner: string, project: string, uuid: string, path?: string, stream?: boolean, options?: any) {
            return RunsV1ApiFp(configuration).getRunArtifact(namespace, owner, project, uuid, path, stream, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run artifacts
         * @param {string} namespace namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {string} [path] Artifact filepath.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunArtifacts(namespace: string, owner: string, project: string, uuid: string, path?: string, options?: any) {
            return RunsV1ApiFp(configuration).getRunArtifacts(namespace, owner, project, uuid, path, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Archive run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1ArchiveRun(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).runsV1ArchiveRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Bookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1BookmarkRun(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).runsV1BookmarkRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Bookmark runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1BookmarkRuns(owner: string, project: string, body: V1Uuids, options?: any) {
            return RunsV1ApiFp(configuration).runsV1BookmarkRuns(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Collect run logs
         * @param {string} namespace 
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1CollectRunLogs(namespace: string, owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).runsV1CollectRunLogs(namespace, owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Restart run with copy
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project
         * @param {string} entity_uuid Uuid identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1CopyRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any) {
            return RunsV1ApiFp(configuration).runsV1CopyRun(entity_owner, entity_project, entity_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {V1OperationBody} body operation object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1CreateRun(owner: string, project: string, body: V1OperationBody, options?: any) {
            return RunsV1ApiFp(configuration).runsV1CreateRun(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create bulk run run artifacts lineage
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {V1RunArtifacts} body Run Artifacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1CreateRunArtifactsLineage(owner: string, project: string, uuid: string, body: V1RunArtifacts, options?: any) {
            return RunsV1ApiFp(configuration).runsV1CreateRunArtifactsLineage(owner, project, uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {V1EntityStatusBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1CreateRunStatus(owner: string, project: string, uuid: string, body: V1EntityStatusBodyRequest, options?: any) {
            return RunsV1ApiFp(configuration).runsV1CreateRunStatus(owner, project, uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1DeleteRun(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).runsV1DeleteRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete run artifact lineage
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {string} name Artifact name
         * @param {string} [namespace] namespace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1DeleteRunArtifactLineage(owner: string, project: string, uuid: string, name: string, namespace?: string, options?: any) {
            return RunsV1ApiFp(configuration).runsV1DeleteRunArtifactLineage(owner, project, uuid, name, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1DeleteRuns(owner: string, project: string, body: V1Uuids, options?: any) {
            return RunsV1ApiFp(configuration).runsV1DeleteRuns(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get multi runs events
         * @param {string} namespace namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table'} kind The artifact kind
         * @param {string} [names] Names query param.
         * @param {string} [runs] Runs query param.
         * @param {string} [orient] Orient query param.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetMultiRunEvents(namespace: string, owner: string, project: string, kind: 'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table', names?: string, runs?: string, orient?: string, options?: any) {
            return RunsV1ApiFp(configuration).runsV1GetMultiRunEvents(namespace, owner, project, kind, names, runs, orient, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetRun(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).runsV1GetRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run artifacts lineage
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {string} name Artifact name
         * @param {string} [namespace] namespace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetRunArtifactLineage(owner: string, project: string, uuid: string, name: string, namespace?: string, options?: any) {
            return RunsV1ApiFp(configuration).runsV1GetRunArtifactLineage(owner, project, uuid, name, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run artifacts lineage
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetRunArtifactsLineage(owner: string, project: string, uuid: string, limit?: number, sort?: string, query?: string, options?: any) {
            return RunsV1ApiFp(configuration).runsV1GetRunArtifactsLineage(owner, project, uuid, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run artifacts lineage names
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetRunArtifactsLineageNames(owner: string, project: string, uuid: string, limit?: number, sort?: string, query?: string, options?: any) {
            return RunsV1ApiFp(configuration).runsV1GetRunArtifactsLineageNames(owner, project, uuid, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run artifacts tree
         * @param {string} namespace namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {string} [path] Path query param.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetRunArtifactsTree(namespace: string, owner: string, project: string, uuid: string, path?: string, options?: any) {
            return RunsV1ApiFp(configuration).runsV1GetRunArtifactsTree(namespace, owner, project, uuid, path, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run events
         * @param {string} namespace namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table'} kind The artifact kind
         * @param {string} [names] Names query param.
         * @param {string} [orient] Orient query param.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetRunEvents(namespace: string, owner: string, project: string, uuid: string, kind: 'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table', names?: string, orient?: string, options?: any) {
            return RunsV1ApiFp(configuration).runsV1GetRunEvents(namespace, owner, project, uuid, kind, names, orient, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run logs
         * @param {string} namespace 
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {Date} [last_time] last time.
         * @param {string} [last_file] last file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetRunLogs(namespace: string, owner: string, project: string, uuid: string, last_time?: Date, last_file?: string, options?: any) {
            return RunsV1ApiFp(configuration).runsV1GetRunLogs(namespace, owner, project, uuid, last_time, last_file, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get Run namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetRunNamespace(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).runsV1GetRunNamespace(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run resources events
         * @param {string} namespace namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {string} [names] Names query param.
         * @param {boolean} [tail] Query param flag to tail the values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetRunResources(namespace: string, owner: string, project: string, uuid: string, names?: string, tail?: boolean, options?: any) {
            return RunsV1ApiFp(configuration).runsV1GetRunResources(namespace, owner, project, uuid, names, tail, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get Run settings
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetRunSettings(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).runsV1GetRunSettings(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetRunStatuses(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).runsV1GetRunStatuses(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get runs artifacts lineage
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1GetRunsArtifactsLineage(owner: string, project: string, options?: any) {
            return RunsV1ApiFp(configuration).runsV1GetRunsArtifactsLineage(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Impersonate run token
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1ImpersonateToken(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).runsV1ImpersonateToken(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Invalidate run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {V1ProjectEntityResourceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1InvalidateRun(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options?: any) {
            return RunsV1ApiFp(configuration).runsV1InvalidateRun(owner, project, uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Invalidate runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1InvalidateRuns(owner: string, project: string, body: V1Uuids, options?: any) {
            return RunsV1ApiFp(configuration).runsV1InvalidateRuns(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1ListArchivedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return RunsV1ApiFp(configuration).runsV1ListArchivedRuns(user, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1ListBookmarkedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return RunsV1ApiFp(configuration).runsV1ListBookmarkedRuns(user, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1ListRuns(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return RunsV1ApiFp(configuration).runsV1ListRuns(owner, project, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List runs io
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1ListRunsIo(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return RunsV1ApiFp(configuration).runsV1ListRunsIo(owner, project, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Notify run status
         * @param {string} namespace Na,espace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {V1EntityNotificationBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1NotifyRunStatus(namespace: string, owner: string, project: string, uuid: string, body: V1EntityNotificationBody, options?: any) {
            return RunsV1ApiFp(configuration).runsV1NotifyRunStatus(namespace, owner, project, uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} run_uuid UUID
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1PatchRun(owner: string, project: string, run_uuid: string, body: V1Run, options?: any) {
            return RunsV1ApiFp(configuration).runsV1PatchRun(owner, project, run_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Restart run
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project
         * @param {string} entity_uuid Uuid identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1RestartRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any) {
            return RunsV1ApiFp(configuration).runsV1RestartRun(entity_owner, entity_project, entity_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Restore run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1RestoreRun(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).runsV1RestoreRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Resume run
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project
         * @param {string} entity_uuid Uuid identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1ResumeRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any) {
            return RunsV1ApiFp(configuration).runsV1ResumeRun(entity_owner, entity_project, entity_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Start run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {V1ProjectEntityResourceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1StartRunTensorboard(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options?: any) {
            return RunsV1ApiFp(configuration).runsV1StartRunTensorboard(owner, project, uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1StopRun(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).runsV1StopRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stop run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1StopRunTensorboard(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).runsV1StopRunTensorboard(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stop runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1StopRuns(owner: string, project: string, body: V1Uuids, options?: any) {
            return RunsV1ApiFp(configuration).runsV1StopRuns(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Tag runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1TagRuns(owner: string, project: string, body: V1Uuids, options?: any) {
            return RunsV1ApiFp(configuration).runsV1TagRuns(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Unbookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1UnbookmarkRun(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).runsV1UnbookmarkRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} run_uuid UUID
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsV1UpdateRun(owner: string, project: string, run_uuid: string, body: V1Run, options?: any) {
            return RunsV1ApiFp(configuration).runsV1UpdateRun(owner, project, run_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Upload an artifact file to a store via run access
         * @param {string} owner Owner of the namespace
         * @param {string} project Project having access to the store
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRunArtifact(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any) {
            return RunsV1ApiFp(configuration).uploadRunArtifact(owner, project, uuid, uploadfile, path, overwrite, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Upload a logs file to a store via run access
         * @param {string} owner Owner of the namespace
         * @param {string} project Project having access to the store
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRunLogs(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any) {
            return RunsV1ApiFp(configuration).uploadRunLogs(owner, project, uuid, uploadfile, path, overwrite, options)(fetch, basePath);
        },
    };
};

/**
 * RunsV1Api - object-oriented interface
 * @export
 * @class RunsV1Api
 * @extends {BaseAPI}
 */
export class RunsV1Api extends BaseAPI {
    /**
     * 
     * @summary Get run artifact
     * @param {string} namespace namespace
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {string} [path] Artifact filepath.
     * @param {boolean} [stream] Whether to stream the file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public getRunArtifact(namespace: string, owner: string, project: string, uuid: string, path?: string, stream?: boolean, options?: any) {
        return RunsV1ApiFp(this.configuration).getRunArtifact(namespace, owner, project, uuid, path, stream, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run artifacts
     * @param {string} namespace namespace
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {string} [path] Artifact filepath.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public getRunArtifacts(namespace: string, owner: string, project: string, uuid: string, path?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).getRunArtifacts(namespace, owner, project, uuid, path, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Archive run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1ArchiveRun(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1ArchiveRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Bookmark run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1BookmarkRun(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1BookmarkRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Bookmark runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {V1Uuids} body Uuids of the entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1BookmarkRuns(owner: string, project: string, body: V1Uuids, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1BookmarkRuns(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Collect run logs
     * @param {string} namespace 
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the run will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1CollectRunLogs(namespace: string, owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1CollectRunLogs(namespace, owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Restart run with copy
     * @param {string} entity_owner Owner of the namespace
     * @param {string} entity_project Project
     * @param {string} entity_uuid Uuid identifier of the entity
     * @param {V1Run} body Run object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1CopyRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1CopyRun(entity_owner, entity_project, entity_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the run will be assigned
     * @param {V1OperationBody} body operation object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1CreateRun(owner: string, project: string, body: V1OperationBody, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1CreateRun(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create bulk run run artifacts lineage
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the run will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {V1RunArtifacts} body Run Artifacts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1CreateRunArtifactsLineage(owner: string, project: string, uuid: string, body: V1RunArtifacts, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1CreateRunArtifactsLineage(owner, project, uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run status
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the run will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {V1EntityStatusBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1CreateRunStatus(owner: string, project: string, uuid: string, body: V1EntityStatusBodyRequest, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1CreateRunStatus(owner, project, uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1DeleteRun(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1DeleteRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete run artifact lineage
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the run will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {string} name Artifact name
     * @param {string} [namespace] namespace.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1DeleteRunArtifactLineage(owner: string, project: string, uuid: string, name: string, namespace?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1DeleteRunArtifactLineage(owner, project, uuid, name, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {V1Uuids} body Uuids of the entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1DeleteRuns(owner: string, project: string, body: V1Uuids, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1DeleteRuns(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get multi runs events
     * @param {string} namespace namespace
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the run will be assigned
     * @param {'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table'} kind The artifact kind
     * @param {string} [names] Names query param.
     * @param {string} [runs] Runs query param.
     * @param {string} [orient] Orient query param.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1GetMultiRunEvents(namespace: string, owner: string, project: string, kind: 'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table', names?: string, runs?: string, orient?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1GetMultiRunEvents(namespace, owner, project, kind, names, runs, orient, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1GetRun(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1GetRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run artifacts lineage
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the run will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {string} name Artifact name
     * @param {string} [namespace] namespace.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1GetRunArtifactLineage(owner: string, project: string, uuid: string, name: string, namespace?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1GetRunArtifactLineage(owner, project, uuid, name, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run artifacts lineage
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the run will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1GetRunArtifactsLineage(owner: string, project: string, uuid: string, limit?: number, sort?: string, query?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1GetRunArtifactsLineage(owner, project, uuid, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run artifacts lineage names
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the run will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1GetRunArtifactsLineageNames(owner: string, project: string, uuid: string, limit?: number, sort?: string, query?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1GetRunArtifactsLineageNames(owner, project, uuid, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run artifacts tree
     * @param {string} namespace namespace
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the run will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {string} [path] Path query param.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1GetRunArtifactsTree(namespace: string, owner: string, project: string, uuid: string, path?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1GetRunArtifactsTree(namespace, owner, project, uuid, path, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run events
     * @param {string} namespace namespace
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the run will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table'} kind The artifact kind
     * @param {string} [names] Names query param.
     * @param {string} [orient] Orient query param.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1GetRunEvents(namespace: string, owner: string, project: string, uuid: string, kind: 'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table', names?: string, orient?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1GetRunEvents(namespace, owner, project, uuid, kind, names, orient, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run logs
     * @param {string} namespace 
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the run will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {Date} [last_time] last time.
     * @param {string} [last_file] last file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1GetRunLogs(namespace: string, owner: string, project: string, uuid: string, last_time?: Date, last_file?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1GetRunLogs(namespace, owner, project, uuid, last_time, last_file, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get Run namespace
     * @param {string} owner Owner of the namespace
     * @param {string} project Project
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1GetRunNamespace(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1GetRunNamespace(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run resources events
     * @param {string} namespace namespace
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the run will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {string} [names] Names query param.
     * @param {boolean} [tail] Query param flag to tail the values.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1GetRunResources(namespace: string, owner: string, project: string, uuid: string, names?: string, tail?: boolean, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1GetRunResources(namespace, owner, project, uuid, names, tail, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get Run settings
     * @param {string} owner Owner of the namespace
     * @param {string} project Project
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1GetRunSettings(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1GetRunSettings(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run status
     * @param {string} owner Owner of the namespace
     * @param {string} project Project
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1GetRunStatuses(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1GetRunStatuses(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get runs artifacts lineage
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1GetRunsArtifactsLineage(owner: string, project: string, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1GetRunsArtifactsLineage(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Impersonate run token
     * @param {string} owner Owner of the namespace
     * @param {string} project Project
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1ImpersonateToken(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1ImpersonateToken(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Invalidate run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project
     * @param {string} uuid Uuid identifier of the entity
     * @param {V1ProjectEntityResourceRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1InvalidateRun(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1InvalidateRun(owner, project, uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Invalidate runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {V1Uuids} body Uuids of the entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1InvalidateRuns(owner: string, project: string, body: V1Uuids, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1InvalidateRuns(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List archived runs for user
     * @param {string} user User
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1ListArchivedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1ListArchivedRuns(user, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked runs for user
     * @param {string} user User
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1ListBookmarkedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1ListBookmarkedRuns(user, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1ListRuns(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1ListRuns(owner, project, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List runs io
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1ListRunsIo(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1ListRunsIo(owner, project, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Notify run status
     * @param {string} namespace Na,espace
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the run will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {V1EntityNotificationBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1NotifyRunStatus(namespace: string, owner: string, project: string, uuid: string, body: V1EntityNotificationBody, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1NotifyRunStatus(namespace, owner, project, uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the run will be assigned
     * @param {string} run_uuid UUID
     * @param {V1Run} body Run object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1PatchRun(owner: string, project: string, run_uuid: string, body: V1Run, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1PatchRun(owner, project, run_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Restart run
     * @param {string} entity_owner Owner of the namespace
     * @param {string} entity_project Project
     * @param {string} entity_uuid Uuid identifier of the entity
     * @param {V1Run} body Run object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1RestartRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1RestartRun(entity_owner, entity_project, entity_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Restore run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1RestoreRun(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1RestoreRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Resume run
     * @param {string} entity_owner Owner of the namespace
     * @param {string} entity_project Project
     * @param {string} entity_uuid Uuid identifier of the entity
     * @param {V1Run} body Run object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1ResumeRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1ResumeRun(entity_owner, entity_project, entity_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Start run tensorboard
     * @param {string} owner Owner of the namespace
     * @param {string} project Project
     * @param {string} uuid Uuid identifier of the entity
     * @param {V1ProjectEntityResourceRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1StartRunTensorboard(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1StartRunTensorboard(owner, project, uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stop run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1StopRun(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1StopRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stop run tensorboard
     * @param {string} owner Owner of the namespace
     * @param {string} project Project
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1StopRunTensorboard(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1StopRunTensorboard(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stop runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {V1Uuids} body Uuids of the entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1StopRuns(owner: string, project: string, body: V1Uuids, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1StopRuns(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Tag runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {V1Uuids} body Uuids of the entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1TagRuns(owner: string, project: string, body: V1Uuids, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1TagRuns(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Unbookmark run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1UnbookmarkRun(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1UnbookmarkRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the run will be assigned
     * @param {string} run_uuid UUID
     * @param {V1Run} body Run object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public runsV1UpdateRun(owner: string, project: string, run_uuid: string, body: V1Run, options?: any) {
        return RunsV1ApiFp(this.configuration).runsV1UpdateRun(owner, project, run_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Upload an artifact file to a store via run access
     * @param {string} owner Owner of the namespace
     * @param {string} project Project having access to the store
     * @param {string} uuid Unique integer identifier of the entity
     * @param {any} uploadfile The file to upload.
     * @param {string} [path] File path query params.
     * @param {boolean} [overwrite] File path query params.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public uploadRunArtifact(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any) {
        return RunsV1ApiFp(this.configuration).uploadRunArtifact(owner, project, uuid, uploadfile, path, overwrite, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Upload a logs file to a store via run access
     * @param {string} owner Owner of the namespace
     * @param {string} project Project having access to the store
     * @param {string} uuid Unique integer identifier of the entity
     * @param {any} uploadfile The file to upload.
     * @param {string} [path] File path query params.
     * @param {boolean} [overwrite] File path query params.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public uploadRunLogs(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any) {
        return RunsV1ApiFp(this.configuration).uploadRunLogs(owner, project, uuid, uploadfile, path, overwrite, options)(this.fetch, this.basePath);
    }

}

/**
 * SchemasV1Api - fetch parameter creator
 * @export
 */
export const SchemasV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List teams names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemasV1NoOp(options: any = {}): FetchArgs {
            const localVarPath = `/schemas`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchemasV1Api - functional programming interface
 * @export
 */
export const SchemasV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List teams names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemasV1NoOp(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Schemas> {
            const localVarFetchArgs = SchemasV1ApiFetchParamCreator(configuration).schemasV1NoOp(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SchemasV1Api - factory interface
 * @export
 */
export const SchemasV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List teams names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemasV1NoOp(options?: any) {
            return SchemasV1ApiFp(configuration).schemasV1NoOp(options)(fetch, basePath);
        },
    };
};

/**
 * SchemasV1Api - object-oriented interface
 * @export
 * @class SchemasV1Api
 * @extends {BaseAPI}
 */
export class SchemasV1Api extends BaseAPI {
    /**
     * 
     * @summary List teams names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasV1Api
     */
    public schemasV1NoOp(options?: any) {
        return SchemasV1ApiFp(this.configuration).schemasV1NoOp(options)(this.fetch, this.basePath);
    }

}

/**
 * SearchesV1Api - fetch parameter creator
 * @export
 */
export const SearchesV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create search
         * @param {string} owner Owner of the namespace
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchesV1CreateSearch(owner: string, body: V1Search, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling searchesV1CreateSearch.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling searchesV1CreateSearch.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/searches`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Search" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete search
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchesV1DeleteSearch(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling searchesV1DeleteSearch.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling searchesV1DeleteSearch.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/searches/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get search
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchesV1GetSearch(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling searchesV1GetSearch.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling searchesV1GetSearch.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/searches/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List search names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchesV1ListSearchNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling searchesV1ListSearchNames.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/searches/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List searches
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchesV1ListSearches(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling searchesV1ListSearches.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/searches`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch search
         * @param {string} owner Owner of the namespace
         * @param {string} search_uuid UUID
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchesV1PatchSearch(owner: string, search_uuid: string, body: V1Search, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling searchesV1PatchSearch.');
            }
            // verify required parameter 'search_uuid' is not null or undefined
            if (search_uuid === null || search_uuid === undefined) {
                throw new RequiredError('search_uuid','Required parameter search_uuid was null or undefined when calling searchesV1PatchSearch.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling searchesV1PatchSearch.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/searches/{search.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"search.uuid"}}`, encodeURIComponent(String(search_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Search" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update search
         * @param {string} owner Owner of the namespace
         * @param {string} search_uuid UUID
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchesV1UpdateSearch(owner: string, search_uuid: string, body: V1Search, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling searchesV1UpdateSearch.');
            }
            // verify required parameter 'search_uuid' is not null or undefined
            if (search_uuid === null || search_uuid === undefined) {
                throw new RequiredError('search_uuid','Required parameter search_uuid was null or undefined when calling searchesV1UpdateSearch.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling searchesV1UpdateSearch.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/searches/{search.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"search.uuid"}}`, encodeURIComponent(String(search_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Search" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchesV1Api - functional programming interface
 * @export
 */
export const SearchesV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create search
         * @param {string} owner Owner of the namespace
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchesV1CreateSearch(owner: string, body: V1Search, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Search> {
            const localVarFetchArgs = SearchesV1ApiFetchParamCreator(configuration).searchesV1CreateSearch(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete search
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchesV1DeleteSearch(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SearchesV1ApiFetchParamCreator(configuration).searchesV1DeleteSearch(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get search
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchesV1GetSearch(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Search> {
            const localVarFetchArgs = SearchesV1ApiFetchParamCreator(configuration).searchesV1GetSearch(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List search names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchesV1ListSearchNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListSearchesResponse> {
            const localVarFetchArgs = SearchesV1ApiFetchParamCreator(configuration).searchesV1ListSearchNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List searches
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchesV1ListSearches(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListSearchesResponse> {
            const localVarFetchArgs = SearchesV1ApiFetchParamCreator(configuration).searchesV1ListSearches(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch search
         * @param {string} owner Owner of the namespace
         * @param {string} search_uuid UUID
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchesV1PatchSearch(owner: string, search_uuid: string, body: V1Search, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Search> {
            const localVarFetchArgs = SearchesV1ApiFetchParamCreator(configuration).searchesV1PatchSearch(owner, search_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update search
         * @param {string} owner Owner of the namespace
         * @param {string} search_uuid UUID
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchesV1UpdateSearch(owner: string, search_uuid: string, body: V1Search, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Search> {
            const localVarFetchArgs = SearchesV1ApiFetchParamCreator(configuration).searchesV1UpdateSearch(owner, search_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SearchesV1Api - factory interface
 * @export
 */
export const SearchesV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create search
         * @param {string} owner Owner of the namespace
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchesV1CreateSearch(owner: string, body: V1Search, options?: any) {
            return SearchesV1ApiFp(configuration).searchesV1CreateSearch(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete search
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchesV1DeleteSearch(owner: string, uuid: string, options?: any) {
            return SearchesV1ApiFp(configuration).searchesV1DeleteSearch(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get search
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchesV1GetSearch(owner: string, uuid: string, options?: any) {
            return SearchesV1ApiFp(configuration).searchesV1GetSearch(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List search names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchesV1ListSearchNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return SearchesV1ApiFp(configuration).searchesV1ListSearchNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List searches
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchesV1ListSearches(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return SearchesV1ApiFp(configuration).searchesV1ListSearches(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch search
         * @param {string} owner Owner of the namespace
         * @param {string} search_uuid UUID
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchesV1PatchSearch(owner: string, search_uuid: string, body: V1Search, options?: any) {
            return SearchesV1ApiFp(configuration).searchesV1PatchSearch(owner, search_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update search
         * @param {string} owner Owner of the namespace
         * @param {string} search_uuid UUID
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchesV1UpdateSearch(owner: string, search_uuid: string, body: V1Search, options?: any) {
            return SearchesV1ApiFp(configuration).searchesV1UpdateSearch(owner, search_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * SearchesV1Api - object-oriented interface
 * @export
 * @class SearchesV1Api
 * @extends {BaseAPI}
 */
export class SearchesV1Api extends BaseAPI {
    /**
     * 
     * @summary Create search
     * @param {string} owner Owner of the namespace
     * @param {V1Search} body Search body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchesV1Api
     */
    public searchesV1CreateSearch(owner: string, body: V1Search, options?: any) {
        return SearchesV1ApiFp(this.configuration).searchesV1CreateSearch(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete search
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchesV1Api
     */
    public searchesV1DeleteSearch(owner: string, uuid: string, options?: any) {
        return SearchesV1ApiFp(this.configuration).searchesV1DeleteSearch(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get search
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchesV1Api
     */
    public searchesV1GetSearch(owner: string, uuid: string, options?: any) {
        return SearchesV1ApiFp(this.configuration).searchesV1GetSearch(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List search names
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchesV1Api
     */
    public searchesV1ListSearchNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return SearchesV1ApiFp(this.configuration).searchesV1ListSearchNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List searches
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchesV1Api
     */
    public searchesV1ListSearches(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return SearchesV1ApiFp(this.configuration).searchesV1ListSearches(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch search
     * @param {string} owner Owner of the namespace
     * @param {string} search_uuid UUID
     * @param {V1Search} body Search body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchesV1Api
     */
    public searchesV1PatchSearch(owner: string, search_uuid: string, body: V1Search, options?: any) {
        return SearchesV1ApiFp(this.configuration).searchesV1PatchSearch(owner, search_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update search
     * @param {string} owner Owner of the namespace
     * @param {string} search_uuid UUID
     * @param {V1Search} body Search body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchesV1Api
     */
    public searchesV1UpdateSearch(owner: string, search_uuid: string, body: V1Search, options?: any) {
        return SearchesV1ApiFp(this.configuration).searchesV1UpdateSearch(owner, search_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * TeamsV1Api - fetch parameter creator
 * @export
 */
export const TeamsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create organization
         * @param {string} owner Owner of the namespace
         * @param {V1Team} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1CreateTeam(owner: string, body: V1Team, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling teamsV1CreateTeam.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling teamsV1CreateTeam.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Team" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create organization member
         * @param {string} owner Owner of the namespace
         * @param {string} team Team
         * @param {V1TeamMember} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1CreateTeamMember(owner: string, team: string, body: V1TeamMember, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling teamsV1CreateTeamMember.');
            }
            // verify required parameter 'team' is not null or undefined
            if (team === null || team === undefined) {
                throw new RequiredError('team','Required parameter team was null or undefined when calling teamsV1CreateTeamMember.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling teamsV1CreateTeamMember.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams/{team}/members`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1TeamMember" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete organization
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1DeleteTeam(owner: string, team: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling teamsV1DeleteTeam.');
            }
            // verify required parameter 'team' is not null or undefined
            if (team === null || team === undefined) {
                throw new RequiredError('team','Required parameter team was null or undefined when calling teamsV1DeleteTeam.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams/{team}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete organization member details
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {string} user Member under team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1DeleteTeamMember(owner: string, team: string, user: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling teamsV1DeleteTeamMember.');
            }
            // verify required parameter 'team' is not null or undefined
            if (team === null || team === undefined) {
                throw new RequiredError('team','Required parameter team was null or undefined when calling teamsV1DeleteTeamMember.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling teamsV1DeleteTeamMember.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams/{team}/members/{user}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1GetTeam(owner: string, team: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling teamsV1GetTeam.');
            }
            // verify required parameter 'team' is not null or undefined
            if (team === null || team === undefined) {
                throw new RequiredError('team','Required parameter team was null or undefined when calling teamsV1GetTeam.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams/{team}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization member details
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {string} user Member under team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1GetTeamMember(owner: string, team: string, user: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling teamsV1GetTeamMember.');
            }
            // verify required parameter 'team' is not null or undefined
            if (team === null || team === undefined) {
                throw new RequiredError('team','Required parameter team was null or undefined when calling teamsV1GetTeamMember.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling teamsV1GetTeamMember.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams/{team}/members/{user}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization members
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1ListTeamMembers(owner: string, team: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling teamsV1ListTeamMembers.');
            }
            // verify required parameter 'team' is not null or undefined
            if (team === null || team === undefined) {
                throw new RequiredError('team','Required parameter team was null or undefined when calling teamsV1ListTeamMembers.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams/{team}/members`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organizations names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1ListTeamNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling teamsV1ListTeamNames.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organizations
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1ListTeams(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling teamsV1ListTeams.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch organization
         * @param {string} owner Owner of the namespace
         * @param {string} team_name Name
         * @param {V1Team} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1PatchTeam(owner: string, team_name: string, body: V1Team, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling teamsV1PatchTeam.');
            }
            // verify required parameter 'team_name' is not null or undefined
            if (team_name === null || team_name === undefined) {
                throw new RequiredError('team_name','Required parameter team_name was null or undefined when calling teamsV1PatchTeam.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling teamsV1PatchTeam.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams/{team.name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"team.name"}}`, encodeURIComponent(String(team_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Team" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch organization member
         * @param {string} owner Owner of the namespace
         * @param {string} team Team
         * @param {string} member_user User
         * @param {V1TeamMember} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1PatchTeamMember(owner: string, team: string, member_user: string, body: V1TeamMember, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling teamsV1PatchTeamMember.');
            }
            // verify required parameter 'team' is not null or undefined
            if (team === null || team === undefined) {
                throw new RequiredError('team','Required parameter team was null or undefined when calling teamsV1PatchTeamMember.');
            }
            // verify required parameter 'member_user' is not null or undefined
            if (member_user === null || member_user === undefined) {
                throw new RequiredError('member_user','Required parameter member_user was null or undefined when calling teamsV1PatchTeamMember.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling teamsV1PatchTeamMember.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams/{team}/members/{member.user}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)))
                .replace(`{${"member.user"}}`, encodeURIComponent(String(member_user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1TeamMember" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update organization
         * @param {string} owner Owner of the namespace
         * @param {string} team_name Name
         * @param {V1Team} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1UpdateTeam(owner: string, team_name: string, body: V1Team, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling teamsV1UpdateTeam.');
            }
            // verify required parameter 'team_name' is not null or undefined
            if (team_name === null || team_name === undefined) {
                throw new RequiredError('team_name','Required parameter team_name was null or undefined when calling teamsV1UpdateTeam.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling teamsV1UpdateTeam.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams/{team.name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"team.name"}}`, encodeURIComponent(String(team_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Team" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update organization member
         * @param {string} owner Owner of the namespace
         * @param {string} team Team
         * @param {string} member_user User
         * @param {V1TeamMember} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1UpdateTeamMember(owner: string, team: string, member_user: string, body: V1TeamMember, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling teamsV1UpdateTeamMember.');
            }
            // verify required parameter 'team' is not null or undefined
            if (team === null || team === undefined) {
                throw new RequiredError('team','Required parameter team was null or undefined when calling teamsV1UpdateTeamMember.');
            }
            // verify required parameter 'member_user' is not null or undefined
            if (member_user === null || member_user === undefined) {
                throw new RequiredError('member_user','Required parameter member_user was null or undefined when calling teamsV1UpdateTeamMember.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling teamsV1UpdateTeamMember.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams/{team}/members/{member.user}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)))
                .replace(`{${"member.user"}}`, encodeURIComponent(String(member_user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1TeamMember" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamsV1Api - functional programming interface
 * @export
 */
export const TeamsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create organization
         * @param {string} owner Owner of the namespace
         * @param {V1Team} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1CreateTeam(owner: string, body: V1Team, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Team> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).teamsV1CreateTeam(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create organization member
         * @param {string} owner Owner of the namespace
         * @param {string} team Team
         * @param {V1TeamMember} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1CreateTeamMember(owner: string, team: string, body: V1TeamMember, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1TeamMember> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).teamsV1CreateTeamMember(owner, team, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete organization
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1DeleteTeam(owner: string, team: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).teamsV1DeleteTeam(owner, team, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete organization member details
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {string} user Member under team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1DeleteTeamMember(owner: string, team: string, user: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).teamsV1DeleteTeamMember(owner, team, user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get organization
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1GetTeam(owner: string, team: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Team> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).teamsV1GetTeam(owner, team, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get organization member details
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {string} user Member under team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1GetTeamMember(owner: string, team: string, user: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1TeamMember> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).teamsV1GetTeamMember(owner, team, user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get organization members
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1ListTeamMembers(owner: string, team: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListTeamMembersResponse> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).teamsV1ListTeamMembers(owner, team, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List organizations names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1ListTeamNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListTeamsResponse> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).teamsV1ListTeamNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List organizations
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1ListTeams(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListTeamsResponse> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).teamsV1ListTeams(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch organization
         * @param {string} owner Owner of the namespace
         * @param {string} team_name Name
         * @param {V1Team} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1PatchTeam(owner: string, team_name: string, body: V1Team, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Team> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).teamsV1PatchTeam(owner, team_name, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch organization member
         * @param {string} owner Owner of the namespace
         * @param {string} team Team
         * @param {string} member_user User
         * @param {V1TeamMember} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1PatchTeamMember(owner: string, team: string, member_user: string, body: V1TeamMember, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1TeamMember> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).teamsV1PatchTeamMember(owner, team, member_user, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update organization
         * @param {string} owner Owner of the namespace
         * @param {string} team_name Name
         * @param {V1Team} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1UpdateTeam(owner: string, team_name: string, body: V1Team, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Team> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).teamsV1UpdateTeam(owner, team_name, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update organization member
         * @param {string} owner Owner of the namespace
         * @param {string} team Team
         * @param {string} member_user User
         * @param {V1TeamMember} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1UpdateTeamMember(owner: string, team: string, member_user: string, body: V1TeamMember, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1TeamMember> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).teamsV1UpdateTeamMember(owner, team, member_user, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TeamsV1Api - factory interface
 * @export
 */
export const TeamsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create organization
         * @param {string} owner Owner of the namespace
         * @param {V1Team} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1CreateTeam(owner: string, body: V1Team, options?: any) {
            return TeamsV1ApiFp(configuration).teamsV1CreateTeam(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create organization member
         * @param {string} owner Owner of the namespace
         * @param {string} team Team
         * @param {V1TeamMember} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1CreateTeamMember(owner: string, team: string, body: V1TeamMember, options?: any) {
            return TeamsV1ApiFp(configuration).teamsV1CreateTeamMember(owner, team, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete organization
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1DeleteTeam(owner: string, team: string, options?: any) {
            return TeamsV1ApiFp(configuration).teamsV1DeleteTeam(owner, team, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete organization member details
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {string} user Member under team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1DeleteTeamMember(owner: string, team: string, user: string, options?: any) {
            return TeamsV1ApiFp(configuration).teamsV1DeleteTeamMember(owner, team, user, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get organization
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1GetTeam(owner: string, team: string, options?: any) {
            return TeamsV1ApiFp(configuration).teamsV1GetTeam(owner, team, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get organization member details
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {string} user Member under team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1GetTeamMember(owner: string, team: string, user: string, options?: any) {
            return TeamsV1ApiFp(configuration).teamsV1GetTeamMember(owner, team, user, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get organization members
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1ListTeamMembers(owner: string, team: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return TeamsV1ApiFp(configuration).teamsV1ListTeamMembers(owner, team, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List organizations names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1ListTeamNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return TeamsV1ApiFp(configuration).teamsV1ListTeamNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List organizations
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1ListTeams(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return TeamsV1ApiFp(configuration).teamsV1ListTeams(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch organization
         * @param {string} owner Owner of the namespace
         * @param {string} team_name Name
         * @param {V1Team} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1PatchTeam(owner: string, team_name: string, body: V1Team, options?: any) {
            return TeamsV1ApiFp(configuration).teamsV1PatchTeam(owner, team_name, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch organization member
         * @param {string} owner Owner of the namespace
         * @param {string} team Team
         * @param {string} member_user User
         * @param {V1TeamMember} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1PatchTeamMember(owner: string, team: string, member_user: string, body: V1TeamMember, options?: any) {
            return TeamsV1ApiFp(configuration).teamsV1PatchTeamMember(owner, team, member_user, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update organization
         * @param {string} owner Owner of the namespace
         * @param {string} team_name Name
         * @param {V1Team} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1UpdateTeam(owner: string, team_name: string, body: V1Team, options?: any) {
            return TeamsV1ApiFp(configuration).teamsV1UpdateTeam(owner, team_name, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update organization member
         * @param {string} owner Owner of the namespace
         * @param {string} team Team
         * @param {string} member_user User
         * @param {V1TeamMember} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsV1UpdateTeamMember(owner: string, team: string, member_user: string, body: V1TeamMember, options?: any) {
            return TeamsV1ApiFp(configuration).teamsV1UpdateTeamMember(owner, team, member_user, body, options)(fetch, basePath);
        },
    };
};

/**
 * TeamsV1Api - object-oriented interface
 * @export
 * @class TeamsV1Api
 * @extends {BaseAPI}
 */
export class TeamsV1Api extends BaseAPI {
    /**
     * 
     * @summary Create organization
     * @param {string} owner Owner of the namespace
     * @param {V1Team} body Team body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public teamsV1CreateTeam(owner: string, body: V1Team, options?: any) {
        return TeamsV1ApiFp(this.configuration).teamsV1CreateTeam(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create organization member
     * @param {string} owner Owner of the namespace
     * @param {string} team Team
     * @param {V1TeamMember} body Team body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public teamsV1CreateTeamMember(owner: string, team: string, body: V1TeamMember, options?: any) {
        return TeamsV1ApiFp(this.configuration).teamsV1CreateTeamMember(owner, team, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete organization
     * @param {string} owner Owner of the namespace
     * @param {string} team Team under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public teamsV1DeleteTeam(owner: string, team: string, options?: any) {
        return TeamsV1ApiFp(this.configuration).teamsV1DeleteTeam(owner, team, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete organization member details
     * @param {string} owner Owner of the namespace
     * @param {string} team Team under namesapce
     * @param {string} user Member under team
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public teamsV1DeleteTeamMember(owner: string, team: string, user: string, options?: any) {
        return TeamsV1ApiFp(this.configuration).teamsV1DeleteTeamMember(owner, team, user, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get organization
     * @param {string} owner Owner of the namespace
     * @param {string} team Team under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public teamsV1GetTeam(owner: string, team: string, options?: any) {
        return TeamsV1ApiFp(this.configuration).teamsV1GetTeam(owner, team, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get organization member details
     * @param {string} owner Owner of the namespace
     * @param {string} team Team under namesapce
     * @param {string} user Member under team
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public teamsV1GetTeamMember(owner: string, team: string, user: string, options?: any) {
        return TeamsV1ApiFp(this.configuration).teamsV1GetTeamMember(owner, team, user, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get organization members
     * @param {string} owner Owner of the namespace
     * @param {string} team Team under namesapce
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public teamsV1ListTeamMembers(owner: string, team: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return TeamsV1ApiFp(this.configuration).teamsV1ListTeamMembers(owner, team, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List organizations names
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public teamsV1ListTeamNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return TeamsV1ApiFp(this.configuration).teamsV1ListTeamNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List organizations
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public teamsV1ListTeams(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return TeamsV1ApiFp(this.configuration).teamsV1ListTeams(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch organization
     * @param {string} owner Owner of the namespace
     * @param {string} team_name Name
     * @param {V1Team} body Team body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public teamsV1PatchTeam(owner: string, team_name: string, body: V1Team, options?: any) {
        return TeamsV1ApiFp(this.configuration).teamsV1PatchTeam(owner, team_name, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch organization member
     * @param {string} owner Owner of the namespace
     * @param {string} team Team
     * @param {string} member_user User
     * @param {V1TeamMember} body Team body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public teamsV1PatchTeamMember(owner: string, team: string, member_user: string, body: V1TeamMember, options?: any) {
        return TeamsV1ApiFp(this.configuration).teamsV1PatchTeamMember(owner, team, member_user, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update organization
     * @param {string} owner Owner of the namespace
     * @param {string} team_name Name
     * @param {V1Team} body Team body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public teamsV1UpdateTeam(owner: string, team_name: string, body: V1Team, options?: any) {
        return TeamsV1ApiFp(this.configuration).teamsV1UpdateTeam(owner, team_name, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update organization member
     * @param {string} owner Owner of the namespace
     * @param {string} team Team
     * @param {string} member_user User
     * @param {V1TeamMember} body Team body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public teamsV1UpdateTeamMember(owner: string, team: string, member_user: string, body: V1TeamMember, options?: any) {
        return TeamsV1ApiFp(this.configuration).teamsV1UpdateTeamMember(owner, team, member_user, body, options)(this.fetch, this.basePath);
    }

}

/**
 * UsersV1Api - fetch parameter creator
 * @export
 */
export const UsersV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersV1GetUser(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersV1Api - functional programming interface
 * @export
 */
export const UsersV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersV1GetUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1User> {
            const localVarFetchArgs = UsersV1ApiFetchParamCreator(configuration).usersV1GetUser(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UsersV1Api - factory interface
 * @export
 */
export const UsersV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersV1GetUser(options?: any) {
            return UsersV1ApiFp(configuration).usersV1GetUser(options)(fetch, basePath);
        },
    };
};

/**
 * UsersV1Api - object-oriented interface
 * @export
 * @class UsersV1Api
 * @extends {BaseAPI}
 */
export class UsersV1Api extends BaseAPI {
    /**
     * 
     * @summary Login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersV1Api
     */
    public usersV1GetUser(options?: any) {
        return UsersV1ApiFp(this.configuration).usersV1GetUser(options)(this.fetch, this.basePath);
    }

}

/**
 * VersionsV1Api - fetch parameter creator
 * @export
 */
export const VersionsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionsV1GetLogHandler(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/log_handler`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionsV1GetVersions(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/version`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VersionsV1Api - functional programming interface
 * @export
 */
export const VersionsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionsV1GetLogHandler(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1LogHandler> {
            const localVarFetchArgs = VersionsV1ApiFetchParamCreator(configuration).versionsV1GetLogHandler(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionsV1GetVersions(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Versions> {
            const localVarFetchArgs = VersionsV1ApiFetchParamCreator(configuration).versionsV1GetVersions(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * VersionsV1Api - factory interface
 * @export
 */
export const VersionsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionsV1GetLogHandler(options?: any) {
            return VersionsV1ApiFp(configuration).versionsV1GetLogHandler(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionsV1GetVersions(options?: any) {
            return VersionsV1ApiFp(configuration).versionsV1GetVersions(options)(fetch, basePath);
        },
    };
};

/**
 * VersionsV1Api - object-oriented interface
 * @export
 * @class VersionsV1Api
 * @extends {BaseAPI}
 */
export class VersionsV1Api extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsV1Api
     */
    public versionsV1GetLogHandler(options?: any) {
        return VersionsV1ApiFp(this.configuration).versionsV1GetLogHandler(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsV1Api
     */
    public versionsV1GetVersions(options?: any) {
        return VersionsV1ApiFp(this.configuration).versionsV1GetVersions(options)(this.fetch, this.basePath);
    }

}

